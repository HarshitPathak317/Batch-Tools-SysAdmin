<#
.SYNOPSIS
  <Overview of script>

.DESCRIPTION
  <Brief description of script>

.PARAMETER -SampleParam
  <This parameter text will not be shown, since -SampleParam is not a real parameter listed in Param(). However, if a .PARAMETER help line is present and there is no Param(), all help text will fail.>

.PARAMETER LaunchedInCmd
  Used to indicate to this script when it has been launched in a Command Prompt windows (CMD.EXE)
  
  Formats output to the size of a standard Command Prompt (79 characters wide + 1) or to the size of a standard PowerShell window (119 characters winde + 1)

.PARAMETER LoadFunctions
  Use this switch to only load the functions in this script. The script main body execution will not run.

.INPUTS
  <Inputs if any, otherwise state None>

.OUTPUTS 
Log File
  The script log file stored in C:\Windows\Temp\<name>.log

.NOTES
  Version:        1.0
  Author:         <Name>
  Creation Date:  <Date>
  Purpose/Change: Initial script development

  Requires PSLogging module from 
  https://9to5it.com/powershell-logging-v2-easily-create-log-files/
  PowerShell Gallery:
  https://www.powershellgallery.com/packages/PSLogging/
  GitHub:
  https://www.powershellgallery.com/packages/PSLogging/

  AUTOGENERATED CONTENT
    The name, syntax, parameter list, parameter attribute table, common
    parameters, and remarks are automatically generated by the Get-Help cmdlet.

.EXAMPLE
  <Example explanation goes here>
  
  <Example goes here. Repeat this attribute for more than one example>

.LINK
about_Comment_Based_Help

.LINK
about_Requires

.LINK
about_Scripts

.LINK
https://ss64.com/ps/syntax-run.html

.LINK
https://ss64.com/ps/call.html

.LINK
about_Functions_CmdletBindingAttribute
#>

# "#Requires" - You can use a #Requires statement to prevent a script from running without specified modules or snap-ins and a specified version of PowerShell. For more information, see about_Requires.
# help about_Requires
# help about_PSSnapins
# e.g. "#Requires -Version 6" "#Requires -RunAsAdministrator"
#Requires -Modules PSLogging

# To insatll PSLogging module:
# https://docs.microsoft.com/en-us/powershell/developer/module/installing-a-powershell-module
# PowerShell v4:
# 	1. Find PSModulePath environment variable
# 		$Env:PSModulePath
# 		[Environment]::GetEnvironmentVariable("PSModulePath")
#	2. Find the PSLogging module
# 		.\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging
# 	3. Either copy the module to a location within the PSModulePath environment variable, or add the location of the module to the PSModulePath environment variable.
# 		3a. Copy the module to the location:
# 			# Install for Current User – $Home\Documents\WindowsPowerShell\Modules (%UserProfile%\Documents\WindowsPowerShell\Modules)
# 				$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 				$Destination = "$Home\Documents\WindowsPowerShell\Modules"
# 				Copy-Item "$newModule" -Destination "$Destination\PSLogging" -Recurse
# 			# Install for All Users – $Env:ProgramFiles\WindowsPowerShell\Modules (%ProgramFiles%\WindowsPowerShell\Modules)
# 				$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 				$Destination = "$Env:ProgramFiles\WindowsPowerShell\Modules"
# 				Copy-Item "$newModule" -Destination "$Destination\PSLogging" -Recurse
# 		3b. Add the module's path to the PSModulePath environment variable
# 			$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 			$p = [Environment]::GetEnvironmentVariable("PSModulePath")
# 			$p += ";$newModule"
# 			[Environment]::SetEnvironmentVariable("PSModulePath",$p)
# PowerShell v5: (and above)
# 	Find-Module -Name "PSLogging*" | Install-Module -Scope AllUsers 
# Accepted values: CurrentUser, AllUsers
# 	Update-Module PSLogging -Force

#-----------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------[Header]--------------------------------------------------------

# Index:
# 1. <# Help #>
# 2. #Requires
# 3. [Header]
# 4. [Script Parameters]
# 5. [Initialisations]
# 6. [Modules]
# 7. [Declarations]
# 8. [Functions]
# 9. [Execution]
# 10. [Footer]

# Tested with PowerShell versions:
# 5.1
# $PSVersionTable.PSVersion

# To run from PowerShell command line:
# https://ss64.com/ps/syntax-run.html
# https://ss64.com/ps/call.html
# help about_Scripts
# & "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1"
# & "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Verbose -Debug
# & "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Verbose -Debug -LaunchedInCmd
# https://ss64.com/ps/source.html
# . "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1"
# . "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Verbose -Debug
# . "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Verbose -Debug -LaunchedInCmd

# To run help:
# Get-Help "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Full
# Example help file:
# Get-Help Get-ChildItem
# Get-Help Get-ChildItem -Full

# Execution Policy:
# $oldExecutionPolicy = Get-ExecutionPolicy
# Set-ExecutionPolicy -ExecutionPolicy RemoteSigned
# Set-ExecutionPolicy -ExecutionPolicy Bypass
# Set-ExecutionPolicy $oldExecutionPolicy

#-----------------------------------------------------------------------------------------------------------------------
#--------------------------------------------------[Script Parameters]--------------------------------------------------

# Debugging: absolutely NO commands can come before Param (except for [CmdletBinding()] )
# Debugging: You must have a script parameter defined here if you have the Help Topic .PARAMETER defined above.
# https://ss64.com/ps/syntax-args.html

#[CmdletBinding()]
#[CmdletBinding(SupportsShouldProcess=$true)]

#Script parameters go here
Param (
  #Script parameters go here
  # Debugging: You must have a script parameter defined here if you have the Help Topic .PARAMETER defined above.
  # help about_Functions_Advanced_Parameters
  # https://ss64.com/ps/syntax-args.html
  # https://ss64.com/ps/syntax-automatic-variables.html

  [Parameter(Mandatory=$false)]
  [switch]$LaunchedInCmd = $false,

  [Parameter(Mandatory=$false)]
  [switch]$LoadFunctions = $false
)


#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
If (-Not $LoadFunctions) {
# Only load functions of script. Do not execute Main script block.
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------[Initialisations]---------------------------------------------------

Write-Verbose `n # New line (carriage return and newline (CRLF), `r`n)
Write-Host `n

# Script name (including extension)
$ScriptName = $MyInvocation.MyCommand.Name
Write-Verbose "Script name:"
Write-Verbose "$ScriptName"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

# Script dir (home directory of script)
#https://stackoverflow.com/questions/801967/how-can-i-find-the-source-path-of-an-executing-script/6985381#6985381
$ScriptDir = Split-Path $script:MyInvocation.MyCommand.Path
Write-Verbose "Script home directory:"
Write-Verbose "$ScriptDir"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

# Script path (full file path & name & extension of currently running script)
$ScriptPath = $MyInvocation.MyCommand.Path
Write-Verbose "Script full path:"
Write-Verbose "$ScriptPath"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

#Set Error Action to Silently Continue
$ErrorActionPreference = 'SilentlyContinue'
#Set Error Action to Continue
$ErrorActionPreference = 'Continue'

#Set Verbose message display
#$VerbosePreference = "SilentlyContinue"
#$VerbosePreference = "Continue"

#Set Debug message display
# help about_Debuggers
#$DebugPreference = "SilentlyContinue"
#$DebugPreference = "Continue"

#Set Progress Bar display
#* If the progress bar does not appear, check the value of the $ProgressPreference variable. If the value is set to SilentlyContinue, the progress bar is not displayed. For more information about Windows PowerShell preferences, see about_Preference_Variables.
#$ProgressPreference = "SilentlyContinue"
#$ProgressPreference = "Continue"

#Set Informational message display
#$InformationPreference = "SilentlyContinue"
#$InformationPreference = "Continue"

#Check Execution Policy
$RecommendedExecutionPolicy = "RemoteSigned"
Write-Verbose "Recommended Execution Policy = $RecommendedExecutionPolicy"
#Write-Host "Current Execution Policy =" (Get-ExecutionPolicy)
$startExecutionPolicy = Get-ExecutionPolicy
Write-Verbose "Current Execution Policy = $startExecutionPolicy"

#Check PowerShell version
$MinimumRequiredVersion = 6
# https://ss64.com/ps/get-host.html
# https://stackoverflow.com/questions/1825585/determine-installed-powershell-version
$PoShVersion = $PSVersionTable.PSVersion
# https://ss64.com/ps/if.html
IF ($PSVersionTable.PSVersion.Major -lt $MinimumRequiredVersion) {
    Write-Warning "This script requires at least PowerShell version $MinimumRequiredVersion. Running version $PoShVersion"
}
Write-Verbose "Minimum required PowerShell version = $MinimumRequiredVersion"
Write-Host "Current PowerShell version =" $PSVersionTable.PSVersion.Major . $PSVersionTable.PSVersion.Minor
Write-Host "Current PowerShell version =" $PSVersionTable.PSVersion.Major`.$PSVersionTable.PSVersion.Minor
#Write-Host "Current PowerShell version = $PSVersionTable.PSVersion.Major . $PSVersionTable.PSVersion.Minor"
Write-Host "Current PowerShell version =" $PSVersionTable.PSVersion.Major `b. `b$PSVersionTable.PSVersion.Minor
Write-Host "Current PowerShell version =" $PSVersionTable.PSVersion.Major `b. `b "$PSVersionTable.PSVersion.Minor"
Write-Host "Current PowerShell version =" $PSVersionTable.PSVersion.Major `b. `b"$PSVersionTable.PSVersion.Minor"

#-----------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------[Modules]-------------------------------------------------------

#Import Modules & Snap-ins
Write-Verbose "Importing modules..."
Write-Verbose `n # New line (carriage return and newline, `r`n)

Import-Module PSLogging

Write-Verbose `r`n
Write-Verbose "Module import complete..."

#-----------------------------------------------------------------------------------------------------------------------
#-----------------------------------------------------[Declarations]----------------------------------------------------

#Script Version
$sScriptVersion = '1.0'

#Log File Info
$scriptPath = Split-Path -parent $MyInvocation.MyCommand.Definition # PoSh v2 compatible - thanks to https://stackoverflow.com/questions/5466329/whats-the-best-way-to-determine-the-location-of-the-current-powershell-script
Write-Verbose "scriptPath = $scriptPath"
Write-Verbose "scriptPath = $PSScriptRoot" # PoSh v3 compatible - This is an automatic variable set to the current file's/module's directory
$sLogPath = $scriptPath
$sLogPath = $PSScriptRoot
$yesterday = [DateTime]::Today.AddDays(-1)
$TodaysDate = Get-Date -Format FileDate
Write-Verbose "Date code = $TodaysDate"
$sLogName = $MyInvocation.MyCommand.Name.Substring(0,$MyInvocation.MyCommand.Name.Length-4) + "_" + $TodaysDate + ".log"
Write-Verbose "LogName = $sLogName"
$sLogFile = Join-Path -Path $sLogPath -ChildPath $sLogName
Write-Verbose "LogFile = $sLogFile"

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Only load functions of script. Do not execute Main script block.
}
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------[Functions]------------------------------------------------------

# help about_Functions
# help about_Functions_Advanced
# help about_Functions_Advanced_Methods
# help about_Functions_Advanced_Parameters
# Get-Verb

<#

Function <FunctionName> {
  Param ()

  Begin {
    Write-LogInfo -LogPath $sLogFile -Message '<description of what is going on>...'
  }

  Process {
    Try {
      <code goes here>
    }

    Catch {
      Write-LogError -LogPath $sLogFile -Message $_.Exception -ExitGracefully
      Break
    }
  }

  End {
    If ($?) {
      Write-LogInfo -LogPath $sLogFile -Message 'Completed Successfully.'
      Write-LogInfo -LogPath $sLogFile -Message ' '
    }
  }
} # End <FunctionName> function ----------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#>

function Start-PSAdmin {Start-Process PowerShell -Verb RunAs}

function Get-ScriptDirectory1 #https://stackoverflow.com/questions/801967/how-can-i-find-the-source-path-of-an-executing-script/6985381#6985381
{
    Split-Path $script:MyInvocation.MyCommand.Path
} # End Get-ScriptDirectory function -----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

function Get-ScriptDirectory2 { #https://stackoverflow.com/questions/1183183/path-of-currently-executing-powershell-script#1183197
    # For PowerShell 3.0 users - following works for both modules and script files:
    Split-Path -parent $PSCommandPath
} # End Get-ScriptDirectory function -----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

function Get-ScriptDirectory3 #https://stackoverflow.com/questions/1183183/path-of-currently-executing-powershell-script#1183197
{
  $Invocation = (Get-Variable MyInvocation -Scope 1).Value
  Split-Path $Invocation.MyCommand.Path
} # End Get-ScriptDirectory function -----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
#.SYNOPSIS
# <Overview of script>

#.DESCRIPTION
# <Brief description of script>

#.PARAMETER HRtype
# Horizontal Rule types. Accepted types are 'SingleLine', 'DoubleLine', 'DashedLine', and 'BlankLine'. 

#.NOTES
# <Notes Here>
Function Write-HorizontalRule {
  Param (
    #Script parameters go here
    # https://ss64.com/ps/syntax-args.html
    [Parameter(Mandatory=$false,Position=0)]
    [string]$HRtype = 'SingleLine'
  )
  
  # help about_Automatic_Variables
  # help about_If
  # help about_Comparison_Operators
  # https://ss64.com/ps/if.html
  IF ($LaunchedInCmd -eq $true) {
    # Print horizontal rule styles here using Write-Host instead of Write-Verbose, since that would add "VERBOSE: " to the beginning of each line and prevent the horizontal rule from lining up on the screen properly.
	# Command Prompt character width: 79
    IF ($HRtype -eq "DoubleLine") {
      Write-Host ===============================================================================
    } ELSEIF ($HRtype -eq "DashedLine") {
      Write-Host "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "SingleLine") {
      #Write-Host -------------------------------------------------------------------------------- # This too long
      Write-Host -------------------------------------------------------------------------------
    } ELSEIF (-Not $HRtype) {
      Write-Host -------------------------------------------------------------------------------
    } ELSE {
      Write-Verbose "PowerShell Script launched in cmd.exe = $LaunchedInCmd"
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
    }
  } ELSEIF ($LaunchedInCmd -eq $false) {
    # PowerShell window character width: 119
    IF ($HRtype -eq "DoubleLine") {
      Write-Host =======================================================================================================================
    } ELSEIF ($HRtype -eq "DashedLine") {
      Write-Host - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    } ELSEIF ($HRtype -eq "SingleLine") {
      #Write-Host ------------------------------------------------------------------------------------------------------------------------ # This too long
      Write-Host -----------------------------------------------------------------------------------------------------------------------
    } ELSEIF (-Not $HRtype) {
      Write-Host -----------------------------------------------------------------------------------------------------------------------
    } ELSE {
      Write-Verbose "PowerShell Script launched in cmd.exe = $LaunchedInCmd"
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
    }
  }
} # End Write-HorizontalRule function ----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

Function Write-HorizontalRuleAdv {
  
  # .DESCRIPTION
  #  <Brief description of script>
  
  # .PARAMETER HRtype
  # Horizontal Rule types. Accepted types are 'SingleLine', 'DoubleLine', 'DashedLine', and 'BlankLine'. 
  
  # .PARAMETER Endcaps
  # Add a character to each end of the horizontal rule. Default is '#'. Set a different endcap character using -EndcapCharacter <single character>
  
  Param (
    #Script parameters go here
    # https://ss64.com/ps/syntax-args.html
    [Parameter(Mandatory=$false,Position=0)]
    [string]$HRtype = 'SingleLine',
    
    [Parameter(Mandatory=$false)]
    [switch]$Endcaps = $false,

    [Parameter(Mandatory=$false)]
    [string]$EndcapCharacter = '#',
    
    [Parameter(Mandatory=$false)]
    [switch]$IsWarning = $false,

    [Parameter(Mandatory=$false)]
    [switch]$IsVerbose = $false,

    [Parameter(Mandatory=$false)]
    [switch]$MaxLineLength = $false
  )
  
  # Function name:
  # https://stackoverflow.com/questions/3689543/is-there-a-way-to-retrieve-a-powershell-function-name-from-within-a-function#3690830
  #$FunctionName = (Get-PSCallStack | Select-Object FunctionName -Skip 1 -First 1).FunctionName
  #$FunctionName = (Get-Variable MyInvocation -Scope 1).Value.MyCommand.Name
  $FunctionName = $PSCmdlet.MyInvocation.MyCommand.Name
  Write-Verbose "Running function: $FunctionName"
  
  # help about_Automatic_Variables
  # help about_If
  # help about_Comparison_Operators
  # https://ss64.com/ps/if.html
  IF ($LaunchedInCmd) {
    # Print horizontal rule styles here using Write-Host instead of Write-Verbose, since that would add "VERBOSE: " to the beginning of each line and prevent the horizontal rule from lining up on the screen properly.
	# Command Prompt character width: 79
    IF ($HRtype -eq "DoubleLine") {
      $HRoutput = "==============================================================================="
    } ELSEIF ($HRtype -eq "DashedLine") {
      $HRoutput = "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "BlankLine") {
      $HRoutput = "                                                                               "
    } ELSEIF ($HRtype -eq "SingleLine") {
      #HRoutput = "--------------------------------------------------------------------------------" # This too long
      $HRoutput = "-------------------------------------------------------------------------------"
    } ELSEIF (-Not $HRtype) {
      $HRoutput = "-------------------------------------------------------------------------------"
    } ELSE {
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
      Return
    }
  } ELSE {
    # PowerShell window character width: 119
    IF ($HRtype -eq "DoubleLine") {
      $HRoutput = "======================================================================================================================="
    } ELSEIF ($HRtype -eq "DashedLine") {
      $HRoutput = "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "BlankLine") {
      $HRoutput = "                                                                                                                       "
    } ELSEIF ($HRtype -eq "SingleLine") {
      #HRoutput = "------------------------------------------------------------------------------------------------------------------------" # This too long
      $HRoutput = "-----------------------------------------------------------------------------------------------------------------------"
    } ELSEIF (-Not $HRtype) {
      $HRoutput = "-----------------------------------------------------------------------------------------------------------------------"
    } ELSE {
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
      Return
    }
  }
  
  # Command Prompt character width: 79
  # PowerShell window character width: 119
  $MaxLength = $HRoutput.Length
  
  IF ($IsWarning -eq $true -or $IsVerbose -eq $true) {
    #WARNING: 
    #VERBOSE: 
    #123456789
    $MaxLength = $MaxLength - 9
    $HRoutput = ($HRoutput).Substring(9,$MaxLength)
  }
  
  IF ($Endcaps -eq $true) {
    #$EndcapLength = $MaxLength - 2
    $MaxLength = $MaxLength - 2
    #$HRoutput = ($HRoutput).Substring(1,$EndcapLength)
    $HRoutput = ($HRoutput).Substring(1,$MaxLength)
    $HRoutput = "$EndcapCharacter$HRoutput$EndcapCharacter"
  }
  
  $MaxLineLengthOutput = $MaxLength
  
  # Write output
  
  IF ($MaxLineLength -eq $true) {
    Write-Output $MaxLineLengthOutput
  } ELSEIF ($IsWarning -eq $true) {
    Write-Warning $HRoutput -WarningAction Continue
  } ELSEIF ($IsVerbose -eq $true) {
    # Set Verbose message display
    # $VerbosePreference = "Continue"
    # $VerbosePreference = "SilentlyContinue"
    #$OrigVerbosePreference = $VerbosePreference
    #$VerbosePreference = "Continue"
    Write-Verbose $HRoutput
    #$VerbosePreference = $OrigVerbosePreference
  } ELSE {
    Write-Host $HRoutput
  }

} # End Write-HorizontalRuleAdv function -------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

If ($LoadFunctions) {
  #https://stackoverflow.com/questions/2022326/terminating-a-script-in-powershell
  # Only load functions of script. Do not execute Main script block.
  Return
}

#-----------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------[Execution]------------------------------------------------------

Start-Log -LogPath $sLogPath -LogName $sLogName -ScriptVersion $sScriptVersion

# run "help about_comment_based_help" - I want to display formatted help for a function or script. Use comment-based help instead - run "help about_comment_based_help". PowerShell will format it for you.
# https://technet.microsoft.com/en-us/library/dd819489.aspx
# Write-Host - You almost never need to do it. 
# Write-Information - Only works if $ErrorActionPreference = 'Continue' Does not work if = 'SilentlyContinue' Prints grey text. Can be overridden with -InformationAction Continue
# Write-Verbose - Writes yellow VERBOSE: messages (9 chars). Can be turned on/off by running script with -Verbose parameter.
# Write-Debug - Pauses script execution every time it's called. Can be turned on/off by running script with -Debug parameter.
# Write-Warning - Writes yellow WARNING: messages (9 chars), regardless of -Verbose or -Debug switches.
# Write-Error - Only works if $ErrorActionPreference = 'Continue' Does not work if = 'SilentlyContinue' Prints in red text, "Entire Script path: Error message." E.g. C:\Users\G\Documents\SpiderOak Hive\Consulting\2018-04-06 SodaLakeNetworking\Manage-SodaLakeData.ps1 : TEST ERROR.
# Write-Output - I just need to display some text! Do you really? PowerShell works better with objects, and that's what your script should be outputting, by means of Write-Output. Let PowerShell's Format cmdlets turn those objects into text like lists and tables.
# Write-Progress - Makes a green and yellow progress bar appear at the top part of the command window.

Write-Host "Script Main beginning." $MyInvocation.MyCommand.Name
Write-Information -MessageData "Will only display if set defaults display infromational messages."
Write-Information -MessageData "Test infromational messages." -InformationAction Continue
Write-Verbose "Script Main beginning. $ScriptName"
Write-Verbose "Debug preference = $DebugPreference"
Write-Debug "Script Main beginning." # NOTE: Writing debug text will PAUSE script execution automatically.
Write-Warning "Test Warning."
Write-Error -Message "TEST ERROR. TEST ERROR. TEST ERROR. TEST ERROR." -Category InvalidData -ErrorId TEST_ID
For ($I = 1; $I -le 100; $I++) {Write-Progress -Activity "Test in progress..." -Status "$I% Complete:" -PercentComplete $I;}
#For ($I = 1; $I -le 1000; $I++) {Write-Progress -Activity "Test in progress..." -Status "$($I / 10)% Complete:" -PercentComplete ($I/10)}

# Write-LogInfo – Writes an informational message to the log file
# Write-LogWarning – Writes a warning message to the log file (with the format of WARNING: )
# Write-LogError – Writes an error message to the log file (with the format of ERROR: ). In addition, optionally calls Stop-Log to end logging and terminate the calling script on fatal error.

Write-LogInfo -LogPath $sLogFile -Message "Test log info write."
Write-LogWarning -LogPath $sLogFile -Message "Test log warning write."
Write-LogError -LogPath $sLogFile -Message "Test log error write."

# https://ss64.com/ps/read-host.html
#$Choice = Read-Host -Prompt "Enter text to be caputred" # CHOICE (Read-Host automatically adds colon at the end of prompt)
# https://ss64.com/ps/syntax-esc.html
#Write-Host "Captured text = `"$Choice`""

#Read-Host "Press ENTER key to continue . . . " # PAUSE (Read-Host automatically adds colon : at the end of prompt)
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

# -----------------------------------------------------------------------------------------------------------------------
# =======================================================================================================================
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#
#
##Script MAIN Execution goes here
Clear-Host # CLS

Write-Host "Write-HorizontalRule Help output:"
Write-HorizontalRule
Get-Help Write-HorizontalRule
Get-Help Write-HorizontalRule -Full
Write-HorizontalRule
Write-Verbose "Script MAIN execution. $ScriptName"
Write-Host "Script MAIN execution." $MyInvocation.MyCommand.Name
Write-HorizontalRule -HRtype DoubleLine
Write-HorizontalRule -HRtype DashedLine
Write-HorizontalRule -HRtype SingleLine
Write-HorizontalRule -HRtype IntentionallyThrowError -Verbose

Write-Host `n
Write-Host "Write-HorizontalRuleAdv Help output:"
Write-HorizontalRule
Get-Help Write-HorizontalRuleAdv -Full
Write-HorizontalRule

Write-HorizontalRuleAdv -HRtype SingleLine -Verbose
Write-HorizontalRuleAdv -HRtype DashedLine -Verbose
Write-HorizontalRuleAdv -HRtype DoubleLine -Verbose
Write-HorizontalRuleAdv -HRtype SingleLine -Endcaps
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `|
Write-HorizontalRuleAdv -HRtype DashedLine -Endcaps
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `|
Write-HorizontalRuleAdv -HRtype DoubleLine -Endcaps

Write-HorizontalRuleAdv -HRtype SingleLine -IsVerbose
Write-HorizontalRuleAdv -HRtype DashedLine -IsVerbose
Write-HorizontalRuleAdv -HRtype DoubleLine -IsVerbose
Write-HorizontalRuleAdv -HRtype SingleLine -Endcaps -IsVerbose
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `| -IsVerbose
Write-HorizontalRuleAdv -HRtype DashedLine -Endcaps -IsVerbose
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `| -IsVerbose
Write-HorizontalRuleAdv -HRtype DoubleLine -Endcaps -IsVerbose

Write-HorizontalRuleAdv -HRtype SingleLine -IsWarning
Write-HorizontalRuleAdv -HRtype DashedLine -IsWarning
Write-HorizontalRuleAdv -HRtype DoubleLine -IsWarning
Write-HorizontalRuleAdv -HRtype SingleLine -Endcaps -IsWarning
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `| -IsWarning
Write-HorizontalRuleAdv -HRtype DashedLine -Endcaps -IsWarning
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `| -IsWarning
Write-HorizontalRuleAdv -HRtype DoubleLine -Endcaps -IsWarning

PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

# =======================================================================================================================

Clear-Host # CLS
Write-Verbose `n
Write-HorizontalRuleAdv -HRtype DoubleLine -IsVerbose
Write-Verbose `n
Write-Verbose "Script body."

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Months in 3 letters."
# https://www.business.com/articles/powershell-for-loop/
# help about_For
For ($m=1; $m -lt 13; $m++) {
    $m
    Get-Date -Month $m -UFormat %b
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Test CSV ForEach loop 1."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test1.csv"
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
$CSVheaders = "col1,col2"
$CSVarray = (Get-Content $CSVfile).split(",")
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
ForEach ($column in $CSVarray) {
	Write-Host "Start of loop."
    Write-Host "Whole:     $column"
	Write-Host "Array One: $column[0]"
	Write-Host "Array Two: $column[1]"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Test CSV ForEach loop 2."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test2.csv"
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
$CSVheaders = "col1,col2"
$CSVarray = (Get-Content $CSVfile).split(",")
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
ForEach ($line in $CSVarray) {
	Write-Host "Start of loop."
    Write-Host "Whole:     $line"
	Write-Host "Array One: $line[0]"
	Write-Host "Array Two: $line[1]"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Test CSV ForEach loop 3."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test3.csv"
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
$CSVheaders = "col1,col2"
$CSVarray = (Get-Content $CSVfile).split(",")
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
ForEach ($line in $CSVarray) {
	Write-Host "Start of loop."
    Write-Host "Whole:     $line"
	Write-Host "Array One: $line[0]"
	Write-Host "Array Two: $line[1]"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype SingleLine
Write-Host `n
Write-Host "Test Import-CSV ForEach loop."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test3.csv"
$CSVheaders = "col1,col2"
$CSVarray = (Get-Content $CSVfile).split(",")
$CSVimport = Import-CSV $CSVfile -Delimiter "," -Header $CSVheaders
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
Import-CSV -Path $CSVfile -Delimiter "," -Header $CSVheaders | ForEach {
	Write-Host "Start of loop."
    Write-Host "Whole:     $_"
	Write-Host "Array One: $_[0]"
	Write-Host "Array Two: $_[1]"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype SingleLine
Write-Host `n
Write-Host "Test Import-CSV ForEach loop 2."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test4.csv"
$CSVheaders = "col1,col2,col3"
$CSVarray = (Get-Content $CSVfile).split(",")
$CSVimport = Import-CSV -Path $CSVfile -Delimiter "," -Header $CSVheaders
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
Import-CSV -Path $CSVfile | ForEach {
	Write-Host "Start of loop."
    Write-Host "Whole:     $_"
	Write-Host "Col call: $($_."header 1")"
	Write-Host "Col call: $($_."header 2")"
	Write-Host "Col call: $($_.H1)"
	Write-Host "Col call: $($_."header 4")"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DoubleLine
Write-Host `n
Write-Host "Perform actions from a CSV file."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\commands.csv"
$CSVheaders = "Program,Exec Command"
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
# The foreach alias also supports beginning command blocks, middle command blocks, and end command blocks. The beginning and end command blocks run once, and the middle command block runs every time the Foreach loop steps through a collection or array.
# <command> | foreach {<beginning command_block>}{<middle command_block>}{<ending command_block>}
Import-CSV -Path $CSVfile | ForEach-Object {
	# beginning (runs once)
	Write-Host `n
	Write-Host "Beginning block: ForEach"
	Write-Host `n
}{
    # middle (loop)
	Write-Host "$_"
	
	# https://discoposse.com/2012/01/23/csv-yeah-you-know-me-powershell-and-the-import-csv-cmdlet-part-1/
	# https://discoposse.com/2012/01/23/csv-yeah-you-know-me-powershell-and-the-import-csv-cmdlet-part-2/
	# https://discoposse.com/2012/12/29/csv-yeah-you-know-me-powershell-and-the-import-csv-cmdlet-part-3/
	
	$HostProgram = $_.Program
	$CommandToExecute = $_."Exec Command"
	
	Write-Host "Host Program: $HostProgram"
	Write-Host "Expand Var: $($_.Program)"
	
	Write-Host "Command to execute: $CommandToExecute"
	Write-Host "Expand Var: $($_."Exec Command")"
	Write-Host `n
}{
	# ending (runs once)
	Write-Host "Ending block: ForEach"
	Write-Host `n
}

Write-Host "Loop is over."
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Choice dialog example."
# If run from shell, will create a dialog box. If run in script, will show choice text in command line.
# https://social.technet.microsoft.com/wiki/contents/articles/24030.powershell-demo-prompt-for-choice.aspx
$Title = "Welcome"
$Info = "Just to Demo Prompt for Choice"
# &Power makes P a Hot Key. 
#$Options = [System.Management.Automation.Host.ChoiceDescription[]] @("&Power", "&Shell", "&Quit")
$ChoicePower = New-Object System.Management.Automation.Host.ChoiceDescription "&Power", "[P]ower, prints `"Power`" in green"
$ChoiceShell = New-Object System.Management.Automation.Host.ChoiceDescription "&Shell", "[S]hell, prints `"Shell`" in green"
$ChoiceQuit = New-Object System.Management.Automation.Host.ChoiceDescription "&Quit", "[Q]uit, prints `"Good Bye!!!`" in green"
$Options = [System.Management.Automation.Host.ChoiceDescription[]]($ChoicePower, $ChoiceShell, $ChoiceQuit)
# default choice: 0 = first Option, 1 = second option, etc.
[int]$defaultchoice = 1
$answer = $host.UI.PromptForChoice($Title, $Info, $Options, $defaultchoice)
#help about_switch
switch($answer)
{
    0 {Write-Host "Power" -ForegroundColor Green}
    1 {Write-Host "Shell" -ForegroundColor Green}
    2 {Write-Host "Good Bye!!!" -ForegroundColor Green}
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Looping Choice dialog example."
# If run from shell, will create a dialog box. If run in script, will show choice text in command line.
# https://social.technet.microsoft.com/wiki/contents/articles/24030.powershell-demo-prompt-for-choice.aspx
$Title = "Welcome"
$Info = @"
Looping Prompt for Choice

P - Power
S - Shell
Q - Quit
 
Select a choice:
"@
# &Power makes P a Hot Key. 
#$Options = [System.Management.Automation.Host.ChoiceDescription[]] @("&Power", "&Shell", "&Quit")
$ChoicePower = New-Object System.Management.Automation.Host.ChoiceDescription "&Power", "[P]ower, prints `"Power`" in green"
$ChoiceShell = New-Object System.Management.Automation.Host.ChoiceDescription "&Shell", "[S]hell, prints `"Shell`" in green"
$ChoiceQuit = New-Object System.Management.Automation.Host.ChoiceDescription "&Quit", "[Q]uit, prints `"Good Bye!!!`" in green"
$Options = [System.Management.Automation.Host.ChoiceDescription[]]($ChoicePower, $ChoiceShell, $ChoiceQuit)
# default choice: 0 = first Option, 1 = second option, etc.
[int]$defaultchoice = 1
do
{
	Clear-Host # CLS
	$answer = $host.UI.PromptForChoice($Title, $Info, $Options, $defaultchoice)
	#help about_switch
	switch($answer)
	{
		0 {Write-Host "Power" -ForegroundColor Green}
		1 {Write-Host "Shell" -ForegroundColor Green}
		2 {Write-Host "Good Bye!!!" -ForegroundColor Green}
	}
	Write-Host `n
	PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
}
until ($answer -eq '2') 

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Run External Script."
$ExternalScript = "$Home\Documents\SodaLake\PowerShell\Choice\DialogDemo.ps1"
PowerShell.exe -NoProfile -ExecutionPolicy Bypass -Command "& '$ExternalScript'"
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-Verbose "/Script body."

# =======================================================================================================================

Write-HorizontalRuleAdv -HRtype DoubleLine
Write-Host `n
Write-Host "End of script" $MyInvocation.MyCommand.Name
Write-Host `n
PAUSE
Write-Host `n

#Script MAIN Execution ends here
#
#
#
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# =======================================================================================================================
# -----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------[Footer]---------------------------------------------------------

Write-Verbose "Script Main end. $ScriptName"
Write-Debug "End-of-script. $ScriptName"
Write-LogInfo -LogPath $sLogFile -Message "End of script $ScriptName"
Stop-Log -LogPath $sLogFile
Write-Output $sLogFile
