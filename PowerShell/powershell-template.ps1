<#
.SYNOPSIS
  <Overview of script>

.DESCRIPTION
  <Brief description of script>

.PARAMETER -SampleParam
  <This parameter text will not be shown, since -SampleParam is not a real parameter listed in Param(). However, if a .PARAMETER help line is present and there is no Param(), all help text will fail.>

.PARAMETER LaunchedInCmd
  Used to indicate to this script when it has been launched in a Command Prompt windows (CMD.EXE)
  
  Formats output to the size of a standard Command Prompt (79 characters wide + 1) or to the size of a standard PowerShell window (119 characters winde + 1)

.PARAMETER LoadFunctions
  Use this switch to only load the functions in this script. The script main body execution will not run.

.INPUTS
  <Inputs if any, otherwise state None>

.OUTPUTS 
Log File
  The script log file stored in C:\Windows\Temp\<name>.log

.NOTES
  Version:        1.0
  Author:         <Name>
  Creation Date:  <Date>
  Purpose/Change: Initial script development

  Requires PSLogging module from 
  https://9to5it.com/powershell-logging-v2-easily-create-log-files/
  PowerShell Gallery:
  https://www.powershellgallery.com/packages/PSLogging/
  GitHub:
  https://www.powershellgallery.com/packages/PSLogging/

  AUTOGENERATED CONTENT
    The name, syntax, parameter list, parameter attribute table, common
    parameters, and remarks are automatically generated by the Get-Help cmdlet.

.EXAMPLE
  <Example explanation goes here>
  
  <Example goes here. Repeat this attribute for more than one example>

.LINK
about_Comment_Based_Help

.LINK
about_Requires

.LINK
about_Scripts

.LINK
https://ss64.com/ps/syntax-run.html

.LINK
https://ss64.com/ps/call.html

.LINK
about_Functions_CmdletBindingAttribute
#>

#-----------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------#Requires-------------------------------------------------------

# "#Requires" - You can use a #Requires statement to prevent a script from running without specified modules or snap-ins and a specified version of PowerShell. For more information, see about_Requires.
# help about_Requires
# help about_PSSnapins
# e.g. "#Requires -Version 6" "#Requires -RunAsAdministrator"
#Requires -Modules PSLogging

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# To insatll PSLogging module:
# https://docs.microsoft.com/en-us/powershell/developer/module/installing-a-powershell-module
# PowerShell v4:
# 	1. Find PSModulePath environment variable
# 		$Env:PSModulePath
# 		[Environment]::GetEnvironmentVariable("PSModulePath")
#	2. Find the PSLogging module
# 		.\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging
# 	3. Either copy the module to a location within the PSModulePath environment variable, or add the location of the module to the PSModulePath environment variable.
# 		3a. Copy the module to the location:
# 			# Install for Current User – $Home\Documents\WindowsPowerShell\Modules (%UserProfile%\Documents\WindowsPowerShell\Modules)
# 				$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 				$Destination = "$Home\Documents\WindowsPowerShell\Modules"
# 				Copy-Item "$newModule" -Destination "$Destination\PSLogging" -Recurse
# 			# Install for All Users – $Env:ProgramFiles\WindowsPowerShell\Modules (%ProgramFiles%\WindowsPowerShell\Modules)
# 				$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 				$Destination = "$Env:ProgramFiles\WindowsPowerShell\Modules"
# 				Copy-Item "$newModule" -Destination "$Destination\PSLogging" -Recurse
# 		3b. Add the module's path to the PSModulePath environment variable
# 			$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 			$p = [Environment]::GetEnvironmentVariable("PSModulePath")
# 			$p += ";$newModule"
# 			[Environment]::SetEnvironmentVariable("PSModulePath",$p)
# PowerShell v5: (and above)
# 	Find-Module -Name "PSLogging*" | Install-Module -Scope AllUsers 
# Accepted values: CurrentUser, AllUsers
# 	Update-Module PSLogging -Force

#-----------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------[Header]--------------------------------------------------------

# Index:
# 1. <# Help #>
# 2. #Requires
# 3. [Header]
# 4. [Script Parameters]
# 5. [Initialisations]
# 6. [Modules]
# 7. [Declarations]
# 8. [Functions]
# 9. [Execution]
# 10. [Footer]

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Tested with PowerShell versions:
# 5.1
# Get PowerShell version:
# $PSVersionTable.PSVersion

# To run from PowerShell command line:
# https://ss64.com/ps/syntax-run.html
# https://ss64.com/ps/call.html
# https://ss64.com/ps/syntax-scriptblock.html
# When passing a variable to a scriptblock it is important to consider the variable scope.
#    Each time the scriptblock is run; it will dynamically read the current value of the variable.
#    When a scriptblock is run using the “&” (call) operator, updates to a variable are not reflected in the parent scope.
#    When a scriptblock is run using the “.” (dot) operator, updates to a variable apply to the current scope.
# help about_Scripts
# & "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1"
# & "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Verbose -Debug
# & "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Verbose -Debug -LaunchedInCmd
# & "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -LoadFunctions
# https://ss64.com/ps/source.html
# . "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1"
# . "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Verbose -Debug
# . "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Verbose -Debug -LaunchedInCmd
# . "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -LoadFunctions

# To run help:
# Get-Help "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1"
# Get-Help "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Full
# Example help file:
# Get-Help Get-ChildItem
# Get-Help Get-ChildItem -Full

# Execution Policy:
# $oldExecutionPolicy = Get-ExecutionPolicy
# Set-ExecutionPolicy -ExecutionPolicy RemoteSigned
# Set-ExecutionPolicy -ExecutionPolicy Bypass
# Set-ExecutionPolicy $oldExecutionPolicy

#-----------------------------------------------------------------------------------------------------------------------
#--------------------------------------------------[Script Parameters]--------------------------------------------------

# Debugging: absolutely NO commands can come before Param (except for [CmdletBinding()] )
# Debugging: You must have a script parameter defined here if you have the Help Topic .PARAMETER defined above.
# https://ss64.com/ps/syntax-args.html

#[CmdletBinding()]
#[CmdletBinding(SupportsShouldProcess=$true)]

#Script parameters go here
Param (
  #Script parameters go here
  # Debugging: You must have a script parameter defined here if you have the Help Topic .PARAMETER defined above.
  # help about_Functions_Advanced_Parameters
  # https://ss64.com/ps/syntax-args.html
  # https://ss64.com/ps/syntax-automatic-variables.html

  [Parameter(Mandatory=$false)]
  [switch]$LaunchedInCmd = $false,

  [Parameter(Mandatory=$false)]
  [switch]$LoadFunctions = $false
)


#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------[Initialisations]---------------------------------------------------

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Skip [Initialisations] script block if -LoadFunctions is on.
If (-Not $LoadFunctions) {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Script name (including extension)
$ScriptName = $MyInvocation.MyCommand.Name
Write-Verbose "Script name:"
Write-Verbose "$ScriptName"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

# Script dir (home directory of script)
Write-Verbose "Script home directory:"
#https://stackoverflow.com/questions/801967/how-can-i-find-the-source-path-of-an-executing-script/6985381#6985381
$ScriptDir = Split-Path $script:MyInvocation.MyCommand.Path
Write-Verbose "$ScriptDir"
$ScriptDir = Split-Path -parent $MyInvocation.MyCommand.Definition # PoSh v2 compatible - thanks to https://stackoverflow.com/questions/5466329/whats-the-best-way-to-determine-the-location-of-the-current-powershell-script
Write-Verbose "$ScriptDir"
$ScriptDir = $PSScriptRoot # PoSh v3 compatible - This is an automatic variable set to the current file's/module's directory
Write-Verbose "$ScriptDir"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

# Script path (full file path & name & extension of currently running script)
$ScriptPath = $MyInvocation.MyCommand.Path
Write-Verbose "Script full path:"
Write-Verbose "$ScriptPath"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

#Set Error Action to Silently Continue
$ErrorActionPreference = 'SilentlyContinue'
#Set Error Action to Continue
$ErrorActionPreference = 'Continue'

#Set Verbose message display
#$VerbosePreference = "SilentlyContinue"
#$VerbosePreference = "Continue"

#Set Debug message display
# help about_Debuggers
#$DebugPreference = "SilentlyContinue"
#$DebugPreference = "Continue"

#Set Progress Bar display
#* If the progress bar does not appear, check the value of the $ProgressPreference variable. If the value is set to SilentlyContinue, the progress bar is not displayed. For more information about Windows PowerShell preferences, see about_Preference_Variables.
#$ProgressPreference = "SilentlyContinue"
#$ProgressPreference = "Continue"

#Set Informational message display
#$InformationPreference = "SilentlyContinue"
#$InformationPreference = "Continue"

#Check Execution Policy
$RecommendedExecutionPolicy = "RemoteSigned"
Write-Verbose "Recommended Execution Policy = $RecommendedExecutionPolicy"
#Write-Host "Current Execution Policy =" (Get-ExecutionPolicy)
$startExecutionPolicy = Get-ExecutionPolicy
Write-Verbose "Current Execution Policy = $startExecutionPolicy"

#Check PowerShell version
$MinimumRequiredVersion = 6
# https://ss64.com/ps/get-host.html
# https://stackoverflow.com/questions/1825585/determine-installed-powershell-version
$PoShVersion = $PSVersionTable.PSVersion
Write-Verbose "Minimum required PowerShell version = $MinimumRequiredVersion"
Write-Verbose "Current PowerShell version = $($PSVersionTable.PSVersion.Major).$($PSVersionTable.PSVersion.Minor)"
# https://ss64.com/ps/if.html
IF ($PSVersionTable.PSVersion.Major -lt $MinimumRequiredVersion) {
    Write-Warning "This script requires at least PowerShell version $MinimumRequiredVersion. Running version $PoShVersion"
	Write-Debug "This script requires at least PowerShell version $MinimumRequiredVersion. Running version $PoShVersion"
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}
# Skip [Initialisations] script block if -LoadFunctions is on.
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------[Modules]-------------------------------------------------------

#Import Modules & Snap-ins
Write-Verbose "Importing modules..."
Write-Verbose `n # New line (carriage return and newline, `r`n)

Import-Module PSLogging

Write-Verbose `r`n
Write-Verbose "Module import complete..."

#-----------------------------------------------------------------------------------------------------------------------
#-----------------------------------------------------[Declarations]----------------------------------------------------

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Skip [Declarations] script block if -LoadFunctions is on.
If (-Not $LoadFunctions) {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#Script Version
$sScriptVersion = '1.0'

#Log File Info
$sLogPath = $ScriptDir
$yesterday = [DateTime]::Today.AddDays(-1)
$TodaysDate = Get-Date -Format FileDate
Write-Verbose "Date code = $TodaysDate"
$sLogName = $MyInvocation.MyCommand.Name.Substring(0,$MyInvocation.MyCommand.Name.Length-4) + "_" + $TodaysDate + ".log"
Write-Verbose "LogName = $sLogName"
$sLogFile = Join-Path -Path $sLogPath -ChildPath $sLogName
Write-Verbose "LogFile = $sLogFile"

# Create Log file if we don't have one already
If (!($sLogPath)) { Start-Log -LogPath $sLogPath -LogName $sLogName -ScriptVersion $sScriptVersion }

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}
# Skip [Declarations] script block if -LoadFunctions is on.
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------[Functions]------------------------------------------------------

# help about_Functions
# help about_Functions_Advanced
# help about_Functions_Advanced_Methods
# help about_Functions_Advanced_Parameters
# Get-Verb

#Index of functions:
# 1. <FunctionName> Example Function
# 2. Start-PSAdmin
# 3. Get-ScriptDirectory1
# 4. Get-ScriptDirectory2
# 5. Get-ScriptDirectory3
# 6. Write-HorizontalRule
# 7. Write-HorizontalRuleAdv

<# Function <FunctionName> {
  Param ()

  Begin {
    Write-LogInfo -LogPath $sLogFile -Message '<description of what is going on>...'
  }

  Process {
    Try {
      <code goes here>
    }

    Catch {
      Write-LogError -LogPath $sLogFile -Message $_.Exception -ExitGracefully
      Break
    }
  }

  End {
    If ($?) {
      Write-LogInfo -LogPath $sLogFile -Message 'Completed Successfully.'
      Write-LogInfo -LogPath $sLogFile -Message ' '
    }
  }
} #> # End <FunctionName> function ----------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

function Start-PSAdmin {Start-Process PowerShell -Verb RunAs}

function Get-ScriptDirectory1 { #https://stackoverflow.com/questions/801967/how-can-i-find-the-source-path-of-an-executing-script/6985381#6985381
    Split-Path $script:MyInvocation.MyCommand.Path
} # End Get-ScriptDirectory function -----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

function Get-ScriptDirectory2 { #https://stackoverflow.com/questions/1183183/path-of-currently-executing-powershell-script#1183197
    # For PowerShell 3.0 users - following works for both modules and script files:
    Split-Path -parent $PSCommandPath
} # End Get-ScriptDirectory function -----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

function Get-ScriptDirectory3 { #https://stackoverflow.com/questions/1183183/path-of-currently-executing-powershell-script#1183197
  $Invocation = (Get-Variable MyInvocation -Scope 1).Value
  Split-Path $Invocation.MyCommand.Path
} # End Get-ScriptDirectory function -----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
#.SYNOPSIS
# <Overview of script>

#.DESCRIPTION
# <Brief description of script>

#.PARAMETER HRtype
# Horizontal Rule types. Accepted types are 'SingleLine', 'DoubleLine', 'DashedLine', and 'BlankLine'. 

#.NOTES
# <Notes Here>
Function Write-HorizontalRule {
  Param (
    #Script parameters go here
    # https://ss64.com/ps/syntax-args.html
    [Parameter(Mandatory=$false,Position=0)]
    [string]$HRtype = 'SingleLine'
  )
  
  # help about_Automatic_Variables
  # help about_If
  # help about_Comparison_Operators
  # https://ss64.com/ps/if.html
  IF ($LaunchedInCmd -eq $true) {
    # Print horizontal rule styles here using Write-Host instead of Write-Verbose, since that would add "VERBOSE: " to the beginning of each line and prevent the horizontal rule from lining up on the screen properly.
	# Command Prompt character width: 79
    IF ($HRtype -eq "DoubleLine") {
      Write-Host ===============================================================================
    } ELSEIF ($HRtype -eq "DashedLine") {
      Write-Host "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "SingleLine") {
      #Write-Host -------------------------------------------------------------------------------- # This too long
      Write-Host -------------------------------------------------------------------------------
    } ELSEIF (-Not $HRtype) {
      Write-Host -------------------------------------------------------------------------------
    } ELSE {
      Write-Verbose "PowerShell Script launched in cmd.exe = $LaunchedInCmd"
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
    }
  } ELSEIF ($LaunchedInCmd -eq $false) {
    # PowerShell window character width: 119
    IF ($HRtype -eq "DoubleLine") {
      Write-Host =======================================================================================================================
    } ELSEIF ($HRtype -eq "DashedLine") {
      Write-Host - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    } ELSEIF ($HRtype -eq "SingleLine") {
      #Write-Host ------------------------------------------------------------------------------------------------------------------------ # This too long
      Write-Host -----------------------------------------------------------------------------------------------------------------------
    } ELSEIF (-Not $HRtype) {
      Write-Host -----------------------------------------------------------------------------------------------------------------------
    } ELSE {
      Write-Verbose "PowerShell Script launched in cmd.exe = $LaunchedInCmd"
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
    }
  }
} # End Write-HorizontalRule function ----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

Function Write-HorizontalRuleAdv {
  <#
	.SYNOPSIS
	Write-HorizontalRuleAdv
	
	.DESCRIPTION
	Write-HorizontalRuleAdv
	
    .PARAMETER HRtype
    Horizontal Rule types. Accepted types are 'SingleLine', 'DoubleLine', 'DashedLine', and 'BlankLine'. 
  
    .PARAMETER Endcaps
    Add a character to each end of the horizontal rule. Default is '#'. Set a different endcap character using -EndcapCharacter <single character>
  #>
  
  Param (
    #Script parameters go here
    # https://ss64.com/ps/syntax-args.html
    [Parameter(Mandatory=$false,Position=0)]
    [ValidateSet("SingleLine", "DoubleLine", "DashedLine", "BlankLine")]
    [string]$HRtype = 'SingleLine',
    
    [Parameter(Mandatory=$false)]
    [switch]$Endcaps = $false,

    [Parameter(Mandatory=$false)]
    [string]$EndcapCharacter = '#',
    
    [Parameter(Mandatory=$false)]
    [switch]$IsWarning = $false,

    [Parameter(Mandatory=$false)]
    [switch]$IsVerbose = $false,

    [Parameter(Mandatory=$false)]
    [switch]$MaxLineLength = $false
  )
  
  # Function name:
  # https://stackoverflow.com/questions/3689543/is-there-a-way-to-retrieve-a-powershell-function-name-from-within-a-function#3690830
  #$FunctionName = (Get-PSCallStack | Select-Object FunctionName -Skip 1 -First 1).FunctionName
  #$FunctionName = (Get-Variable MyInvocation -Scope 1).Value.MyCommand.Name
  $FunctionName = $PSCmdlet.MyInvocation.MyCommand.Name
  
  # help about_Automatic_Variables
  # help about_If
  # help about_Comparison_Operators
  # https://ss64.com/ps/if.html
  IF ($LaunchedInCmd) {
    # Print horizontal rule styles here using Write-Host instead of Write-Verbose, since that would add "VERBOSE: " to the beginning of each line and prevent the horizontal rule from lining up on the screen properly.
	# Command Prompt character width: 79
    IF ($HRtype -eq "DoubleLine") {
      $HRoutput = "==============================================================================="
    } ELSEIF ($HRtype -eq "DashedLine") {
      $HRoutput = "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "BlankLine") {
      $HRoutput = "                                                                               "
    } ELSEIF ($HRtype -eq "SingleLine") {
      #HRoutput = "--------------------------------------------------------------------------------" # This too long
      $HRoutput = "-------------------------------------------------------------------------------"
    } ELSEIF (-Not $HRtype) {
      $HRoutput = "-------------------------------------------------------------------------------"
    } ELSE {
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
      Return
    }
  } ELSE {
    # PowerShell window character width: 119
    IF ($HRtype -eq "DoubleLine") {
      $HRoutput = "======================================================================================================================="
    } ELSEIF ($HRtype -eq "DashedLine") {
      $HRoutput = "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "BlankLine") {
      $HRoutput = "                                                                                                                       "
    } ELSEIF ($HRtype -eq "SingleLine") {
      #HRoutput = "------------------------------------------------------------------------------------------------------------------------" # This too long
      $HRoutput = "-----------------------------------------------------------------------------------------------------------------------"
    } ELSEIF (-Not $HRtype) {
      $HRoutput = "-----------------------------------------------------------------------------------------------------------------------"
    } ELSE {
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
      Return
    }
  }
  
  # Command Prompt character width: 79
  # PowerShell window character width: 119
  $MaxLength = $HRoutput.Length
  
  IF ($IsWarning -eq $true -or $IsVerbose -eq $true) {
    #WARNING: 
    #VERBOSE: 
    #123456789
    $MaxLength = $MaxLength - 9
    $HRoutput = ($HRoutput).Substring(9,$MaxLength)
  }
  
  IF ($Endcaps -eq $true) {
    #$EndcapLength = $MaxLength - 2
    $MaxLength = $MaxLength - 2
    #$HRoutput = ($HRoutput).Substring(1,$EndcapLength)
    $HRoutput = ($HRoutput).Substring(1,$MaxLength)
    $HRoutput = "$EndcapCharacter$HRoutput$EndcapCharacter"
  }
  
  $MaxLineLengthOutput = $MaxLength
  
  # Write output
  
  IF ($MaxLineLength -eq $true) {
    Write-Output $MaxLineLengthOutput
  } ELSEIF ($IsWarning -eq $true) {
    Write-Warning $HRoutput -WarningAction Continue
  } ELSEIF ($IsVerbose -eq $true) {
    # Set Verbose message display
    # $VerbosePreference = "Continue"
    # $VerbosePreference = "SilentlyContinue"
    #$OrigVerbosePreference = $VerbosePreference
    #$VerbosePreference = "Continue"
    Write-Verbose $HRoutput
    #$VerbosePreference = $OrigVerbosePreference
  } ELSE {
    Write-Host $HRoutput
  }

} # End Write-HorizontalRuleAdv function -------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

Function Convert-AMPMhourTo24hour {
	<#
		.SYNOPSIS
			Convert an hour value in AM/PM format to a 24-hour value.
		
		.DESCRIPTION
			Enter a 12-hour format value plus its AM/PM value, and this cmdlet will return the equivalent 24-hour format hour value from 0-23. Must specify either -AM or -PM switch.
			
			The abbreviations AM and PM derive from Latin:
			
			AM = Ante meridiem: Before noon
			PM = Post meridiem: After noon
			
			https://www.timeanddate.com/time/am-and-pm.html
			
		.PARAMETER Hours
			The AM/PM hour value, from 1-12.
		
		.PARAMETER AM
			Add a character to each end of the horizontal rule. Default is '#'. Set a different endcap character using -EndcapCharacter <single character>
		
		.PARAMETER PM
			Add a character to each end of the horizontal rule. Default is '#'. Set a different endcap character using -EndcapCharacter <single character>
		
		.EXAMPLE
			#1.
			
			The following 3 lines will convert any PM Hour value (in this case, 4) and convert it into its 24-hour equivalent.
			
			\> $AMPMhour = 4
			\> $OutputVar = Convert-AMPMhourTo24hour $AMPMhour -PM
			\> Write-Host "$AMPMhour PM = $OutputVar           (24-hour)"
			
			In this example, the output would read:
			"4 PM = 16           (24-hour)"
			
			Because 4:00 PM is equivalent to 16:00 on a 24-hour clock.
			
		.EXAMPLE
			#2.
			
			The following single-line script will get the current hour in AM/PM format (Get-Date -UFormat %I) and convert it to 24-hour format.
			
			\> Get-Date -UFormat %I | Convert-AMPMhourTo24hour -PM
			
			To capture this output in a variable first, then print it out:
			
			\> $OutputVar = (Get-Date -UFormat %I | Convert-AMPMhourTo24hour -PM)
			\> Write-Host "`$OutputVar = $OutputVar"
			\> Write-Host "$(Get-Date -UFormat %I) PM = $OutputVar           (24-hour)"
			
			For example, if the current time was 2 PM, the output would read:
			"$OutputVar = 14"
			"2 PM = 14           (24-hour)"
			
			For the same thing but with AM times, simply change the -PM switch to the -AM switch:
			
			\> $OutputVar = (Get-Date -UFormat %I | Convert-AMPMhourTo24hour -AM)
			\> Write-Host "`$OutputVar = $OutputVar"
			\> Write-Host "$(Get-Date -UFormat %I) AM = $OutputVar           (24-hour)"
			
			For example, if the current time was 8 PM, the output would read:
			"$OutputVar = 8"
			"8 AM = 8           (24-hour)"
			
		.EXAMPLE
			#3.
			
			To get today's date, but with a different time-value, use a script block invloving Read-Host, Get-Date, and Convert-AMPMhourTo24hour, such as this:
			
			\> $StartHour = Read-Host -Prompt "Enter Start hour"
			
			\> $StartMin = Read-Host -Prompt "Enter Start minute"
			
			\> do {
			\>   $ChoiceAMPM24hour = Read-Host -Prompt "[A]M, [P]M, or [2]4 hour? [A\P\2]"
			\>   switch ($ChoiceAMPM24hour) {
			\> 	   'A' { # A - AM time
			\>            $AntePost = "AM"
			\>            Write-Verbose "AM time ('$ChoiceAMPM24hour') option selected."
			\>            $24hourFormat = Convert-AMPMhourTo24hour -Hours $StartHour -AM
			\>     }
			\>     'P' { # P - PM time
			\>            $AntePost = "PM"
			\>            Write-Verbose "PM time ('$ChoiceAMPM24hour') option selected."
			\>            $24hourFormat = Convert-AMPMhourTo24hour -Hours $StartHour -PM
			\>     }
			\>     2 { # 2 - 24-hour time
			\>            $AntePost = "(24-hour)"
			\>            Write-Verbose "24-hour time ('$ChoiceAMPM24hour') option selected."
			\>            $24hourFormat = $StartHour
			\>     }
			\>     default { # Choice not recognized.
			\>            Write-Host `r`n
			\>            Write-Warning "Choice `"$ChoiceAMPM24hour`" not recognized. Options must be AM, PM, or 24-hour."
			\>            Write-Host `r`n
			\>            #Break #help about_Break
			\>            PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
			\>            #Clear-Host # CLS
			\>            Write-Host `r`n
			\>     }
			\>   }
			\> } until ($ChoiceAMPM24hour -eq 'A' -Or $ChoiceAMPM24hour -eq 'P' -Or $ChoiceAMPM24hour -eq 2)
			\> Write-Verbose "12-hour time '$StartHour:$StartMin $AntePost' converted to 24-hour time ('$24hourFormat:$StartMin')"
			
			\> $DifferentTimeToday = Get-Date -Hour $24hourFormat -Minute $StartMin
			
			This script above will set a <DateTime> type variable called $DifferentTimeToday that is the same date as today, but with a time entered by manually by the user.
			
		.INPUTS
			Requires a "Hours" time value as input, and selection of AM or PM. Hour value must be a positive integer (whole number, non-decimal) between 1 and 12. "Hours" value can be piped int from other commands, but a choice between -AM or -PM switch must still be made. See Examples for more info.
		
		.OUTPUTS
			Returns a [int32] integer number (whole number, not decimal, not negative) between 0 and 23, according to 24-hour time formats, equivalent to the AM/PM input time (hour).
			
		.NOTES
			
			Conversion table between AM/PM hours and 24-hour time format:
			
			--AM/PM----24-hr--------------------------------------------------------------------------------
			12:00 AM = 00:00	*** exception: if AM hours = 12, then 24-hours = 0			\
			 1:00 AM = 01:00	\															 |
			 2:00 AM = 02:00	 |															 |
			 3:00 AM = 03:00	 |															 |
			 4:00 AM = 04:00	 |															 |
			 5:00 AM = 05:00	 |															 |
			 6:00 AM = 06:00	 |------- AM time = 24-hour time							 |-------  AM
			 7:00 AM = 07:00	 |															 |
			 8:00 AM = 08:00	 |															 |
			 9:00 AM = 09:00	 |															 |
			10:00 AM = 10:00	 |															 |
			11:00 AM = 11:00____/___________________________________________________________/_______________
			12:00 PM = 12:00	*** exception: if PM hours = 12, then 24-hours = 12			\
			 1:00 PM = 13:00	\															 |
			 2:00 PM = 14:00	 |															 |
			 3:00 PM = 15:00	 |															 |
			 4:00 PM = 16:00	 |															 |
			 5:00 PM = 17:00	 |															 |
			 6:00 PM = 18:00	 |------- PM hours + 12 = 24-hours							 |-------  PM
			 7:00 PM = 19:00	 |															 |
			 8:00 PM = 20:00	 |															 |
			 9:00 PM = 21:00	 |															 |
			10:00 PM = 22:00	 |															 |
			11:00 PM = 23:00	/															/
			------------------------------------------------------------------------------------------------
			
		.LINK
			https://www.lsoft.com/manuals/maestro/4.0/htmlhelp/interface%20user/TimeConversionTable.html
		
		.LINK
			https://stackoverflow.com/questions/16774064/regular-expression-for-whole-numbers-and-integers
		
		.LINK
			https://www.gngrninja.com/script-ninja/2016/5/15/powershell-getting-started-part-8-accepting-pipeline-input
		
		.LINK
			https://www.timeanddate.com/time/am-and-pm.html
		
	#>
	
	Param (
		#Script parameters go here
		[Parameter(Mandatory=$true,Position=0,
		ValueFromPipeline = $true)]
		# Validate a positive integer (whole number) using Regular Expressions, thanks to:
		#https://stackoverflow.com/questions/16774064/regular-expression-for-whole-numbers-and-integers
		#	(?<![-.])		# Assert that the previous character isn't a minus sign or a dot.
		#	\b				# Anchor the match to the start of a number.
		#	[0-9]+			# Match a number.
		#	\b				# Anchor the match to the end of the number.
		#	(?!\.[0-9])		# Assert that no decimal part follows.
		#$RegEx = "(?<![-.])\b[0-9]+\b(?!\.[0-9])"
		#[ValidatePattern("(?<![-.])\b[0-9]+\b(?!\.[0-9])")]
		# This [ValidateScript({))] does the exact same thing as the [ValidatePattern("")] above, it just throws much nicer, customizable error messages.
		[ValidateScript({
            If ($_ -match "(?<![-.])\b[0-9]+\b(?!\.[0-9])") {
                $True
            } else {
                Throw "$_ must be a positive integer (whole number, no decimals)."
            }
        })]
		[ValidateRange(1,12)]
		# Bugfix: To properly validate regex for integer ranges, and throw an error if a decimal value is provided, do not use [int]$var since PowerShell will automatically round the input value before performing the [ValidatePattern("")] regex comparison. Instead, declare parameter without [int] e.g. $var,
		$Hours,
		
		[Parameter(Mandatory=$true,
		ParameterSetName='AMtag')]
		[switch]$AM,
		
		[Parameter(Mandatory=$true,
		ParameterSetName='PMtag')]
		[switch]$PM
	)
	
	<#
	------------------------------------------------------------------------------------------------
	12:00 AM = 00:00	*** exception: if AM hours = 12, subtract 12 for 24-hours	\
	1:00 AM = 01:00		\															 |
	2:00 AM = 02:00		 |															 |
	3:00 AM = 03:00		 |															 |
	4:00 AM = 04:00		 |															 |
	5:00 AM = 05:00		 |															 |
	6:00 AM = 06:00		 |------- AM time = 24-hour time							 |-------  AM
	7:00 AM = 07:00		 |															 |
	8:00 AM = 08:00		 |															 |
	9:00 AM = 09:00		 |															 |
	10:00 AM = 10:00	 |															 |
	11:00 AM = 11:00____/___________________________________________________________/_______________
	12:00 PM = 12:00	*** exception: if PM hours = 12, 24-hours = 12				\
	1:00 PM = 13:00		\															 |
	2:00 PM = 14:00		 |															 |
	3:00 PM = 15:00		 |															 |
	4:00 PM = 16:00		 |															 |
	5:00 PM = 17:00		 |															 |
	6:00 PM = 18:00		 |------- PM hours + 12 = 24-hours							 |-------  PM
	7:00 PM = 19:00		 |															 |
	8:00 PM = 20:00		 |															 |
	9:00 PM = 21:00		 |															 |
	10:00 PM = 22:00	 |															 |
	11:00 PM = 23:00	/															/
	------------------------------------------------------------------------------------------------
	#>
	
	#-----------------------------------------------------------------------------------------------------------------------
	# Convert AM hours
	#-----------------------------------------------------------------------------------------------------------------------
	
	If ($AM) {
		If ($AM -eq 12) {
			$24hour = 0
		} else {
			$24hour = $Hours
		}
	}
	
	#-----------------------------------------------------------------------------------------------------------------------
	# Convert PM hours
	#-----------------------------------------------------------------------------------------------------------------------
	
	If ($PM) {
		If ($PM -eq 12) {
			$24hour = 12
		} else {
			$24hour = [Int]$Hours + 12
		}
	}
	
	#-----------------------------------------------------------------------------------------------------------------------
	# Write out result of function
	#-----------------------------------------------------------------------------------------------------------------------
	
	#$24hour
	
	Return $24hour
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
} # End Convert-AMPMhourTo24hour function -------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------



#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Once [Functions] block has finished running, exit the script if -LoadFunctions switch is on.
If ($LoadFunctions) {
  #https://stackoverflow.com/questions/2022326/terminating-a-script-in-powershell
  # Only load functions of script. Do not execute Main script block.
  Return
}
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------[Execution]------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
#=======================================================================================================================
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#
#
##Script MAIN Execution goes here
Clear-Host # CLS
Write-Verbose `n
Write-HorizontalRuleAdv -HRtype DoubleLine -IsVerbose
Write-Verbose `n
Write-Verbose "Script body."

#=======================================================================================================================
#Index:
#1. Test different methods of writing output
#2. Testing Write-HorizontalRule function
#3. Testing Out-GridView
#4. User Choice Selection / Menu Demos
#5. Test For loop & date formatting
#6. Test multi-dimensional variable methods
#7. Test running external script
#=======================================================================================================================

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#1. Test different methods of writing output
#=======================================================================================================================


# run "help about_comment_based_help" - I want to display formatted help for a function or script. Use comment-based help instead - run "help about_comment_based_help". PowerShell will format it for you.
# https://technet.microsoft.com/en-us/library/dd819489.aspx
# Write-Host - You almost never need to do it. 
# Write-Information - Only works if $ErrorActionPreference = 'Continue' Does not work if = 'SilentlyContinue' Prints grey text. Can be overridden with -InformationAction Continue
# Write-Verbose - Writes yellow VERBOSE: messages (9 chars). Can be turned on/off by running script with -Verbose parameter.
# Write-Debug - Pauses script execution every time it's called. Can be turned on/off by running script with -Debug parameter.
# Write-Warning - Writes yellow WARNING: messages (9 chars), regardless of -Verbose or -Debug switches.
# Write-Error - Only works if $ErrorActionPreference = 'Continue' Does not work if = 'SilentlyContinue' Prints in red text, "Entire Script path: Error message." E.g. C:\Users\G\Documents\SpiderOak Hive\Consulting\2018-04-06 SodaLakeNetworking\Manage-SodaLakeData.ps1 : TEST ERROR.
# Write-Output - I just need to display some text! Do you really? PowerShell works better with objects, and that's what your script should be outputting, by means of Write-Output. Let PowerShell's Format cmdlets turn those objects into text like lists and tables.
# Write-Progress - Makes a green and yellow progress bar appear at the top part of the command window.

Write-Host "Script Main beginning." $MyInvocation.MyCommand.Name
Write-Information -MessageData "Will only display if set defaults display infromational messages."
Write-Information -MessageData "Test informational messages." -InformationAction Continue
Write-Verbose "Script Main beginning. $ScriptName"
Write-Verbose "Debug preference = $DebugPreference"
Write-Debug "Script Main beginning." # NOTE: Writing debug text will PAUSE script execution automatically.
Write-Warning "Test Warning."
Write-Error -Message "TEST ERROR. TEST ERROR. TEST ERROR. TEST ERROR." -Category InvalidData -ErrorId TEST_ID
For ($I = 1; $I -le 100; $I++) {Write-Progress -Activity "Test in progress..." -Status "$I% Complete:" -PercentComplete $I;}
#For ($I = 1; $I -le 1000; $I++) {Write-Progress -Activity "Test in progress..." -Status "$($I / 10)% Complete:" -PercentComplete ($I/10)}


#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#1. Test different methods of writing output thru Logging Module
#-----------------------------------------------------------------------------------------------------------------------

# Write-LogInfo – Writes an informational message to the log file
# Write-LogWarning – Writes a warning message to the log file (with the format of WARNING: )
# Write-LogError – Writes an error message to the log file (with the format of ERROR: ). In addition, optionally calls Stop-Log to end logging and terminate the calling script on fatal error.

Write-LogInfo -LogPath $sLogFile -Message "-----------------------------------------------------------------------------------------------------------------------"
Write-LogInfo -LogPath $sLogFile -Message "[TIMESTAMP]: $($Time)"

Write-LogInfo -LogPath $sLogFile -Message "Test log info write."
Write-LogWarning -LogPath $sLogFile -Message "Test log warning write."
Write-LogError -LogPath $sLogFile -Message "Test log error write."

#Read-Host "Press ENTER key to continue . . . " # PAUSE (Read-Host automatically adds colon : at the end of prompt)
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#=======================================================================================================================
#2. Testing Write-HorizontalRule function
#=======================================================================================================================

Write-Host "Write-HorizontalRule Help output:"
Write-HorizontalRule
Get-Help Write-HorizontalRule
Get-Help Write-HorizontalRule -Full
Write-HorizontalRule
Write-Verbose "Script MAIN execution. $ScriptName"
Write-Host "Script MAIN execution." $MyInvocation.MyCommand.Name
Write-HorizontalRule -HRtype DoubleLine
Write-HorizontalRule -HRtype DashedLine
Write-HorizontalRule -HRtype SingleLine
Write-HorizontalRule -HRtype IntentionallyThrowError -Verbose

Write-Host `n
Write-Host "Write-HorizontalRuleAdv Help output:"
Write-HorizontalRule
Get-Help Write-HorizontalRuleAdv -Full
Write-HorizontalRule

Write-HorizontalRuleAdv -HRtype SingleLine -Verbose
Write-HorizontalRuleAdv -HRtype DashedLine -Verbose
Write-HorizontalRuleAdv -HRtype DoubleLine -Verbose
Write-HorizontalRuleAdv -HRtype SingleLine -Endcaps
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `|
Write-HorizontalRuleAdv -HRtype DashedLine -Endcaps
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `|
Write-HorizontalRuleAdv -HRtype DoubleLine -Endcaps

Write-HorizontalRuleAdv -HRtype SingleLine -IsVerbose
Write-HorizontalRuleAdv -HRtype DashedLine -IsVerbose
Write-HorizontalRuleAdv -HRtype DoubleLine -IsVerbose
Write-HorizontalRuleAdv -HRtype SingleLine -Endcaps -IsVerbose
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `| -IsVerbose
Write-HorizontalRuleAdv -HRtype DashedLine -Endcaps -IsVerbose
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `| -IsVerbose
Write-HorizontalRuleAdv -HRtype DoubleLine -Endcaps -IsVerbose

Write-HorizontalRuleAdv -HRtype SingleLine -IsWarning
Write-HorizontalRuleAdv -HRtype DashedLine -IsWarning
Write-HorizontalRuleAdv -HRtype DoubleLine -IsWarning
Write-HorizontalRuleAdv -HRtype SingleLine -Endcaps -IsWarning
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `| -IsWarning
Write-HorizontalRuleAdv -HRtype DashedLine -Endcaps -IsWarning
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `| -IsWarning
Write-HorizontalRuleAdv -HRtype DoubleLine -Endcaps -IsWarning

PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#3. Testing Out-GridView
#=======================================================================================================================

#https://mcpmag.com/articles/2016/02/17/creating-a-gui-using-out-gridview.aspx
Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "A quick way to go back in your history and run the same command again:"
Write-Host "Get-History | Out-GridView -PassThru | Invoke-Expression"
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
Get-History | Out-GridView -PassThru | Invoke-Expression

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Looking at the cmdlet help:"
Get-Command | Out-GridView -PassThru | Get-Help -ShowWindow 

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Looking at the about* Help Files:"
Get-Help about* | Out-GridView -PassThru | Get-Help -ShowWindow 

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Menu example using Out-GridView:"
$Menu = [ordered]@{
	1 = 'Do something'
	2 = 'Do this instead'
	3 = 'Do whatever you want'
}

$Result = $Menu | Out-GridView -PassThru -Title 'Make a selection'

Switch ($Result) {
	{$Result.Name -eq 1} {Write-Host 'Do something'}
	{$Result.Name -eq 2} {Write-Host 'Do this instead'}
	{$Result.Name -eq 3} {Write-Host 'Do whatever you want'}   
} 

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Advanced Out-GridView usage:"
$WMI =  @{
	Filter =  "DriveType='3' AND (Not Name LIKE  '\\\\?\\%')"
	Class =  "Win32_Volume"
	ErrorAction =  "Stop"
	Property =  "Name","Label","Capacity","FreeSpace"
	Computername =  $Env:COMPUTERNAME
}

$List = New-Object System.Collections.ArrayList

Get-WmiObject @WMI  | ForEach {

	$Decimal  = $_.freespace / $_.capacity

	$Graph  = "$($Bar)"*($Decimal*100)

	$Hash = [ordered]@{

		Computername =  $Env:COMPUTERNAME

		Name =  $_.Name

		FreeSpace =  "$Graph"       

		Percent =  $Decimal

		FreeSpaceGB =  ([math]::Round(($_.Freespace/1GB),2))

		CapacityGB =  ([math]::Round(($_.Capacity/1GB),2))

	}

	[void]$List.Add((

		[pscustomobject]$Hash

	))

}

$List | Out-GridView -Title 'Drive Space' 

PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#4. User Choice Selection / Menu Demos
#=======================================================================================================================

#-----------------------------------------------------------------------------------------------------------------------

Write-Host `r`n
Write-Host "4. User Choice Selection / Menu Demos"
Write-Host `r`n

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-HorizontalRuleAdv -HRtype SingleLine -IsVerbose
Write-Verbose 'Method #1: "Read-Host -Prompt"'
Write-HorizontalRuleAdv -HRtype DashedLine -IsVerbose
do {
	$ChoiceYesNoCancel = Read-Host -Prompt "[Y]es, [N]o, or [C]ancel? [Y\N\C]"
	switch ($ChoiceYesNoCancel) {
		'Y'	{ # Y - Yes
			Write-Verbose "Yes ('$ChoiceYesNoCancel') option selected."
			Write-Host `r`n
		}
		'N' { # N - No
			Write-Verbose "No ('$ChoiceYesNoCancel') option selected."
			Write-Host `r`n
		}
		'C' { # C - Cancel
			Write-Verbose "Cancel ('$ChoiceYesNoCancel') option selected."
			Write-Host `r`n
		}
		default { # Choice not recognized.
			Write-Host `r`n
			Write-Host "Choice `"$ChoiceYesNoCancel`" not recognized. Options must be Yes, No, or Cancel."
			#Write-HorizontalRuleAdv -HRtype DashedLine
			Write-Host `r`n
			#Break #help about_Break
			PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
			Write-Host `r`n
			Write-HorizontalRuleAdv -HRtype DashedLine
		}
	}
}
until ($ChoiceYesNoCancel -eq 'Y' -Or $ChoiceYesNoCancel -eq 'N' -Or $ChoiceYesNoCancel -eq 'C')
Write-HorizontalRuleAdv -HRtype DashedLine -IsVerbose
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `r`n
Write-HorizontalRuleAdv -HRtype SingleLine -IsVerbose
Write-Verbose 'Method #2: "PromptForChoice()"'
#-----------------------------------------------------------------------------------------------------------------------
# Build Menu
#-----------------------------------------------------------------------------------------------------------------------
#Clear-Host # CLS
Write-HorizontalRuleAdv -HRtype DashedLine
#-----------------------------------------------------------------------------------------------------------------------
# Build Choice Prompt
#-----------------------------------------------------------------------------------------------------------------------
$Title = "Main Menu"
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
$Info = 'User choice selection example using "PromptForChoice()"'
$Info = @"
User choice selection example using "PromptForChoice()"

Y - Yes
N - No
Q - Quit
 
Select a choice:
"@
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# &Quit makes Q a Hot Key. 
$ChoiceYes = New-Object System.Management.Automation.Host.ChoiceDescription "&Yes", "Select [Y]es as the answer."
$ChoiceNo = New-Object System.Management.Automation.Host.ChoiceDescription "&No", "Select [N]o as the answer."
$ChoiceQuit = New-Object System.Management.Automation.Host.ChoiceDescription "&Quit", "[Q]uit, prints `"Good Bye!!!`" in green"
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
$Options = [System.Management.Automation.Host.ChoiceDescription[]]($ChoiceYes, $ChoiceNo)
# default choice: 0 = first Option, 1 = second option, etc.
[int]$defaultchoice = 1
#-----------------------------------------------------------------------------------------------------------------------
# Execute Choice Prompt
#-----------------------------------------------------------------------------------------------------------------------
# PromptForChoice() output will always be integer: https://powershell.org/forums/topic/question-regarding-result-host-ui-promptforchoice/
# If run from shell, will create a GUI dialog box. If run from script, will create choice text menu in command line.
# https://social.technet.microsoft.com/wiki/contents/articles/24030.powershell-demo-prompt-for-choice.aspx
$answer = $host.UI.PromptForChoice($Title, $Info, $Options, $defaultchoice)
#-----------------------------------------------------------------------------------------------------------------------
# Interpret answer
#-----------------------------------------------------------------------------------------------------------------------
#help about_switch
#https://powershellexplained.com/2018-01-12-Powershell-switch-statement/#switch-statement
Write-Verbose "Answer = $answer"
switch ($answer) {
	0	{ # Y - Yes
		Write-Verbose "Yes ('$answer') option selected."
		Write-Host "Si Senor." -ForegroundColor Green
		Write-Host `r`n
	}
	1 { # N - No
		Write-Verbose "No ('$answer') option selected."
		Write-Host "No gracias." -ForegroundColor Green
		Write-Host `r`n
	}
	2 {
		Write-Verbose "Quit ('$answer') option selected."
		Write-Host "Good Bye!!!" -ForegroundColor Green
		Write-HorizontalRuleAdv -HRtype DashedLine
		Write-Host `r`n
	}
}
Write-HorizontalRuleAdv -HRtype DashedLine -IsVerbose
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `r`n
Write-HorizontalRuleAdv -HRtype SingleLine -IsVerbose
Write-Verbose 'Method #3: "Out-GridView -PassThru"'
Write-HorizontalRuleAdv -HRtype DashedLine -IsVerbose
#-----------------------------------------------------------------------------------------------------------------------
# Build Menu
#-----------------------------------------------------------------------------------------------------------------------
Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Menu example using Out-GridView:"
#-----------------------------------------------------------------------------------------------------------------------
# Build Choice Prompt
#-----------------------------------------------------------------------------------------------------------------------
$Title = "Main Menu"
$Menu = [ordered]@{
	1 = 'Yes'
	2 = 'No'
	3 = 'Cancel'
}
#-----------------------------------------------------------------------------------------------------------------------
# Execute Choice Prompt
#-----------------------------------------------------------------------------------------------------------------------
# Using Out-GridView creates a GUI selection window with filter ability
# and ability to select multiple options with the -PassThru switch
$Result = $Menu | Out-GridView -PassThru -Title $Title
#-----------------------------------------------------------------------------------------------------------------------
# Interpret answer
#-----------------------------------------------------------------------------------------------------------------------
$answer = $Result.Name
Write-Verbose "`$Result.Name = $answer"
Write-HorizontalRuleAdv -HRtype DashedLine -IsVerbose
Switch ($answer) {
	1 {
		Write-Host '"Yes" was selected.'
	}
	2 {
		Write-Host '"No" was selected.'
	}
	3 {
		Write-Host '"Cancel" was selected.'
	}
}
Write-HorizontalRuleAdv -HRtype DashedLine -IsVerbose
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#5. Test For loop & date formatting
#=======================================================================================================================

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Months in 3 letters."
# https://www.business.com/articles/powershell-for-loop/
# help about_For
For ($m=1; $m -lt 13; $m++) {
    $m
    Get-Date -Month $m -UFormat %b
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#6. Test multi-dimensional variable methods
#=======================================================================================================================

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Test CSV ForEach loop 1."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test1.csv"
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
$CSVheaders = "col1,col2"
$CSVarray = (Get-Content $CSVfile).split(",")
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
ForEach ($column in $CSVarray) {
	Write-Host "Start of loop."
    Write-Host "Whole:     $column"
	Write-Host "Array One: $column[0]"
	Write-Host "Array Two: $column[1]"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Test CSV ForEach loop 2."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test2.csv"
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
$CSVheaders = "col1,col2"
$CSVarray = (Get-Content $CSVfile).split(",")
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
ForEach ($line in $CSVarray) {
	Write-Host "Start of loop."
    Write-Host "Whole:     $line"
	Write-Host "Array One: $line[0]"
	Write-Host "Array Two: $line[1]"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Test CSV ForEach loop 3."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test3.csv"
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
$CSVheaders = "col1,col2"
$CSVarray = (Get-Content $CSVfile).split(",")
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
ForEach ($line in $CSVarray) {
	Write-Host "Start of loop."
    Write-Host "Whole:     $line"
	Write-Host "Array One: $line[0]"
	Write-Host "Array Two: $line[1]"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype SingleLine
Write-Host `n
Write-Host "Test Import-CSV ForEach loop."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test3.csv"
$CSVheaders = "col1,col2"
$CSVarray = (Get-Content $CSVfile).split(",")
$CSVimport = Import-CSV $CSVfile -Delimiter "," -Header $CSVheaders
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
Import-CSV -Path $CSVfile -Delimiter "," -Header $CSVheaders | ForEach {
	Write-Host "Start of loop."
    Write-Host "Whole:     $_"
	Write-Host "Array One: $_[0]"
	Write-Host "Array Two: $_[1]"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype SingleLine
Write-Host `n
Write-Host "Test Import-CSV ForEach loop 2."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test4.csv"
$CSVheaders = "col1,col2,col3"
$CSVarray = (Get-Content $CSVfile).split(",")
$CSVimport = Import-CSV -Path $CSVfile -Delimiter "," -Header $CSVheaders
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
Import-CSV -Path $CSVfile | ForEach {
	Write-Host "Start of loop."
    Write-Host "Whole:     $_"
	Write-Host "Col call: $($_."header 1")"
	Write-Host "Col call: $($_."header 2")"
	Write-Host "Col call: $($_.H1)"
	Write-Host "Col call: $($_."header 4")"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DoubleLine
Write-Host `n
Write-Host "Perform actions from a CSV file."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\commands.csv"
$CSVheaders = "Program,Exec Command"
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
# The foreach alias also supports beginning command blocks, middle command blocks, and end command blocks. The beginning and end command blocks run once, and the middle command block runs every time the Foreach loop steps through a collection or array.
# <command> | foreach {<beginning command_block>}{<middle command_block>}{<ending command_block>}
Import-CSV -Path $CSVfile | ForEach-Object {
	# beginning (runs once)
	Write-Host `n
	Write-Host "Beginning block: ForEach"
	Write-Host `n
}{
    # middle (loop)
	Write-Host "$_"
	
	# https://discoposse.com/2012/01/23/csv-yeah-you-know-me-powershell-and-the-import-csv-cmdlet-part-1/
	# https://discoposse.com/2012/01/23/csv-yeah-you-know-me-powershell-and-the-import-csv-cmdlet-part-2/
	# https://discoposse.com/2012/12/29/csv-yeah-you-know-me-powershell-and-the-import-csv-cmdlet-part-3/
	
	$HostProgram = $_.Program
	$CommandToExecute = $_."Exec Command"
	
	Write-Host "Host Program: $HostProgram"
	Write-Host "Expand Var: $($_.Program)"
	
	Write-Host "Command to execute: $CommandToExecute"
	Write-Host "Expand Var: $($_."Exec Command")"
	Write-Host `n
}{
	# ending (runs once)
	Write-Host "Ending block: ForEach"
	Write-Host `n
}

Write-Host "Loop is over."
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#7. Test running external script
#=======================================================================================================================

#-----------------------------------------------------------------------------------------------------------------------

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Run External Script."
$ExternalScript = "$Home\Documents\SodaLake\PowerShell\Choice\DialogDemo.ps1"
PowerShell.exe -NoProfile -ExecutionPolicy Bypass -Command "& '$ExternalScript'"
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-Verbose "/Script body."

#=======================================================================================================================

Write-HorizontalRuleAdv -HRtype DoubleLine
Write-Host `n
Write-Host "End of script" $MyInvocation.MyCommand.Name
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
Write-Host `n

#Script MAIN Execution ends here
#
#
#
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#=======================================================================================================================
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------[Footer]---------------------------------------------------------

Write-Verbose "Script Main end. $ScriptName"
Write-Debug "End-of-script. $ScriptName"
Write-LogInfo -LogPath $sLogFile -Message "End of script $ScriptName"
Stop-Log -LogPath $sLogFile
Write-Output $sLogFile
Return
