<#
.SYNOPSIS
  <Overview of script>

.DESCRIPTION
  <Brief description of script>

.PARAMETER -SampleParam
  <This parameter text will not be shown, since -SampleParam is not a real parameter listed in Param(). However, if a .PARAMETER help line is present and there is no Param(), all help text will fail.>

.PARAMETER LaunchedInCmd
  Used to indicate to this script when it has been launched in a Command Prompt windows (CMD.EXE)
  
  Formats output to the size of a standard Command Prompt (79 characters wide + 1) or to the size of a standard PowerShell window (119 characters winde + 1)

.PARAMETER LoadFunctions
  Use this switch to only load the functions in this script. The script main body execution will not run.

.INPUTS
  <Inputs if any, otherwise state None>

.OUTPUTS 
Log File
  The script log file stored in C:\Windows\Temp\<name>.log

.NOTES
  Version:        1.0
  Author:         <Name>
  Creation Date:  <Date>
  Purpose/Change: Initial script development

  Requires PSLogging module from 
  https://9to5it.com/powershell-logging-v2-easily-create-log-files/
  PowerShell Gallery:
  https://www.powershellgallery.com/packages/PSLogging/
  GitHub:
  https://www.powershellgallery.com/packages/PSLogging/

  AUTOGENERATED CONTENT
    The name, syntax, parameter list, parameter attribute table, common
    parameters, and remarks are automatically generated by the Get-Help cmdlet.

.EXAMPLE
  <Example explanation goes here>
  
  <Example goes here. Repeat this attribute for more than one example>

.LINK
about_Comment_Based_Help

.LINK
about_Requires

.LINK
about_Scripts

.LINK
https://ss64.com/ps/syntax-run.html

.LINK
https://ss64.com/ps/call.html

.LINK
about_Functions_CmdletBindingAttribute
#>

#-----------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------#Requires-------------------------------------------------------

# "#Requires" - You can use a #Requires statement to prevent a script from running without specified modules or snap-ins and a specified version of PowerShell. For more information, see about_Requires.
# help about_Requires
# help about_PSSnapins
# e.g. "#Requires -Version 6" "#Requires -RunAsAdministrator"
#Requires -Modules PSLogging

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# To insatll PSLogging module:
# https://docs.microsoft.com/en-us/powershell/developer/module/installing-a-powershell-module
# PowerShell v4:
# 	1. Find PSModulePath environment variable
# 		$Env:PSModulePath
# 		[Environment]::GetEnvironmentVariable("PSModulePath")
#	2. Find the PSLogging module
# 		.\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging
# 	3. Either copy the module to a location within the PSModulePath environment variable, or add the location of the module to the PSModulePath environment variable.
# 		3a. Copy the module to the location:
# 			# Install for Current User ? $Home\Documents\WindowsPowerShell\Modules (%UserProfile%\Documents\WindowsPowerShell\Modules)
# 				$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 				$Destination = "$Home\Documents\WindowsPowerShell\Modules"
# 				Copy-Item "$newModule" -Destination "$Destination\PSLogging" -Recurse
# 			# Install for All Users ? $Env:ProgramFiles\WindowsPowerShell\Modules (%ProgramFiles%\WindowsPowerShell\Modules)
# 				$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 				$Destination = "$Env:ProgramFiles\WindowsPowerShell\Modules"
# 				Copy-Item "$newModule" -Destination "$Destination\PSLogging" -Recurse
# 		3b. Add the module's path to the PSModulePath environment variable
# 			$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 			$p = [Environment]::GetEnvironmentVariable("PSModulePath")
# 			$p += ";$newModule"
# 			[Environment]::SetEnvironmentVariable("PSModulePath",$p)
# PowerShell v5: (and above)
# 	Find-Module -Name "PSLogging*" | Install-Module -Scope AllUsers 
# Accepted values: CurrentUser, AllUsers
# 	Update-Module PSLogging -Force

#-----------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------[Header]--------------------------------------------------------

# Index:
# 1. <# Help #>
# 2. #Requires
# 3. [Header]
# 4. [Script Parameters]
# 5. [Initialisations]
# 6. [Modules]
# 7. [Declarations]
# 8. [Functions]
# 9. [Execution]
# 10. [Footer]

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Tested with PowerShell versions:
# 5.1
# Get PowerShell version:
# $PSVersionTable.PSVersion

# To run from PowerShell command line:
# https://ss64.com/ps/syntax-run.html
# https://ss64.com/ps/call.html
# https://ss64.com/ps/syntax-scriptblock.html
# When passing a variable to a scriptblock it is important to consider the variable scope.
#    Each time the scriptblock is run; it will dynamically read the current value of the variable.
#    When a scriptblock is run using the ?&? (call) operator, updates to a variable are not reflected in the parent scope.
#    When a scriptblock is run using the ?.? (dot) operator, updates to a variable apply to the current scope.
# help about_Scripts
# & "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1"
# & "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Verbose -Debug
# & "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Verbose -Debug -LaunchedInCmd
# & "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -LoadFunctions
# https://ss64.com/ps/source.html
# . "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1"
# . "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Verbose -Debug
# . "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Verbose -Debug -LaunchedInCmd
# . "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -LoadFunctions

# To run help:
# Get-Help "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1"
# Get-Help "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Full
# Example help file:
# Get-Help Get-ChildItem
# Get-Help Get-ChildItem -Full

# Execution Policy:
# $oldExecutionPolicy = Get-ExecutionPolicy
# Set-ExecutionPolicy -ExecutionPolicy RemoteSigned
# Set-ExecutionPolicy -ExecutionPolicy Bypass
# Set-ExecutionPolicy $oldExecutionPolicy

#-----------------------------------------------------------------------------------------------------------------------
#--------------------------------------------------[Script Parameters]--------------------------------------------------

# Debugging: absolutely NO commands can come before Param (except for [CmdletBinding()] )
# Debugging: You must have a script parameter defined here if you have the Help Topic .PARAMETER defined above.
# https://ss64.com/ps/syntax-args.html

#[CmdletBinding()]
#[CmdletBinding(SupportsShouldProcess=$true)]

#Script parameters go here
Param (
  #Script parameters go here
  # Debugging: You must have a script parameter defined here if you have the Help Topic .PARAMETER defined above.
  # help about_Functions_Advanced_Parameters
  # https://ss64.com/ps/syntax-args.html
  # https://ss64.com/ps/syntax-automatic-variables.html

  [Parameter(Mandatory=$false)]
  [switch]$LaunchedInCmd = $false,

  [Parameter(Mandatory=$false)]
  [switch]$LoadFunctions = $false
)


#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------[Initialisations]---------------------------------------------------

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Skip [Initialisations] script block if -LoadFunctions is on.
If (-Not $LoadFunctions) {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Script name (including extension)
$ScriptName = $MyInvocation.MyCommand.Name
Write-Verbose "Script name:"
Write-Verbose "$ScriptName"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

# Script dir (home directory of script)
Write-Verbose "Script home directory:"
#https://stackoverflow.com/questions/801967/how-can-i-find-the-source-path-of-an-executing-script/6985381#6985381
$ScriptDir = Split-Path $script:MyInvocation.MyCommand.Path
Write-Verbose "$ScriptDir"
$ScriptDir = Split-Path -parent $MyInvocation.MyCommand.Definition # PoSh v2 compatible - thanks to https://stackoverflow.com/questions/5466329/whats-the-best-way-to-determine-the-location-of-the-current-powershell-script
Write-Verbose "$ScriptDir"
$ScriptDir = $PSScriptRoot # PoSh v3 compatible - This is an automatic variable set to the current file's/module's directory
Write-Verbose "$ScriptDir"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

# Script path (full file path & name & extension of currently running script)
$ScriptPath = $MyInvocation.MyCommand.Path
Write-Verbose "Script full path:"
Write-Verbose "$ScriptPath"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

#Set Error Action to Silently Continue
$ErrorActionPreference = 'SilentlyContinue'
#Set Error Action to Continue
$ErrorActionPreference = 'Continue'

#Set Verbose message display
#$VerbosePreference = "SilentlyContinue"
#$VerbosePreference = "Continue"

#Set Debug message display
# help about_Debuggers
#$DebugPreference = "SilentlyContinue"
#$DebugPreference = "Continue"

#Set Progress Bar display
#* If the progress bar does not appear, check the value of the $ProgressPreference variable. If the value is set to SilentlyContinue, the progress bar is not displayed. For more information about Windows PowerShell preferences, see about_Preference_Variables.
#$ProgressPreference = "SilentlyContinue"
#$ProgressPreference = "Continue"

#Set Informational message display
#$InformationPreference = "SilentlyContinue"
#$InformationPreference = "Continue"

#Check Execution Policy
$RecommendedExecutionPolicy = "RemoteSigned"
Write-Verbose "Recommended Execution Policy = $RecommendedExecutionPolicy"
#Write-Host "Current Execution Policy =" (Get-ExecutionPolicy)
$startExecutionPolicy = Get-ExecutionPolicy
Write-Verbose "Current Execution Policy = $startExecutionPolicy"

#Check PowerShell version
$MinimumRequiredVersion = 6
# https://ss64.com/ps/get-host.html
# https://stackoverflow.com/questions/1825585/determine-installed-powershell-version
$PoShVersion = $PSVersionTable.PSVersion
Write-Verbose "Minimum required PowerShell version = $MinimumRequiredVersion"
Write-Verbose "Current PowerShell version = $($PSVersionTable.PSVersion.Major).$($PSVersionTable.PSVersion.Minor)"
# https://ss64.com/ps/if.html
IF ($PSVersionTable.PSVersion.Major -lt $MinimumRequiredVersion) {
    Write-Warning "This script requires at least PowerShell version $MinimumRequiredVersion. Running version $PoShVersion"
	Write-Debug "This script requires at least PowerShell version $MinimumRequiredVersion. Running version $PoShVersion"
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}
# Skip [Initialisations] script block if -LoadFunctions is on.
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------[Modules]-------------------------------------------------------

#Import Modules & Snap-ins
Write-Verbose "Importing modules..."
Write-Verbose `n # New line (carriage return and newline, `r`n)

Import-Module PSLogging

Write-Verbose `r`n
Write-Verbose "Module import complete..."

#-----------------------------------------------------------------------------------------------------------------------
#-----------------------------------------------------[Declarations]----------------------------------------------------

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Skip [Declarations] script block if -LoadFunctions is on.
If (-Not $LoadFunctions) {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#Script Version
$sScriptVersion = '1.0'

#Log File Info
$sLogPath = $ScriptDir
$yesterday = [DateTime]::Today.AddDays(-1)
$TodaysDate = Get-Date -Format FileDate
Write-Verbose "Date code = $TodaysDate"
$sLogName = $MyInvocation.MyCommand.Name.Substring(0,$MyInvocation.MyCommand.Name.Length-4) + "_" + $TodaysDate + ".log"
Write-Verbose "LogName = $sLogName"
$sLogFile = Join-Path -Path $sLogPath -ChildPath $sLogName
Write-Verbose "LogFile = $sLogFile"

# Create Log file if we don't have one already
If (!($sLogPath)) { Start-Log -LogPath $sLogPath -LogName $sLogName -ScriptVersion $sScriptVersion }

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}
# Skip [Declarations] script block if -LoadFunctions is on.
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------[Functions]------------------------------------------------------

# help about_Functions
# help about_Functions_Advanced
# help about_Functions_Advanced_Methods
# help about_Functions_Advanced_Parameters
# Get-Verb

#Index of functions:
# 1. <FunctionName> Example Function
# 2. Start-PSAdmin
# 3. Get-ScriptDirectory1
# 4. Get-ScriptDirectory2
# 5. Get-ScriptDirectory3
# 6. Write-HorizontalRule
# 7. Write-HorizontalRuleAdv

<# Function <FunctionName> {
  Param ()

  Begin {
    Write-LogInfo -LogPath $sLogFile -Message '<description of what is going on>...'
  }

  Process {
    Try {
      <code goes here>
    }

    Catch {
      Write-LogError -LogPath $sLogFile -Message $_.Exception -ExitGracefully
      Break
    }
  }

  End {
    If ($?) {
      Write-LogInfo -LogPath $sLogFile -Message 'Completed Successfully.'
      Write-LogInfo -LogPath $sLogFile -Message ' '
    }
  }
} #> # End <FunctionName> function ----------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

function Start-PSAdmin {Start-Process PowerShell -Verb RunAs}

function Get-ScriptDirectory1 { #https://stackoverflow.com/questions/801967/how-can-i-find-the-source-path-of-an-executing-script/6985381#6985381
    Split-Path $script:MyInvocation.MyCommand.Path
} # End Get-ScriptDirectory function -----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

function Get-ScriptDirectory2 { #https://stackoverflow.com/questions/1183183/path-of-currently-executing-powershell-script#1183197
    # For PowerShell 3.0 users - following works for both modules and script files:
    Split-Path -parent $PSCommandPath
} # End Get-ScriptDirectory function -----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

function Get-ScriptDirectory3 { #https://stackoverflow.com/questions/1183183/path-of-currently-executing-powershell-script#1183197
  $Invocation = (Get-Variable MyInvocation -Scope 1).Value
  Split-Path $Invocation.MyCommand.Path
} # End Get-ScriptDirectory function -----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
#.SYNOPSIS
# <Overview of script>

#.DESCRIPTION
# <Brief description of script>

#.PARAMETER HRtype
# Horizontal Rule types. Accepted types are 'SingleLine', 'DoubleLine', 'DashedLine', and 'BlankLine'. 

#.NOTES
# <Notes Here>
Function Write-HorizontalRule {
  Param (
    #Script parameters go here
    # https://ss64.com/ps/syntax-args.html
    [Parameter(Mandatory=$false,Position=0)]
    [string]$HRtype = 'SingleLine'
  )
  
  # help about_Automatic_Variables
  # help about_If
  # help about_Comparison_Operators
  # https://ss64.com/ps/if.html
  IF ($LaunchedInCmd -eq $true) {
    # Print horizontal rule styles here using Write-Host instead of Write-Verbose, since that would add "VERBOSE: " to the beginning of each line and prevent the horizontal rule from lining up on the screen properly.
	# Command Prompt character width: 79
    IF ($HRtype -eq "DoubleLine") {
      Write-Host ===============================================================================
    } ELSEIF ($HRtype -eq "DashedLine") {
      Write-Host "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "SingleLine") {
      #Write-Host -------------------------------------------------------------------------------- # This too long
      Write-Host -------------------------------------------------------------------------------
    } ELSEIF (-Not $HRtype) {
      Write-Host -------------------------------------------------------------------------------
    } ELSE {
      Write-Verbose "PowerShell Script launched in cmd.exe = $LaunchedInCmd"
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
    }
  } ELSEIF ($LaunchedInCmd -eq $false) {
    # PowerShell window character width: 119
    IF ($HRtype -eq "DoubleLine") {
      Write-Host =======================================================================================================================
    } ELSEIF ($HRtype -eq "DashedLine") {
      Write-Host - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    } ELSEIF ($HRtype -eq "SingleLine") {
      #Write-Host ------------------------------------------------------------------------------------------------------------------------ # This too long
      Write-Host -----------------------------------------------------------------------------------------------------------------------
    } ELSEIF (-Not $HRtype) {
      Write-Host -----------------------------------------------------------------------------------------------------------------------
    } ELSE {
      Write-Verbose "PowerShell Script launched in cmd.exe = $LaunchedInCmd"
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
    }
  }
} # End Write-HorizontalRule function ----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

Function Write-HorizontalRuleAdv {
  <#
	.SYNOPSIS
	Write-HorizontalRuleAdv
	
	.DESCRIPTION
	Write-HorizontalRuleAdv
	
    .PARAMETER HRtype
    Horizontal Rule types. Accepted types are 'SingleLine', 'DoubleLine', 'DashedLine', and 'BlankLine'. 
  
    .PARAMETER Endcaps
    Add a character to each end of the horizontal rule. Default is '#'. Set a different endcap character using -EndcapCharacter <single character>
  #>
  
  Param (
    #Script parameters go here
    # https://ss64.com/ps/syntax-args.html
    [Parameter(Mandatory=$false,Position=0)]
    [ValidateSet("SingleLine", "DoubleLine", "DashedLine", "BlankLine")]
    [string]$HRtype = 'SingleLine',
    
    [Parameter(Mandatory=$false)]
    [switch]$Endcaps = $false,

    [Parameter(Mandatory=$false)]
    [string]$EndcapCharacter = '#',
    
    [Parameter(Mandatory=$false)]
    [switch]$IsWarning = $false,

    [Parameter(Mandatory=$false)]
    [switch]$IsVerbose = $false,

    [Parameter(Mandatory=$false)]
    [switch]$MaxLineLength = $false
  )
  
  # Function name:
  # https://stackoverflow.com/questions/3689543/is-there-a-way-to-retrieve-a-powershell-function-name-from-within-a-function#3690830
  #$FunctionName = (Get-PSCallStack | Select-Object FunctionName -Skip 1 -First 1).FunctionName
  #$FunctionName = (Get-Variable MyInvocation -Scope 1).Value.MyCommand.Name
  $FunctionName = $PSCmdlet.MyInvocation.MyCommand.Name
  
  # help about_Automatic_Variables
  # help about_If
  # help about_Comparison_Operators
  # https://ss64.com/ps/if.html
  IF ($LaunchedInCmd) {
    # Print horizontal rule styles here using Write-Host instead of Write-Verbose, since that would add "VERBOSE: " to the beginning of each line and prevent the horizontal rule from lining up on the screen properly.
	# Command Prompt character width: 79
    IF ($HRtype -eq "DoubleLine") {
      $HRoutput = "==============================================================================="
    } ELSEIF ($HRtype -eq "DashedLine") {
      $HRoutput = "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "BlankLine") {
      $HRoutput = "                                                                               "
    } ELSEIF ($HRtype -eq "SingleLine") {
      #HRoutput = "--------------------------------------------------------------------------------" # This too long
      $HRoutput = "-------------------------------------------------------------------------------"
    } ELSEIF (-Not $HRtype) {
      $HRoutput = "-------------------------------------------------------------------------------"
    } ELSE {
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
      Return
    }
  } ELSE {
    # PowerShell window character width: 119
    IF ($HRtype -eq "DoubleLine") {
      $HRoutput = "======================================================================================================================="
    } ELSEIF ($HRtype -eq "DashedLine") {
      $HRoutput = "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "BlankLine") {
      $HRoutput = "                                                                                                                       "
    } ELSEIF ($HRtype -eq "SingleLine") {
      #HRoutput = "------------------------------------------------------------------------------------------------------------------------" # This too long
      $HRoutput = "-----------------------------------------------------------------------------------------------------------------------"
    } ELSEIF (-Not $HRtype) {
      $HRoutput = "-----------------------------------------------------------------------------------------------------------------------"
    } ELSE {
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
      Return
    }
  }
  
  # Command Prompt character width: 79
  # PowerShell window character width: 119
  $MaxLength = $HRoutput.Length
  
  IF ($IsWarning -eq $true -or $IsVerbose -eq $true) {
    #WARNING: 
    #VERBOSE: 
    #123456789
    $MaxLength = $MaxLength - 9
    $HRoutput = ($HRoutput).Substring(9,$MaxLength)
  }
  
  IF ($Endcaps -eq $true) {
    #$EndcapLength = $MaxLength - 2
    $MaxLength = $MaxLength - 2
    #$HRoutput = ($HRoutput).Substring(1,$EndcapLength)
    $HRoutput = ($HRoutput).Substring(1,$MaxLength)
    $HRoutput = "$EndcapCharacter$HRoutput$EndcapCharacter"
  }
  
  $MaxLineLengthOutput = $MaxLength
  
  # Write output
  
  IF ($MaxLineLength -eq $true) {
    Write-Output $MaxLineLengthOutput
  } ELSEIF ($IsWarning -eq $true) {
    Write-Warning $HRoutput -WarningAction Continue
  } ELSEIF ($IsVerbose -eq $true) {
    # Set Verbose message display
    # $VerbosePreference = "Continue"
    # $VerbosePreference = "SilentlyContinue"
    #$OrigVerbosePreference = $VerbosePreference
    #$VerbosePreference = "Continue"
    Write-Verbose $HRoutput
    #$VerbosePreference = $OrigVerbosePreference
  } ELSE {
    Write-Host $HRoutput
  }

} # End Write-HorizontalRuleAdv function -------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

Function Convert-AMPMhourTo24hour {
	<#
		.SYNOPSIS
			Convert an hour value in AM/PM format to a 24-hour value.
		
		.DESCRIPTION
			Enter a 12-hour format value plus its AM/PM value, and this cmdlet will return the equivalent 24-hour format hour value from 0-23. Must specify either -AM or -PM switch.
			
			The abbreviations AM and PM derive from Latin:
			
			AM = Ante meridiem: Before noon
			PM = Post meridiem: After noon
			
			https://www.timeanddate.com/time/am-and-pm.html
			
		.PARAMETER Hours
			The AM/PM hour value, from 1-12.
		
		.PARAMETER AM
			Add a character to each end of the horizontal rule. Default is '#'. Set a different endcap character using -EndcapCharacter <single character>
		
		.PARAMETER PM
			Add a character to each end of the horizontal rule. Default is '#'. Set a different endcap character using -EndcapCharacter <single character>
		
		.EXAMPLE
			#1.
			The following 3 lines will convert any PM Hour value (in this case, 4) and convert it into its 24-hour equivalent.
			C:\PS> $AMPMhour = 4
			C:\PS> $OutputVar = Convert-AMPMhourTo24hour $AMPMhour -PM
			C:\PS> Write-Host "$AMPMhour PM = $OutputVar           (24-hour)"
			In this example, the output would read:
			"4 PM = 16           (24-hour)"
			Because 4:00 PM is equivalent to 16:00 on a 24-hour clock.
			
		.EXAMPLE
			#2.
			
			The following single-line script will get the current hour in AM/PM format (Get-Date -UFormat %I) and convert it to 24-hour format.
			
			C:\PS> Get-Date -UFormat %I | Convert-AMPMhourTo24hour -PM
			
			To capture this output in a variable first, then print it out:
			
			C:\PS> $OutputVar = (Get-Date -UFormat %I | Convert-AMPMhourTo24hour -PM)
			C:\PS> Write-Host "`$OutputVar = $OutputVar"
			C:\PS> Write-Host "$(Get-Date -UFormat %I) PM = $OutputVar           (24-hour)"
			
			For example, if the current time was 2 PM, the output would read:
			"$OutputVar = 14"
			"2 PM = 14           (24-hour)"
			
			For the same thing but with AM times, simply change the -PM switch to the -AM switch:
			
			C:\PS> $OutputVar = (Get-Date -UFormat %I | Convert-AMPMhourTo24hour -AM)
			C:\PS> Write-Host "`$OutputVar = $OutputVar"
			C:\PS> Write-Host "$(Get-Date -UFormat %I) AM = $OutputVar           (24-hour)"
			
			For example, if the current time was 8 PM, the output would read:
			"$OutputVar = 8"
			"8 AM = 8           (24-hour)"
			
		.EXAMPLE
			#3.
			
			To get today's date, but with a different time-value, use a script block invloving Read-Host, Get-Date, and Convert-AMPMhourTo24hour, such as this:
			
			\> $StartHour = Read-Host -Prompt "Enter Start hour"
			
			\> $StartMin = Read-Host -Prompt "Enter Start minute"
			
			\> do {
			\>   $ChoiceAMPM24hour = Read-Host -Prompt "[A]M, [P]M, or [2]4 hour? [A\P\2]"
			\>   switch ($ChoiceAMPM24hour) {
			\> 	   'A' { # A - AM time
			\>            $AntePost = "AM"
			\>            Write-Verbose "AM time ('$ChoiceAMPM24hour') option selected."
			\>            $24hourFormat = Convert-AMPMhourTo24hour -Hours $StartHour -AM
			\>     }
			\>     'P' { # P - PM time
			\>            $AntePost = "PM"
			\>            Write-Verbose "PM time ('$ChoiceAMPM24hour') option selected."
			\>            $24hourFormat = Convert-AMPMhourTo24hour -Hours $StartHour -PM
			\>     }
			\>     2 { # 2 - 24-hour time
			\>            $AntePost = "(24-hour)"
			\>            Write-Verbose "24-hour time ('$ChoiceAMPM24hour') option selected."
			\>            $24hourFormat = $StartHour
			\>     }
			\>     default { # Choice not recognized.
			\>            Write-Host `r`n
			\>            Write-Warning "Choice `"$ChoiceAMPM24hour`" not recognized. Options must be AM, PM, or 24-hour."
			\>            Write-Host `r`n
			\>            #Break #help about_Break
			\>            PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
			\>            #Clear-Host # CLS
			\>            Write-Host `r`n
			\>     }
			\>   }
			\> } until ($ChoiceAMPM24hour -eq 'A' -Or $ChoiceAMPM24hour -eq 'P' -Or $ChoiceAMPM24hour -eq 2)
			\> Write-Verbose "12-hour time '$StartHour:$StartMin $AntePost' converted to 24-hour time ('$24hourFormat:$StartMin')"
			
			\> $DifferentTimeToday = Get-Date -Hour $24hourFormat -Minute $StartMin
			
			This script above will set a <DateTime> type variable called $DifferentTimeToday that is the same date as today, but with a time entered by manually by the user.
			
		.INPUTS
			Requires a "Hours" time value as input, and selection of AM or PM. Hour value must be a positive integer (whole number, non-decimal) between 1 and 12. "Hours" value can be piped int from other commands, but a choice between -AM or -PM switch must still be made. See Examples for more info.
		
		.OUTPUTS
			Returns a [int32] integer number (whole number, not decimal, not negative) between 0 and 23, according to 24-hour time formats, equivalent to the AM/PM input time (hour).
			
		.NOTES
			
			Conversion table between AM/PM hours and 24-hour time format:
			
			--AM/PM----24-hr--------------------------------------------------------------------------------
			12:00 AM = 00:00	*** exception: if AM hours = 12, then 24-hours = 0			\
			 1:00 AM = 01:00	\															 |
			 2:00 AM = 02:00	 |															 |
			 3:00 AM = 03:00	 |															 |
			 4:00 AM = 04:00	 |															 |
			 5:00 AM = 05:00	 |															 |
			 6:00 AM = 06:00	 |------- AM time = 24-hour time							 |-------  AM
			 7:00 AM = 07:00	 |															 |
			 8:00 AM = 08:00	 |															 |
			 9:00 AM = 09:00	 |															 |
			10:00 AM = 10:00	 |															 |
			11:00 AM = 11:00____/___________________________________________________________/_______________
			12:00 PM = 12:00	*** exception: if PM hours = 12, then 24-hours = 12			\
			 1:00 PM = 13:00	\															 |
			 2:00 PM = 14:00	 |															 |
			 3:00 PM = 15:00	 |															 |
			 4:00 PM = 16:00	 |															 |
			 5:00 PM = 17:00	 |															 |
			 6:00 PM = 18:00	 |------- PM hours + 12 = 24-hours							 |-------  PM
			 7:00 PM = 19:00	 |															 |
			 8:00 PM = 20:00	 |															 |
			 9:00 PM = 21:00	 |															 |
			10:00 PM = 22:00	 |															 |
			11:00 PM = 23:00	/															/
			------------------------------------------------------------------------------------------------
			
		.LINK
			https://www.lsoft.com/manuals/maestro/4.0/htmlhelp/interface%20user/TimeConversionTable.html
		
		.LINK
			https://stackoverflow.com/questions/16774064/regular-expression-for-whole-numbers-and-integers
		
		.LINK
			https://www.gngrninja.com/script-ninja/2016/5/15/powershell-getting-started-part-8-accepting-pipeline-input
		
		.LINK
			https://www.timeanddate.com/time/am-and-pm.html
		
	#>
	
	Param (
		#Script parameters go here
		[Parameter(Mandatory=$true,Position=0,
		ValueFromPipeline = $true)]
		# Validate a positive integer (whole number) using Regular Expressions, thanks to:
		#https://stackoverflow.com/questions/16774064/regular-expression-for-whole-numbers-and-integers
		#	(?<![-.])		# Assert that the previous character isn't a minus sign or a dot.
		#	\b				# Anchor the match to the start of a number.
		#	[0-9]+			# Match a number.
		#	\b				# Anchor the match to the end of the number.
		#	(?!\.[0-9])		# Assert that no decimal part follows.
		#$RegEx = "(?<![-.])\b[0-9]+\b(?!\.[0-9])"
		#[ValidatePattern("(?<![-.])\b[0-9]+\b(?!\.[0-9])")]
		# This [ValidateScript({))] does the exact same thing as the [ValidatePattern("")] above, it just throws much nicer, customizable error messages.
		[ValidateScript({
            If ($_ -match "(?<![-.])\b[0-9]+\b(?!\.[0-9])") {
                $True
            } else {
                Throw "$_ must be a positive integer (whole number, no decimals)."
            }
        })]
		[ValidateRange(1,12)]
		# Bugfix: To properly validate regex for integer ranges, and throw an error if a decimal value is provided, do not use [int]$var since PowerShell will automatically round the input value before performing the [ValidatePattern("")] regex comparison. Instead, declare parameter without [int] e.g. $var,
		$Hours,
		
		[Parameter(Mandatory=$true,
		ParameterSetName='AMtag')]
		[switch]$AM,
		
		[Parameter(Mandatory=$true,
		ParameterSetName='PMtag')]
		[switch]$PM
	)
	
	<#
	------------------------------------------------------------------------------------------------
	12:00 AM = 00:00	*** exception: if AM hours = 12, subtract 12 for 24-hours	\
	1:00 AM = 01:00		\															 |
	2:00 AM = 02:00		 |															 |
	3:00 AM = 03:00		 |															 |
	4:00 AM = 04:00		 |															 |
	5:00 AM = 05:00		 |															 |
	6:00 AM = 06:00		 |------- AM time = 24-hour time							 |-------  AM
	7:00 AM = 07:00		 |															 |
	8:00 AM = 08:00		 |															 |
	9:00 AM = 09:00		 |															 |
	10:00 AM = 10:00	 |															 |
	11:00 AM = 11:00____/___________________________________________________________/_______________
	12:00 PM = 12:00	*** exception: if PM hours = 12, 24-hours = 12				\
	1:00 PM = 13:00		\															 |
	2:00 PM = 14:00		 |															 |
	3:00 PM = 15:00		 |															 |
	4:00 PM = 16:00		 |															 |
	5:00 PM = 17:00		 |															 |
	6:00 PM = 18:00		 |------- PM hours + 12 = 24-hours							 |-------  PM
	7:00 PM = 19:00		 |															 |
	8:00 PM = 20:00		 |															 |
	9:00 PM = 21:00		 |															 |
	10:00 PM = 22:00	 |															 |
	11:00 PM = 23:00	/															/
	------------------------------------------------------------------------------------------------
	#>
	
	#-----------------------------------------------------------------------------------------------------------------------
	# Convert AM hours
	#-----------------------------------------------------------------------------------------------------------------------
	
	If ($AM) {
		If ($AM -eq 12) {
			$24hour = 0
		} else {
			$24hour = $Hours
		}
	}
	
	#-----------------------------------------------------------------------------------------------------------------------
	# Convert PM hours
	#-----------------------------------------------------------------------------------------------------------------------
	
	If ($PM) {
		If ($PM -eq 12) {
			$24hour = 12
		} else {
			$24hour = [Int]$Hours + 12
		}
	}
	
	#-----------------------------------------------------------------------------------------------------------------------
	# Write out result of function
	#-----------------------------------------------------------------------------------------------------------------------
	
	#$24hour
	
	Return $24hour
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
} # End Convert-AMPMhourTo24hour function -------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------



#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Once [Functions] block has finished running, exit the script if -LoadFunctions switch is on.
If ($LoadFunctions) {
  #https://stackoverflow.com/questions/2022326/terminating-a-script-in-powershell
  # Only load functions of script. Do not execute Main script block.
  Return
}
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------[Execution]------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
#=======================================================================================================================
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#

Write-Host "--------------------------------------------------------------------------------------------------"

#

<#
12.1
11.6
11.4
11
011
9.6
9.4
09
9
-9
.9
0.9
.0
0.0
#>

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

help Convert-AMPMhourTo24hour

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

help Convert-AMPMhourTo24hour -full

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

Write-Host "--------------------------------------------------------------------------------------------------"

<#
Write-Host "Failure:"
Convert-AMPMhourTo24hour 0 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 1 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 12 -AM


Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 09.6 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 09.4 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 12.1 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 11.6 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 11.4 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 11 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 011 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 9.6 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 9.4 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 009 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 09 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 9 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour -9 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour .9 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 0.9 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour .0 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 0.0 -AM

#>

Write-Host "--------------------------------------------------------------------------------------------------"

#

Write-Host `r`n

Write-Host "Example #1:"

$AMPMhour = 4

$OutputVar = Convert-AMPMhourTo24hour $AMPMhour -PM

Write-Host "$AMPMhour PM = $OutputVar           (24-hour)"

Write-Host `r`n

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

Write-Host `r`n

Write-Host "Example #2:"

Get-Date -UFormat %I | Convert-AMPMhourTo24hour -PM

$NowHour = Get-Date -UFormat %I
Write-Host "`$NowHour = $NowHour"

$OutputVar = (Get-Date -UFormat %I | Convert-AMPMhourTo24hour -PM)
Write-Host "`$OutputVar = $OutputVar"

Write-Host "$NowHour PM = $OutputVar           (24-hour)"
Write-Host "$(Get-Date -UFormat %I) PM = $OutputVar           (24-hour)"

Write-Host `r`n

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

Write-Host `r`n

Write-Host "Example #3:"

Get-Random -Minimum 1 -Maximum 12 | Convert-AMPMhourTo24hour -PM

Get-Random -Minimum 1 -Maximum 12 | Tee-Object -Variable Randomvar | Convert-AMPMhourTo24hour -PM
Write-Host "`$Randomvar = $Randomvar"

$OutputVar = (Get-Random -Minimum 1 -Maximum 12 | Tee-Object -Variable Randomvar | Convert-AMPMhourTo24hour -PM)
Write-Host "$Randomvar PM = $OutputVar           (24-hour)"

Write-Host `r`n

#

Write-Host "--------------------------------------------------------------------------------------------------"

#



