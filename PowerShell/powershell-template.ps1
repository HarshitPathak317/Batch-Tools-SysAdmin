<#
.SYNOPSIS
  <Overview of script>

.DESCRIPTION
  <Brief description of script>

.PARAMETER -SampleParam
  <This parameter text will not be shown, since -SampleParam is not a real parameter listed in Param(). However, if a .PARAMETER help line is present and there is no Param(), all help text will fail.>

.PARAMETER LaunchedInCmd
  Used to indicate to this script when it has been launched in a Command Prompt windows (CMD.EXE)
  
  Formats output to the size of a standard Command Prompt (79 characters wide + 1) or to the size of a standard PowerShell window (119 characters winde + 1)

.PARAMETER LoadFunctions
  Use this switch to only load the functions in this script. The script main body execution will not run.

.INPUTS
  <Inputs if any, otherwise state None>

.OUTPUTS 
Log File
  The script log file stored in C:\Windows\Temp\<name>.log

.NOTES
  Version:        1.0
  Author:         <Name>
  Creation Date:  <Date>
  Purpose/Change: Initial script development

  Requires PSLogging module from 
  https://9to5it.com/powershell-logging-v2-easily-create-log-files/
  PowerShell Gallery:
  https://www.powershellgallery.com/packages/PSLogging/
  GitHub:
  https://www.powershellgallery.com/packages/PSLogging/

  AUTOGENERATED CONTENT
    The name, syntax, parameter list, parameter attribute table, common
    parameters, and remarks are automatically generated by the Get-Help cmdlet.

.EXAMPLE
  <Example explanation goes here>
  
  <Example goes here. Repeat this attribute for more than one example>

.LINK
about_Comment_Based_Help

.LINK
about_Requires

.LINK
about_Scripts

.LINK
https://ss64.com/ps/syntax-run.html

.LINK
https://ss64.com/ps/call.html

.LINK
about_Functions_CmdletBindingAttribute
#>

#-----------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------#Requires-------------------------------------------------------

#Requires -Modules PSLogging
<#
# "#Requires" - You can use a #Requires statement to prevent a script from running without specified modules or snap-ins and a specified version of PowerShell. For more information, see about_Requires.
# help about_Requires
# help about_PSSnapins
# e.g. "#Requires -Version 6" "#Requires -RunAsAdministrator"
#>

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#1. PSLogging module
<#
# To insatll PSLogging module:
# https://docs.microsoft.com/en-us/powershell/developer/module/installing-a-powershell-module
# PowerShell v4:
# 	1. Find PSModulePath environment variable
# 		$Env:PSModulePath
# 		[Environment]::GetEnvironmentVariable("PSModulePath")
#	2. Find the PSLogging module
# 		.\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging
# 	3. Either copy the module to a location within the PSModulePath environment variable, or add the location of the module to the PSModulePath environment variable.
# 		3a. Copy the module to the location:
# 			# Install for Current User - $Home\Documents\WindowsPowerShell\Modules (%UserProfile%\Documents\WindowsPowerShell\Modules)
# 				$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 				$Destination = "$Home\Documents\WindowsPowerShell\Modules"
# 				Copy-Item "$newModule" -Destination "$Destination\PSLogging" -Recurse
# 			# Install for All Users - $Env:ProgramFiles\WindowsPowerShell\Modules (%ProgramFiles%\WindowsPowerShell\Modules)
# 				$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 				$Destination = "$Env:ProgramFiles\WindowsPowerShell\Modules"
# 				Copy-Item "$newModule" -Destination "$Destination\PSLogging" -Recurse
# 		3b. Add the module's path to the PSModulePath environment variable
# 			$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 			$p = [Environment]::GetEnvironmentVariable("PSModulePath")
# 			$p += ";$newModule"
# 			[Environment]::SetEnvironmentVariable("PSModulePath",$p)
# PowerShell v5: (and above)
# 	Find-Module -Name "PSLogging*" | Install-Module -Scope AllUsers 
# Accepted values: CurrentUser, AllUsers
# 	Update-Module PSLogging -Force
#>

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------[Header]--------------------------------------------------------

# Index:
# 1. <# .HELP #>
# 2. #Requires
# 3. [Header]
# 4. [Script Parameters]
# 5. [Initializations]
# 6. [Modules]
# 7. [Declarations]
# 8. [Functions]
# 9. [Execution]
# 10. [Footer]

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Run this script:
<#
# Tested with PowerShell versions:
# 5.1
# Get PowerShell version:
# $PSVersionTable.PSVersion

# To run from PowerShell command line:
# https://ss64.com/ps/syntax-run.html
# https://ss64.com/ps/syntax-scriptblock.html
# When passing a variable to a scriptblock it is important to consider the variable scope.
#    Each time the scriptblock is run; it will dynamically read the current value of the variable.
#    When a scriptblock is run using the "." (dot) operator, updates to a variable apply to the current scope.
#    When a scriptblock is run using the "&" (call) operator, updates to a variable are not reflected in the parent scope.
# help about_Scripts
# %USERPROFILE% = $env:UserProfile = $Home
# 'Dot-sourcing:'
# . "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\powershell-template.ps1"
# . "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\powershell-template.ps1" -Verbose -Debug
# . "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\powershell-template.ps1" -Verbose -Debug -LaunchedInCmd
# . "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\powershell-template.ps1" -LoadFunctions
# https://ss64.com/ps/source.html
# Using the 'call' operator (&):
# & "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\powershell-template.ps1"
# & "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\powershell-template.ps1" -Verbose -Debug
# & "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\powershell-template.ps1" -Verbose -Debug -LaunchedInCmd
# https://ss64.com/ps/call.html

# To run help:
# Get-Help "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\powershell-template.ps1"
# Get-Help "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\powershell-template.ps1" -Full
# Example help file:
# Get-Help Get-ChildItem
# Get-Help Get-ChildItem -Full

# Execution Policy:
# $oldExecutionPolicy = Get-ExecutionPolicy
# Set-ExecutionPolicy -ExecutionPolicy RemoteSigned
# Set-ExecutionPolicy -ExecutionPolicy Bypass
# Set-ExecutionPolicy $oldExecutionPolicy
#>

#-----------------------------------------------------------------------------------------------------------------------
#--------------------------------------------------[Script Parameters]--------------------------------------------------

# Debugging: absolutely NO commands can come before Param (except for [CmdletBinding()] )
# Debugging: You must have a script parameter defined here if you have the Help Topic .PARAMETER defined above.
# https://ss64.com/ps/syntax-args.html

[CmdletBinding()]
#[CmdletBinding(SupportsShouldProcess=$true)]

#Script parameters go here
Param (
  #Script parameters go here
  # Debugging: You must have a script parameter defined here if you have the Help Topic .PARAMETER defined above.
  # help about_Functions_Advanced_Parameters
  # https://ss64.com/ps/syntax-args.html
  # https://ss64.com/ps/syntax-automatic-variables.html

  [Parameter(Mandatory=$false)]
  [switch]$LaunchedInCmd = $false,

  [Parameter(Mandatory=$false)]
  [switch]$LoadFunctions = $false
)

#-----------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------[Initializations]---------------------------------------------------

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Skip [Initializations] script block if -LoadFunctions is on.
If (-Not $LoadFunctions) {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Script name (including extension)
$ScriptName = $MyInvocation.MyCommand.Name
Write-Verbose "Script name:"
Write-Verbose "$ScriptName"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

# Script dir (home directory of script)
Write-Verbose "Script home directory:"
#https://stackoverflow.com/questions/801967/how-can-i-find-the-source-path-of-an-executing-script/6985381#6985381
$ScriptDir = Split-Path $script:MyInvocation.MyCommand.Path
Write-Verbose "$ScriptDir"
$ScriptDir = Split-Path -parent $MyInvocation.MyCommand.Definition # PoSh v2 compatible - thanks to https://stackoverflow.com/questions/5466329/whats-the-best-way-to-determine-the-location-of-the-current-powershell-script
Write-Verbose "$ScriptDir"
$ScriptDir = $PSScriptRoot # PoSh v3 compatible - This is an automatic variable set to the current file's/module's directory
Write-Verbose "$ScriptDir"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

# Script path (full file path & name & extension of currently running script)
$ScriptPath = $MyInvocation.MyCommand.Path
Write-Verbose "Script full path:"
Write-Verbose "$ScriptPath"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

#Set Error Action to Silently Continue
$ErrorActionPreference = 'SilentlyContinue'
#Set Error Action to Continue
$ErrorActionPreference = 'Continue'

#Set Verbose message display
#$VerbosePreference = "SilentlyContinue" # Will suppress Write-Verbose messages. This is the default value.
#$VerbosePreference = "Continue" # Will print out Write-Verbose messages. Gets set when -Verbose switch is used to run the script. (Or when you set the variable manually.)

#Set Debug message display
# help about_Debuggers
#$DebugPreference = "SilentlyContinue"
#$DebugPreference = "Continue"

#Set Progress Bar display
#* If the progress bar does not appear, check the value of the $ProgressPreference variable. If the value is set to SilentlyContinue, the progress bar is not displayed. For more information about Windows PowerShell preferences, see about_Preference_Variables.
#$ProgressPreference = "SilentlyContinue"
#$ProgressPreference = "Continue"

#Set Informational message display
#$InformationPreference = "SilentlyContinue"
#$InformationPreference = "Continue"

#Check Execution Policy
$RecommendedExecutionPolicy = "RemoteSigned"
Write-Verbose "Recommended Execution Policy = $RecommendedExecutionPolicy"
#Write-Host "Current Execution Policy =" (Get-ExecutionPolicy)
$startExecutionPolicy = Get-ExecutionPolicy
Write-Verbose "Current Execution Policy = $startExecutionPolicy"

#Check PowerShell version
$MinimumRequiredVersion = 6
# https://ss64.com/ps/get-host.html
# https://stackoverflow.com/questions/1825585/determine-installed-powershell-version
$PoShVersion = $PSVersionTable.PSVersion
Write-Verbose "Minimum required PowerShell version = $MinimumRequiredVersion"
Write-Verbose "Current PowerShell version = $($PSVersionTable.PSVersion.Major).$($PSVersionTable.PSVersion.Minor)"
# https://ss64.com/ps/if.html
IF ($PSVersionTable.PSVersion.Major -lt $MinimumRequiredVersion) {
    Write-Warning "This script requires at least PowerShell version $MinimumRequiredVersion. Running version $PoShVersion"
	Write-Debug "This script requires at least PowerShell version $MinimumRequiredVersion. Running version $PoShVersion"
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}
# Skip [Initializations] script block if -LoadFunctions is on.
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------[Modules]-------------------------------------------------------

#Import Modules & Snap-ins
Write-Verbose "Importing modules..."
Write-Verbose `n # New line (carriage return and newline, `r`n)

Import-Module PSLogging

Write-Verbose `r`n
Write-Verbose "Module import complete..."

#-----------------------------------------------------------------------------------------------------------------------
#-----------------------------------------------------[Declarations]----------------------------------------------------

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Skip [Declarations] script block if -LoadFunctions is on.
If (-Not $LoadFunctions) {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#Script Version
$sScriptVersion = '1.0'

#Log File Info
$sLogPath = $ScriptDir
$yesterday = [DateTime]::Today.AddDays(-1)
$TodaysDate = Get-Date -Format FileDate
Write-Verbose "Date code = $TodaysDate"
$sLogName = $MyInvocation.MyCommand.Name.Substring(0,$MyInvocation.MyCommand.Name.Length-4) + "_" + $TodaysDate + ".log"
Write-Verbose "LogName = $sLogName"
$sLogFile = Join-Path -Path $sLogPath -ChildPath $sLogName
Write-Verbose "LogFile = $sLogFile"

# Create Log file if we don't have one already
If (!($sLogPath)) { Start-Log -LogPath $sLogPath -LogName $sLogName -ScriptVersion $sScriptVersion }

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}
# Skip [Declarations] script block if -LoadFunctions is on.
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------[Functions]------------------------------------------------------

# help about_Functions
# help about_Functions_Advanced
# help about_Functions_Advanced_Methods
# help about_Functions_Advanced_Parameters
# Get-Verb

#Index of functions:
# 1. <FunctionName> (Example Function)
# 2. Start-PSAdmin
# 3. Get-ScriptDirectory1
# 4. Get-ScriptDirectory2
# 5. Get-ScriptDirectory3
# 6. Write-HorizontalRule
# 7. Write-HorizontalRuleAdv (Aliases: "Write-HR")
# 8. PromptForChoice-YesNoSectionSkip
# 9. ReadPrompt-AMPM24
# 10. ReadPrompt-Hour
# 11. ReadPrompt-ValidateIntegerRange
# 12. ReadPrompt-Minute 
# 13. ReadPrompt-DayOfMonth
# 14. ReadPrompt-Month
# 15. Convert-AMPMhourTo24hour
# 16. Convert-TimeZone

#-----------------------------------------------------------------------------------------------------------------------
<# Function <FunctionName> {
  Param ()

  Begin {
    Write-LogInfo -LogPath $sLogFile -Message '<description of what is going on>...'
  }

  Process {
    Try {
      <code goes here>
    }

    Catch {
      Write-LogError -LogPath $sLogFile -Message $_.Exception -ExitGracefully
      Break
    }
  }

  End {
    If ($?) {
      Write-LogInfo -LogPath $sLogFile -Message 'Completed Successfully.'
      Write-LogInfo -LogPath $sLogFile -Message ' '
    }
  }
} #> # End <FunctionName> function ----------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
function Start-PSAdmin {Start-Process PowerShell -Verb RunAs}
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
function Get-ScriptDirectory1 { #https://stackoverflow.com/questions/801967/how-can-i-find-the-source-path-of-an-executing-script/6985381#6985381
  <#
  .NOTES
  From:
  https://www.red-gate.com/simple-talk/dotnet/.net-tools/further-down-the-rabbit-hole-powershell-modules-and-encapsulation/#third
  
  To illustrate the difference between the two implementations, I created a test vehicle that evaluates the target expression in four different ways (bracketed terms are keys in the table that follows):
  
    - Inline code [inline]
    - Inline function, i.e. function in the main program [inline function]
    - Dot-sourced function, i.e. the same function moved to a separate .ps1 file [dot source]
    - Module function, i.e. the same function moved to a separate .psm1 file [module]
  
  The first two columns in the table define the scenario; the last two columns display the results of the two candidate implementations of Get-ScriptDirectory. A result of script means that the invocation correctly reported the location of the script. A result of module means the invocation reported the location of the module (see next section) containing the function rather than the script that called the function; this indicates a drawback of both implementations such that you cannot put this function in a module to find the location of the calling script. Setting this module issue aside, the remarkable observation from the table is that using the parent scope approach fails most of the time (in fact, twice as often as it succeeds)!
  
  ________________________________________________________________
  | Where Called | What Called     | Script Scope | Parent Scope |
  |--------------|-----------------|--------------|--------------|
  | Top Level    | inline          | script       | error        |
  |              | inline function | script       | script       |
  |              | dot source      | script       | script       |
  |              | module          | module       | module       |
  | Nested once  | inline          | script       | script       |
  |              | inline function | script       | error        |
  |              | dot source      | script       | error        |
  |              | module          | module       | module       |
  | Nested twice | inline          | script       | error        |
  |              | inline function | script       | error        |
  |              | dot source      | script       | error        |
  |              | module          | module       | module       |
  ----------------------------------------------------------------
  
  (You can find my test vehicle code for this in my post on StackOverflow.)
  
  .EXAMPLE  
  Write-Host (Get-ScriptDirectory1)
  
  .LINK
  https://stackoverflow.com/questions/801967/how-can-i-find-the-source-path-of-an-executing-script/6985381#6985381
  
  .LINK
  https://www.red-gate.com/simple-talk/dotnet/.net-tools/further-down-the-rabbit-hole-powershell-modules-and-encapsulation/#third
  
  #>
    Split-Path $script:MyInvocation.MyCommand.Path
} # End Get-ScriptDirectory function -----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
function Get-ScriptDirectory2 { #https://stackoverflow.com/questions/1183183/path-of-currently-executing-powershell-script#1183197
    <#
	.LINK
	https://stackoverflow.com/questions/1183183/path-of-currently-executing-powershell-script#1183197
	#>
	# For PowerShell 3.0 users - following works for both modules and script files:
    Split-Path -parent $PSCommandPath
} # End Get-ScriptDirectory function -----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
function Get-ScriptDirectory3 { #https://stackoverflow.com/questions/1183183/path-of-currently-executing-powershell-script#1183197
  <#
  .NOTES
  Thanks to Jeffrey Snover of the PowerShell team:
  https://www.red-gate.com/simple-talk/dotnet/.net-tools/further-down-the-rabbit-hole-powershell-modules-and-encapsulation/#third
  
  .EXAMPLE  
  Write-Host (Get-ScriptDirectory3)
  
  Will properly display the directory where your script resides rather than your current directory. 
  
  **Maybe.** The results you get from this function depend on where you call it from!
  
  See Get-ScriptDirectory1 and 
  https://www.red-gate.com/simple-talk/dotnet/.net-tools/further-down-the-rabbit-hole-powershell-modules-and-encapsulation/#third
  for more information.
  
  .LINK
  https://stackoverflow.com/questions/1183183/path-of-currently-executing-powershell-script#1183197
  
  .LINK
  https://www.red-gate.com/simple-talk/dotnet/.net-tools/further-down-the-rabbit-hole-powershell-modules-and-encapsulation/#third
  #>
  $Invocation = (Get-Variable MyInvocation -Scope 1).Value
  Split-Path $Invocation.MyCommand.Path
} # End Get-ScriptDirectory function -----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
Function Write-HorizontalRule { #---------------------------------------------------------------------------------------
  Param (
    #Script parameters go here
    # https://ss64.com/ps/syntax-args.html
    [Parameter(Mandatory=$false,Position=0)]
    [string]$HRtype = 'SingleLine'
  )
  
  # help about_Automatic_Variables
  # help about_If
  # help about_Comparison_Operators
  # https://ss64.com/ps/if.html
  IF ($LaunchedInCmd -eq $true) {
    # Print horizontal rule styles here using Write-Host instead of Write-Verbose, since that would add "VERBOSE: " to the beginning of each line and prevent the horizontal rule from lining up on the screen properly.
	# Command Prompt character width: 79
    IF ($HRtype -eq "DoubleLine") {
      Write-Host ===============================================================================
    } ELSEIF ($HRtype -eq "DashedLine") {
      Write-Host "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "SingleLine") {
      #Write-Host -------------------------------------------------------------------------------- # This too long
      Write-Host -------------------------------------------------------------------------------
    } ELSEIF (-Not $HRtype) {
      Write-Host -------------------------------------------------------------------------------
    } ELSE {
      Write-Verbose "PowerShell Script launched in cmd.exe = $LaunchedInCmd"
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
    }
  } ELSEIF ($LaunchedInCmd -eq $false) {
    # PowerShell window character width: 119
    IF ($HRtype -eq "DoubleLine") {
      Write-Host =======================================================================================================================
    } ELSEIF ($HRtype -eq "DashedLine") {
      Write-Host - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    } ELSEIF ($HRtype -eq "SingleLine") {
      #Write-Host ------------------------------------------------------------------------------------------------------------------------ # This too long
      Write-Host -----------------------------------------------------------------------------------------------------------------------
    } ELSEIF (-Not $HRtype) {
      Write-Host -----------------------------------------------------------------------------------------------------------------------
    } ELSE {
      Write-Verbose "PowerShell Script launched in cmd.exe = $LaunchedInCmd"
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
    }
  }
} # End Write-HorizontalRule function ----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
Function Write-HorizontalRuleAdv { #------------------------------------------------------------------------------------
  <#
	.SYNOPSIS
	Writes a horizontal rule across the the console. 
	
	.DESCRIPTION
	Writes either a horzintal rule of different types:
	
	SingleLine "-------------------------" (default)
	DoubleLine "========================="
	DashedLine "- - - - - - - - - - - - -"
	BlankLine  "                         "
	
	Using different output types:
	
	using Write-Host (default):
	"-------------------------"
	
	using Write-Warning:
	"WARNING: ----------------"
	
	using Write-Verbose:
	"VERBOSE: ----------------"
	
	.PARAMETER HRtype
	Horizontal Rule types. Accepted types are 'SingleLine', 'DoubleLine', 'DashedLine', and 'BlankLine'. Defaults to 'SingleLine'.
	
	.PARAMETER SingleLine
	Set horizontal rule type as 'SingleLine'. Uses hyphen ('-'). If no other horizontal rule type is selected, will default to this.
	
	.PARAMETER DoubleLine
	Set horizontal rule type as 'DoubleLine'. Uses equals sign ('=')
	
	.PARAMETER DashedLine
	Set horizontal rule type as 'DashedLine'. Uses spaces between hyphen sign.
	
	.PARAMETER BlankLine
	Set horizontal rule type as 'BlankLine'
	
	.PARAMETER Endcaps
	Add a character to each end of the horizontal rule. Default is '#'. Set a different endcap character using -EndcapCharacter <single character>
	
	.PARAMETER EndcapCharacter
	Define which character is used as the end-cap using -EndcapCharacter "<SINGLE_CHARACTER>". Only works if the -Endcaps switch is also enabled. Default is '#'. 
	
	.PARAMETER IsWarning
	Prints the output as a warning (using Write-Warning).
	
	.PARAMETER IsVerbose
	Prints the output as a verbose message (using Write-Verbose). Will only be displayed if $VerbosePreference = "Continue"
	
	.EXAMPLE
	Write-HorizontalRuleAdv -BlankLine -Endcaps
	
	Prints a horizontal rule string like:
	"#                       #"
	
	.EXAMPLE
	Write-HR -double
	
	Uses the alias Write-HR to print a doubled horizontal rule (using the equals sign) like:
	"========================="
	
	.EXAMPLE
	Write-HR -dashed -IsWarning
	
	Uses the Write-HR alias to print a warning using Write-Warning, like:
	"WARNING:  - - - - - - - -"
	
	.EXAMPLE
	Write-HorizontalRuleAdv -HRtype SingleLine -Endcaps
	PS C:\> Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `|
	PS C:\> Write-HorizontalRuleAdv -HRtype DashedLine -Endcaps
	PS C:\> Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `|
	PS C:\> Write-HorizontalRuleAdv -HRtype DoubleLine -Endcaps
	
	Outputs something like:
	"#-----------------------#"
	"|                       |"
	"# - - - - - - - - - - - #"
	"|                       |"
	"#=======================#"
	
	.INPUTS
	If run without any input parameters, will default to a SingleLine "-----" ouput using Write-Host.
	
	.OUTPUTS
	Outputs a horizontal rule across the console of the selected type.
	
	.NOTES
	Command Prompt character width: 79
	PowerShell window character width: 119
	
	WARNING: 
	VERBOSE: 
	123456789
	
	.LINK
	about_Comment_Based_Help
	
	.LINK
	about_Functions_Advanced_Parameters
	
	.LINK
	https://docs.microsoft.com/en-us/powershell/developer/cmdlet/validating-parameter-input
	
	.LINK
	https://social.technet.microsoft.com/wiki/contents/articles/15994.powershell-advanced-function-parameter-attributes.aspx
	
	.LINK
	help about_Automatic_Variables
	
	.LINK
	help about_If
	
	.LINK
	help about_Comparison_Operators
	
  #>
  
  #- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  [cmdletbinding(
    DefaultParameterSetName='DefineString'
  )]
  Param (
    #Script parameters go here
    # https://ss64.com/ps/syntax-args.html
    [Parameter(Mandatory=$false,Position=0,
    ParameterSetName='DefineString')]
    [ValidateSet("SingleLine", "DoubleLine", "DashedLine", "BlankLine")]
    [Alias('HorizontalRule','HorizontalRuleType','Type','hr')]
    [string]$HRtype = 'SingleLine',
    
    [Parameter(ParameterSetName='SingleLine')]
    [Alias('s','single')]
    [switch]$SingleLine,
    
    [Parameter(ParameterSetName='DoubleLine')]
    [Alias('d','dbl','double')]
    [switch]$DoubleLine,
    
    [Parameter(ParameterSetName='DashedLine')]
    [Alias('dash','dashed')]
    [switch]$DashedLine,
    
    [Parameter(ParameterSetName='BlankLine')]
    [Alias('blank')]
    [switch]$BlankLine,
    
    [Parameter(Mandatory=$false)]
    [switch]$Endcaps = $false,

    [Parameter(Mandatory=$false)]
    [string]$EndcapCharacter = '#',
    
    [Parameter(Mandatory=$false)]
    [switch]$IsWarning = $false,

    [Parameter(Mandatory=$false)]
    [switch]$IsVerbose = $false,

    [Parameter(Mandatory=$false)]
    [switch]$MaxLineLength = $false
  )
  
  #- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  # Function name:
  # https://stackoverflow.com/questions/3689543/is-there-a-way-to-retrieve-a-powershell-function-name-from-within-a-function#3690830
  #$FunctionName = (Get-PSCallStack | Select-Object FunctionName -Skip 1 -First 1).FunctionName
  #$FunctionName = (Get-Variable MyInvocation -Scope 1).Value.MyCommand.Name
  $FunctionName = $PSCmdlet.MyInvocation.MyCommand.Name
  
  # Set $HRtype
  If ($SingleLine) {
    $HRtype = "SingleLine"
  } elseif ($DoubleLine) {
    $HRtype = "DoubleLine"
  } elseif ($DashedLine) {
    $HRtype = "DashedLine"
  } elseif ($BlankLine) {
    $HRtype = "BlankLine"
  }
  
  # Detect if $LaunchedInCmd
  
  # help about_Automatic_Variables
  # help about_If
  # help about_Comparison_Operators
  # https://ss64.com/ps/if.html
  IF ($LaunchedInCmd) {
    # Print horizontal rule styles here using Write-Host instead of Write-Verbose, since that would add "VERBOSE: " to the beginning of each line and prevent the horizontal rule from lining up on the screen properly.
    # Command Prompt character width: 79
    IF ($HRtype -eq "DoubleLine") {
      $HRoutput = "==============================================================================="
    } ELSEIF ($HRtype -eq "DashedLine") {
      $HRoutput = "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "BlankLine") {
      $HRoutput = "                                                                               "
    } ELSEIF ($HRtype -eq "SingleLine") {
      #HRoutput = "--------------------------------------------------------------------------------" # This too long
      $HRoutput = "-------------------------------------------------------------------------------"
    } ELSEIF (-Not $HRtype) {
      $HRoutput = "-------------------------------------------------------------------------------"
    } ELSE {
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
      Return
    }
  } ELSE {
    # PowerShell window character width: 119
    IF ($HRtype -eq "DoubleLine") {
      $HRoutput = "======================================================================================================================="
    } ELSEIF ($HRtype -eq "DashedLine") {
      $HRoutput = "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "BlankLine") {
      $HRoutput = "                                                                                                                       "
    } ELSEIF ($HRtype -eq "SingleLine") {
      #HRoutput = "------------------------------------------------------------------------------------------------------------------------" # This too long
      $HRoutput = "-----------------------------------------------------------------------------------------------------------------------"
    } ELSEIF (-Not $HRtype) {
      $HRoutput = "-----------------------------------------------------------------------------------------------------------------------"
    } ELSE {
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
      Return
    }
  }
  
  # Command Prompt character width: 79
  # PowerShell window character width: 119
  $MaxLength = $HRoutput.Length
  
  IF ($IsWarning -eq $true -or $IsVerbose -eq $true) {
    #WARNING: 
    #VERBOSE: 
    #123456789
    $MaxLength = $MaxLength - 9
    $HRoutput = ($HRoutput).Substring(9,$MaxLength)
  }
  
  IF ($Endcaps -eq $true) {
    #$EndcapLength = $MaxLength - 2
    $MaxLength = $MaxLength - 2
    #$HRoutput = ($HRoutput).Substring(1,$EndcapLength)
    $HRoutput = ($HRoutput).Substring(1,$MaxLength)
    $HRoutput = "$EndcapCharacter$HRoutput$EndcapCharacter"
  }
  
  $MaxLineLengthOutput = $MaxLength
  
  # Write output
  
  IF ($MaxLineLength -eq $true) {
    Write-Output $MaxLineLengthOutput
  } ELSEIF ($IsWarning -eq $true) {
    Write-Warning $HRoutput -WarningAction Continue
  } ELSEIF ($IsVerbose -eq $true) {
    # Set Verbose message display
	#$VerbosePreference = "SilentlyContinue" # Will suppress Write-Verbose messages. This is the default value.
	#$VerbosePreference = "Continue" # Will print out Write-Verbose messages. Gets set when -Verbose switch is used to run the script. (Or when you set the variable manually.)
    #$OrigVerbosePreference = $VerbosePreference
    #$VerbosePreference = "Continue" # Print out Write-Verbose messages.
    Write-Verbose $HRoutput
    #$VerbosePreference = $OrigVerbosePreference
  } ELSE {
    Write-Host $HRoutput
  }
  
  #- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
} # End Write-HorizontalRuleAdv function -------------------------------------------------------------------------------
Set-Alias -Name "Write-HR" -Value "Write-HorizontalRuleAdv" # -Scope Global
#-----------------------------------------------------------------------------------------------------------------------

Function DateToiso($Zeit) {
  <#
  .LINK
  https://ss64.com/ps/syntax-dateformats.htmls
  #>
  "Returns an array containing the ISO Year, Week and DayofWeek"
  $DayofWeek = +$Zeit.DayofWeek
  if ($DayofWeek -eq 0) { $DayofWeek = 7 }           # Mon=1..Sun=7
  $Thursday = $Zeit.AddDays(4 - $DayofWeek)          # Go to nearest Thursday
  $Week = 1+[Math]::Floor(($Thursday.DayOfYear-1)/7) # Adjusted seventh
  $Year = $Thursday.Year         # Needed
  $Year, $Week, $DayofWeek
} # Source Dr J R Stockton 

#-----------------------------------------------------------------------------------------------------------------------
Function PromptForChoice-YesNoSectionSkip { #---------------------------------------------------------------------------
	
	Param (
		#Script parameters go here
		[Parameter(Mandatory=$false,Position=0,
		ValueFromPipeline = $true)]
		[string]$SectionName
	)
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	#-----------------------------------------------------------------------------------------------------------------------
	# Build Choice Prompt
	#-----------------------------------------------------------------------------------------------------------------------
	$Title = "Skip this section?"
	$Info = "$SectionName"
	$ChoiceYes = New-Object System.Management.Automation.Host.ChoiceDescription "&Yes", "[Y]es, skip this section."
	$ChoiceNo = New-Object System.Management.Automation.Host.ChoiceDescription "&No", "[N]o, do not skip this section"
	$Options = [System.Management.Automation.Host.ChoiceDescription[]]($ChoiceYes, $ChoiceNo)
	# default choice: 0 = first Option, 1 = second option, etc.
	[int]$defaultchoice = 0
	#-----------------------------------------------------------------------------------------------------------------------
	# Execute Choice Prompt
	#-----------------------------------------------------------------------------------------------------------------------
	# PromptForChoice() output will always be integer: https://powershell.org/forums/topic/question-regarding-result-host-ui-promptforchoice/
	If ($SectionName) {
		$answer = $host.UI.PromptForChoice($Title, $Info, $Options, $defaultchoice)
	} else {
		$answer = $host.UI.PromptForChoice($Title, "", $Options, $defaultchoice)
	}
	#-----------------------------------------------------------------------------------------------------------------------
	# Interpret answer
	#-----------------------------------------------------------------------------------------------------------------------
	#help about_switch
	#https://powershellexplained.com/2018-01-12-Powershell-switch-statement/#switch-statement
	#Write-Verbose "Answer = $answer"
	switch ($answer) {
		0 { # Y - Yes
			Write-Verbose "Yes ('$answer') option selected."
			$ChoiceSkipSection = 'Y'
		}
		1 { # N - No
			Write-Verbose "No ('$answer') option selected."
			$ChoiceSkipSection = 'N'
		}
	}
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	Return $ChoiceSkipSection

} # End PromptForChoice-YesNoSectionSkip function ----------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
Function PromptForChoice-YesNo { #--------------------------------------------------------------------------------------
	
	Param (
		#Script parameters go here
		[Parameter(Mandatory=$true,Position=0,
		ValueFromPipeline = $true)]
		[string]$TitleName,
		
		[Parameter(Mandatory=$false)]
		[string]$InfoDescription,
		
		[Parameter(Mandatory=$false)]
		[string]$HintPhrase
	)
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	#-----------------------------------------------------------------------------------------------------------------------
	# Build Choice Prompt
	#-----------------------------------------------------------------------------------------------------------------------
	$Title = "$TitleName?"
	$Info = "$InfoDescription"
	$ChoiceYes = New-Object System.Management.Automation.Host.ChoiceDescription "&Yes", "[Y]es, $HintPhrase."
	$ChoiceNo = New-Object System.Management.Automation.Host.ChoiceDescription "&No", "[N]o, do not $HintPhrase."
	$Options = [System.Management.Automation.Host.ChoiceDescription[]]($ChoiceYes, $ChoiceNo)
	# default choice: 0 = first Option, 1 = second option, etc.
	[int]$defaultchoice = 0
	#-----------------------------------------------------------------------------------------------------------------------
	# Execute Choice Prompt
	#-----------------------------------------------------------------------------------------------------------------------
	# PromptForChoice() output will always be integer: https://powershell.org/forums/topic/question-regarding-result-host-ui-promptforchoice/
	If ($InfoDescription) {
		$answer = $host.UI.PromptForChoice($Title, $Info, $Options, $defaultchoice)
	} else {
		$answer = $host.UI.PromptForChoice($Title, "", $Options, $defaultchoice)
	}
	#-----------------------------------------------------------------------------------------------------------------------
	# Interpret answer
	#-----------------------------------------------------------------------------------------------------------------------
	#help about_switch
	#https://powershellexplained.com/2018-01-12-Powershell-switch-statement/#switch-statement
	#Write-Verbose "Answer = $answer"
	switch ($answer) {
		0 { # Y - Yes
			Write-Verbose "Yes ('$answer') option selected."
			$ChoiceResultVar = 'Y'
		}
		1 { # N - No
			Write-Verbose "No ('$answer') option selected."
			$ChoiceResultVar = 'N'
		}
	}
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	Return $ChoiceResultVar

} # End PromptForChoice-YesNo function ---------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
Function PromptForChoice-DayDate { #------------------------------------------------------------------------------------
	
	<#
	.LINK
	https://ss64.com/ps/syntax-dateformats.html
	#>
	
	Param (
		#Script parameters go here
		[Parameter(Mandatory=$false,Position=0,
		ValueFromPipeline = $true)]
		[string]$TitleName,
		
		[Parameter(Mandatory=$false)]
		[string]$InfoDescription,
		
		[Parameter(Mandatory=$false)]
		[string]$HintPhrase
	)
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	#$VerbosePreference = "SilentlyContinue" # Will suppress Write-Verbose messages. This is the default value.
	$VerbosePreference = "Continue" # Will print out Write-Verbose messages. Gets set when -Verbose switch is used to run the script. (Or when you set the variable manually.)
	
	#-----------------------------------------------------------------------------------------------------------------------
	
	# Collect date variables
	
	#https://ss64.com/ps/syntax-dateformats.html
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	# Today:
	
	$TodayDoWLong = Get-Date -UFormat %A
	Write-Verbose "`$TodayDoWLong = $TodayDoWLong"
	
	# Month/Day (MM/DD)
	$TodayMonthDay = Get-Date -Format 'm, M'
	Write-Verbose "`$TodayMonthDay = $TodayMonthDay"
	
	# Month/Day (MM/DD)
	$TodayMonthDay = Get-Date -UFormat %m/%d
	Write-Verbose "`$TodayMonthDay = $TodayMonthDay"
	
	# Day/Month (DD/MM)
	$TodayDayMonth = Get-Date -UFormat %d/%m
	Write-Verbose "`$TodayDayMonth = $TodayDayMonth"
	
    # Month name - abbreviated (Jan)
	<#
	01 - Jan
	02 - Feb
	03 - Mar
	04 - Apr
	05 - May
	06 - Jun
	07 - Jul
	08 - Aug
	09 - Sep
	10 - Oct
	11 - Nov
	12 - Dec
	#>
    $TodayMonthShort = Get-Date -UFormat %b
	Write-Verbose "`$TodayMonthShort - $TodayMonthShort"
	    
    # Month name - full (January)
	$TodayMonthFull = Get-Date -UFormat %B
	Write-Verbose "`$TodayMonthFull = $TodayMonthFull"
	
	# Week of the Year (00-52)
	$TodayWeekOfYearZero = Get-Date -UFormat %W
	Write-Verbose "`$TodayWeekOfYearZero (00-52) = $TodayWeekOfYearZero"
    
	# Week of the Year (01-53)
	$TodayWeekOfYear = Get-Date -UFormat %V
	Write-Verbose "`$TodayWeekOfYear (01-53) = $TodayWeekOfYear"
	
	Write-HR -IsVerbose -DashedLine
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	# Yesterday:
	
	$TodayDateTime = Get-Date
	
	$YesterdayDateTime = $TodayDateTime.AddDays(-1)
	Write-Verbose "`$YesterdayDateTime = $YesterdayDateTime"
	
	$YesterdayDateTime = (Get-Date).AddDays(-1)
	Write-Verbose "`$YesterdayDateTime = $YesterdayDateTime"
	
	$YesterdayDoW = Get-Date -Date $YesterdayDateTime -UFormat %A
	Write-Verbose "`$YesterdayDoW = $YesterdayDoW"
	
	$YesterdayMonthDay = Get-Date -Date $YesterdayDateTime -UFormat %m/%d
	Write-Verbose "`$YesterdayMonthDay = $YesterdayMonthDay"
	
	$YesterdayDayMonth = Get-Date -Date $YesterdayDateTime -UFormat %d/%m
	Write-Verbose "`$YesterdayDayMonth = $YesterdayDayMonth"
	
	Write-HR -IsVerbose -DashedLine
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	# Get earlier Days of Week
	
	Write-Verbose "Today:"
	
	$TodayDoWLong = Get-Date -UFormat %A
	Write-Verbose "`$TodayDoWLong = $TodayDoWLong"
	
	# Day-of-Week in 3 characters:
	<#
	Sun
	Mon
	Tue
	Wed
	Thu
	Fri
	Sat
	Sun
	#>
	$TodayDoWShort = Get-Date -UFormat %a
	Write-Verbose "`$TodayDoWShort = $TodayDoWShort"
	
	# Day-of-Week in number format, (Sun-Sat = 0-6):
	<#
	0 = Sunday
	1 = Monday
	2 = Tuesday
	3 = Wednesday
	4 = Thursday
	5 = Friday
	6 = Saturday
	#>
	$TodayDoWNumber = Get-Date -UFormat %u
	Write-Verbose "`$TodayDoWNumber = $TodayDoWNumber"
	
	# Day-of-Week in number format, (Mon-Sun = 1-7):
	<#
	1 = Monday
	2 = Tuesday
	3 = Wednesday
	4 = Thursday
	5 = Friday
	6 = Saturday
	7 = Sunday
	#>
	$TodayDoWNumberOneThruSeven = Get-Date -UFormat %u
	If ([int]$TodayDoWNumberOneThruSeven -eq 0) {$TodayDoWNumberOneThruSeven = 7}
	Write-Verbose "`$TodayDoWNumberOneThruSeven = $TodayDoWNumberOneThruSeven"
	
	Write-HR -IsVerbose -DashedLine
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	# Test all Day-of-Week output
	
	Write-Verbose "Start of Loop."
	
	Write-HR -IsVerbose
	
	$CurrentDateTime = Get-Date
	
	For ($i=1; $i -le 7; $i++) {
	
	$DoWLong = Get-Date -Date $CurrentDateTime -UFormat %A
	Write-Verbose "`$DoWLong = $DoWLong"
	
	# Day-of-Week in 3 characters::
	<#
	Sun
	Mon
	Tue
	Wed
	Thu
	Fri
	Sat
	Sun
	#>
	$DoWShort = Get-Date -Date $CurrentDateTime -UFormat %a
	Write-Verbose "`$DoWShort = $DoWShort"
	
	# Day-of-Week in number format, (Sun-Sat = 0-6):
	<#
	0 = Sunday
	1 = Monday
	2 = Tuesday
	3 = Wednesday
	4 = Thursday
	5 = Friday
	6 = Saturday
	#>
	$DoWNumber = Get-Date -Date $CurrentDateTime -UFormat %u
	Write-Verbose "`$DoWNumber = $DoWNumber"
	
	# Day-of-Week in number format, (Mon-Sun = 1-7):
	<#
	1 = Monday
	2 = Tuesday
	3 = Wednesday
	4 = Thursday
	5 = Friday
	6 = Saturday
	7 = Sunday
	#>
	$DoWNumberOneThruSeven = Get-Date -Date $CurrentDateTime -UFormat %u
	If ([int]$DoWNumberOneThruSeven -eq 0) {$DoWNumberOneThruSeven = 7}
	Write-Verbose "`$DoWNumberOneThruSeven = $DoWNumberOneThruSeven"
	
	$CurrentDateTime = $CurrentDateTime.AddDays(-1)
	
	Write-HR -IsVerbose
	
	}
	Write-Verbose "End of Loop."
	
	Write-HR -IsVerbose -DashedLine
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	# Fill in earlier days of the week.
	
	# 'Today' and 'Yesterday' will be constant. But we'll fill in every day earlier as an option, up to Monday. So starting at Wednesday and later, we'll calculate those values. And to do that we'll need the Day-of-Week as an integer value for Monday through Sunday.
	
	# Day-of-Week in number format, (Mon-Sun = 1-7):
	<#
	1 = Monday
	2 = Tuesday
	3 = Wednesday
	4 = Thursday
	5 = Friday
	6 = Saturday
	7 = Sunday
	#>
	$TodayDoWNumberOneThruSeven = Get-Date -UFormat %u
	If ([int]$TodayDoWNumberOneThruSeven -eq 0) {$TodayDoWNumberOneThruSeven = 7}
	Write-Verbose "`$TodayDoWNumberOneThruSeven = $TodayDoWNumberOneThruSeven"
	
	
	
	$TodayDateTime = Get-Date
	
	$YesterdayDateTime = $TodayDateTime.AddDays(-1)
	
	<#
	1 = Monday		
	2 = Tuesday		
	3 = Wednesday	-2 = 1 Monday
	4 = Thursday	-3 = 1 Monday, -2 = Tuesday
	5 = Friday		-4 = 1 Monday, -3 = Tuesday, -2 = Wednesday
	6 = Saturday	-5 = 1 Monday, -4 = Tuesday, -3 = Wednesday, -2 = Thursday
	7 = Sunday		-6 = 1 Monday, -5 = Tuesday, -4 = Wednesday, -3 = Thursday, -2 = Friday
	#>
	
	<#
	1 = Monday		
	2 = Tuesday		
	3 = Wednesday	DayOptionOne = -2 = 1 Monday
	4 = Thursday	DayOptionTwo = -3 = 1 Monday, -2 = Tuesday
	5 = Friday		DayOptionThree = -4 = 1 Monday, -3 = Tuesday, -2 = Wednesday
	6 = Saturday	DayOptionFour = -5 = 1 Monday, -4 = Tuesday, -3 = Wednesday, -2 = Thursday
	7 = Sunday		DayOptionFive = -6 = 1 Monday, -5 = Tuesday, -4 = Wednesday, -3 = Thursday, -2 = Friday
	#>
	
	
	Write-Verbose "`$TodayDoWNumberOneThruSeven = $TodayDoWNumberOneThruSeven"
	
	If ([int]$TodayDoWNumberOneThruSeven -ge 3) {
		
		$RollingInt = [int]$TodayDoWNumberOneThruSeven - 2
		Write-Verbose "`$RollingInt = $RollingInt"
		$DaysBefore = -2
		Write-Verbose "`$DaysBefore = $DaysBefore"
		$DayOptionFive = (Get-Date).AddDays($DaysBefore) # Two days before
		Write-Verbose "`$DayOptionFive = $DayOptionFive"
		$DayOptionFive = $TodayDateTime.AddDays($DaysBefore) # Two days before
		Write-Verbose "`$DayOptionFive = $DayOptionFive"
		Write-Verbose "`$DayOptionFive = $(Get-Date -Date $DayOptionFive -UFormat %A)"
		
		$RollingInt = $RollingInt - 1
		Write-Verbose "`$RollingInt = $RollingInt"
		$DaysBefore = $DaysBefore - 1
		Write-Verbose "`$DaysBefore = $DaysBefore"
		$DayOptionFour = $TodayDateTime.AddDays($DaysBefore)
		Write-Verbose "`$DayOptionFour = $DayOptionFour"
		Write-Verbose "`$DayOptionFour = $(Get-Date -Date $DayOptionFour -UFormat %A)"
		
		$RollingInt = $RollingInt - 1
		Write-Verbose "`$RollingInt = $RollingInt"
		$DaysBefore = $DaysBefore - 1
		Write-Verbose "`$DaysBefore = $DaysBefore"
		$DayOptionThree = $TodayDateTime.AddDays($DaysBefore)
		Write-Verbose "`$DayOptionThree = $DayOptionThree"
		Write-Verbose "`$DayOptionThree = $(Get-Date -Date $DayOptionThree -UFormat %A)"
		
		$RollingInt = $RollingInt - 1
		Write-Verbose "`$RollingInt = $RollingInt"
		$DaysBefore = $DaysBefore - 1
		Write-Verbose "`$DaysBefore = $DaysBefore"
		$DayOptionTwo = $TodayDateTime.AddDays($DaysBefore)
		Write-Verbose "`$DayOptionTwo = $DayOptionTwo"
		Write-Verbose "`$DayOptionTwo = $(Get-Date -Date $DayOptionTwo -UFormat %A)"
		
		$RollingInt = $RollingInt - 1
		Write-Verbose "`$RollingInt = $RollingInt"
		$DaysBefore = $DaysBefore - 1
		Write-Verbose "`$DaysBefore = $DaysBefore"
		$DayOptionOne = $TodayDateTime.AddDays($DaysBefore)
		Write-Verbose "`$DayOptionOne = $DayOptionOne"
		Write-Verbose "`$DayOptionOne = $(Get-Date -Date $DayOptionOne -UFormat %A)"
		
		
		
		
		
	}
	
	
	
	Write-Verbose "`$TodayDoWNumberOneThruSeven = $TodayDoWNumberOneThruSeven"
	
	If ([int]$TodayDoWNumberOneThruSeven -ge 3) {
		
		$RollingInt = [int]$TodayDoWNumberOneThruSeven - 2
		Write-Verbose "`$RollingInt = $RollingInt"
		$DaysBefore = -2
		Write-Verbose "`$DaysBefore = $DaysBefore"
		$DayOptionFive = (Get-Date).AddDays($DaysBefore) # Two days before
		Write-Verbose "`$DayOptionFive = $DayOptionFive"
		$DayOptionFive = $TodayDateTime.AddDays($DaysBefore) # Two days before
		Write-Verbose "`$DayOptionFive = $DayOptionFive"
		Write-Verbose "`$DayOptionFive = $(Get-Date -Date $DayOptionFive -UFormat %A)"
		$DayOptionFiveDate = $DayOptionFive.Date
		Write-Verbose "`$DayOptionFive = $($DayOptionFive.Date)"
		Write-Verbose "`$DayOptionFive = $DayOptionFiveDate"
		Write-Verbose "`$DayOptionFive = $(Get-Date -Date $DayOptionFive)"
		
		
		$RollingInt = $RollingInt - 1
		Write-Verbose "`$RollingInt = $RollingInt"
		$DaysBefore = $DaysBefore - 1
		Write-Verbose "`$DaysBefore = $DaysBefore"
		$DayOptionFour = $TodayDateTime.AddDays($DaysBefore)
		Write-Verbose "`$DayOptionFour = $DayOptionFour"
		Write-Verbose "`$DayOptionFour = $(Get-Date -Date $DayOptionFour -UFormat %A)"
		
		$RollingInt = $RollingInt - 1
		Write-Verbose "`$RollingInt = $RollingInt"
		$DaysBefore = $DaysBefore - 1
		Write-Verbose "`$DaysBefore = $DaysBefore"
		$DayOptionThree = $TodayDateTime.AddDays($DaysBefore)
		Write-Verbose "`$DayOptionThree = $DayOptionThree"
		Write-Verbose "`$DayOptionThree = $(Get-Date -Date $DayOptionThree -UFormat %A)"
		
		$RollingInt = $RollingInt - 1
		Write-Verbose "`$RollingInt = $RollingInt"
		$DaysBefore = $DaysBefore - 1
		Write-Verbose "`$DaysBefore = $DaysBefore"
		$DayOptionTwo = $TodayDateTime.AddDays($DaysBefore)
		Write-Verbose "`$DayOptionTwo = $DayOptionTwo"
		Write-Verbose "`$DayOptionTwo = $(Get-Date -Date $DayOptionTwo -UFormat %A)"
		
		$RollingInt = $RollingInt - 1
		Write-Verbose "`$RollingInt = $RollingInt"
		$DaysBefore = $DaysBefore - 1
		Write-Verbose "`$DaysBefore = $DaysBefore"
		$DayOptionOne = $TodayDateTime.AddDays($DaysBefore)
		Write-Verbose "`$DayOptionOne = $DayOptionOne"
		Write-Verbose "`$DayOptionOne = $(Get-Date -Date $DayOptionOne -UFormat %A)"
		
		
		
		
		
	}
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	# Test past dates
	
	Write-HR -DashedLine
	
	Write-Host "`Test past dates"
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	Write-Verbose "Start of Loop."
	
	$VerbosePreferenceOrig = $VerbosePreference
	$VerbosePreference = 'SilentlyContinue'
	
	Write-HR -IsVerbose
	
	$CurrentDateTime = Get-Date
	$LastWeekOfYear = ""
	#$LastMonthFull = ""
	$LastMonthFull = $TodayMonthFull
	
	# Week of the Year (00-52)
	$TodayWeekOfYearZero = Get-Date -UFormat %W
	Write-Verbose "`$TodayWeekOfYearZero (00-52) = $TodayWeekOfYearZero"
    
	# Week of the Year (01-53)
	$TodayWeekOfYear = Get-Date -UFormat %V
	Write-Verbose "`$TodayWeekOfYear (01-53) = $TodayWeekOfYear"
	
	$CountLoop = 45
	Write-Verbose "Days to count backwards: $CountLoop"
	
	#-----------------------------------------------------------------------------------------------------------------------
	For ($i=1; $i -le $CountLoop; $i++) {
	    
	    $DoWLong = Get-Date -Date $CurrentDateTime -UFormat %A
	    Write-Verbose "`$DoWLong = $DoWLong"
	    
	    # Day-of-Week in 3 characters::
	    <#
	    Sun
	    Mon
	    Tue
	    Wed
	    Thu
	    Fri
	    Sat
	    Sun
	    #>
	    $DoWShort = Get-Date -Date $CurrentDateTime -UFormat %a
	    Write-Verbose "`$DoWShort = $DoWShort"
    	
	    # Day-of-Week in number format, (Sun-Sat = 0-6):
	    <#
	    0 = Sunday
	    1 = Monday
	    2 = Tuesday
	    3 = Wednesday
	    4 = Thursday
	    5 = Friday
	    6 = Saturday
	    #>
	    $DoWNumber = Get-Date -Date $CurrentDateTime -UFormat %u
	    Write-Verbose "`$DoWNumber = $DoWNumber"
    	
	    # Day-of-Week in number format, (Mon-Sun = 1-7):
	    <#
	    1 = Monday
	    2 = Tuesday
	    3 = Wednesday
	    4 = Thursday
	    5 = Friday
	    6 = Saturday
	    7 = Sunday
	    #>
	    $DoWNumberOneThruSeven = Get-Date -Date $CurrentDateTime -UFormat %u
	    If ([int]$DoWNumberOneThruSeven -eq 0) {$DoWNumberOneThruSeven = 7}
	    Write-Verbose "`$DoWNumberOneThruSeven = $DoWNumberOneThruSeven"
    	
	    # Month/Day (MM/DD)
	    $MonthDay = Get-Date -Date $CurrentDateTime -UFormat %m/%d
	    Write-Verbose "`$MonthDay = $MonthDay"
    	
    	# Day/Month (DD/MM)
	    $DayMonth = Get-Date -Date $CurrentDateTime -UFormat %d/%m
	    Write-Verbose "`$DayMonth = $DayMonth"
    	
        # Month name - abbreviated (Jan)
	    <#
	    01 - Jan
	    02 - Feb
	    03 - Mar
	    04 - Apr
	    05 - May
	    06 - Jun
	    07 - Jul
	    08 - Aug
	    09 - Sep
	    10 - Oct
	    11 - Nov
	    12 - Dec
	    #>
        $MonthShort = Get-Date -Date $CurrentDateTime -UFormat %b
	    Write-Verbose "`$MonthShort - $MonthShort"
    	    
        # Month name - full (January)
	    $MonthFull = Get-Date -Date $CurrentDateTime -UFormat %B
	    Write-Verbose "`$MonthFull = $MonthFull"
    	
	    # Week of the Year (00-52)
	    $WeekOfYearZero = Get-Date -Date $CurrentDateTime -UFormat %W
	    Write-Verbose "`$WeekOfYearZero (00-52) = $WeekOfYearZero"
        
	    # Week of the Year (01-53)
	    $WeekOfYear = Get-Date -Date $CurrentDateTime -UFormat %V
	    Write-Verbose "`$WeekOfYear (01-53) = $WeekOfYear"
    	
	    #- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    	
	    #Test case:
	    If ($i -eq 3) {
		    #$MonthFull = "December"
		    #$MonthShort = "Dec"
	    }
	    
    	
	    If ($WeekOfYear -eq $TodayWeekOfYear) {
		    Write-Verbose "Current week selected"
    		$WeekOfYearDisplayLabel = " - Current week."
	    } Else {
		    $WeekOfYearDisplayLabel = ""
    	}
    	
	    if ($MonthFull -ne $LastMonthFull) {
		    Write-Verbose "Month change detected."
    		$LastMonthFull = $MonthFull
	    	$MonthChangeDisplayLabel = " - Month change."
    	}  Else {
    		$MonthChangeDisplayLabel = ""
	    }
	    
    	if ($WeekOfYear -ne $LastWeekOfYear) {
    		Write-Verbose "New week detected."
	    	Write-Host "New week detected."
    		$LastWeekOfYear = $WeekOfYear
	    }
	    
	    
    	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    	
	    #Write-Host "$MonthDay - $DoWShort - $MonthShort - Week #($WeekOfYear/52)($WeekOfYearDisplayLabel)$($MonthChangeDisplayLabel)"
	    Write-Host "$MonthDay - $DoWShort - ($WeekOfYear/52) - $MonthShort$($WeekOfYearDisplayLabel)$($MonthChangeDisplayLabel)"
	    
    	$CurrentDateTime = $CurrentDateTime.AddDays(-1)
    	
	    Write-HR -IsVerbose
	}
	
	$VerbosePreference = 'Continue'
	$VerbosePreference = $VerbosePreferenceOrig
	Write-Verbose "End of Loop."
	
	#-----------------------------------------------------------------------------------------------------------------------
	
	Write-HR -IsVerbose -DashedLine
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	
	
	$Info = @"
Month: $TodayMonth
Week #$TodayWeekOfYear/53

Select day:

T - Today - $TodayDoWLong ($TodayMonthDay)
Y - Yesterday - $YesterdayDoW ($YesterdayMonthDay)
C - Current Week
N - Next Week

D - Sunday
S - Saturday
F - Friday
H - Thursday
W - Wednesday
U - Tuesday
M - Monday

O - Show/Hide Saturday & Sunday
P - Previous Week
L - Last Week
Q - Quit

Select a choice:
"@
	Write-Host "$Info"
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	Write-HR -IsVerbose -DashedLine
	Write-HR -IsVerbose -DashedLine
	Write-HR -IsVerbose
	Write-HR -IsVerbose
	
	#-----------------------------------------------------------------------------------------------------------------------
	#-----------------------------------------------------------------------------------------------------------------------
	#-----------------------------------------------------------------------------------------------------------------------
	
	# Build week info.
	
	$SelectedWeek = 0
	$PresentWeekSelected = $true
	$TodayDateTime = Get-Date
	$YesterdayDateTime = $TodayDateTime.AddDays(-1)
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	# Build out currently selected week, out until Monday (Mon-Sun week display)
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	# Get how many days we are away from Monday. 
	
	# Since the default output of PowerShell DoW is Sun-Sat = 0-6, we must convert it to our choice of a Monday through Sunday week format, Mon-Sun = 1-7.
	
	# Day-of-Week in number format, (Sun-Sat = 0-6):
	<#
	0 = Sunday
	1 = Monday
	2 = Tuesday
	3 = Wednesday
	4 = Thursday
	5 = Friday
	6 = Saturday
	#>
	$TodayDoWNumber = Get-Date -UFormat %u
	Write-Verbose "`$TodayDoWNumber = $TodayDoWNumber"
	
	# Day-of-Week in number format, (Mon-Sun = 1-7):
	<#
	1 = Monday
	2 = Tuesday
	3 = Wednesday
	4 = Thursday
	5 = Friday
	6 = Saturday
	7 = Sunday
	#>
	$TodayDoWNumberOneThruSeven = Get-Date -UFormat %u
	If ([int]$TodayDoWNumberOneThruSeven -eq 0) {$TodayDoWNumberOneThruSeven = 7}
	Write-Verbose "`$TodayDoWNumberOneThruSeven = $TodayDoWNumberOneThruSeven"
	
	$DaysIntoTheWeek = [int]$TodayDoWNumberOneThruSeven
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	$SelectedDoW = [int]$TodayDoWNumberOneThruSeven
	
	$SelectedDateTime = [datetime]$TodayDateTime
    
    # Get Monday of current week

	# Day-of-Week in number format, (Mon-Sun = 1-7):
	<#
	1 = Monday    - Monday is 1 - 0 = 1
	2 = Tuesday   - Monday is 2 - 1 = 1
	3 = Wednesday - Monday is 3 - 2 = 1
	4 = Thursday  - Monday is 4 - 3 = 1
	5 = Friday    - Monday is 5 - 4 = 1
	6 = Saturday  - Monday is 6 - 5 = 1
	7 = Sunday    - Monday is 7 - 6 = 1
	#>
    
    
    # Get Sunday of current week

	# Day-of-Week in number format, (Mon-Sun = 1-7):
	<#
	1 = Monday    - Sunday is 1 + 6 = 7
	2 = Tuesday   - Sunday is 2 + 5 = 7
	3 = Wednesday - Sunday is 3 + 4 = 7
	4 = Thursday  - Sunday is 4 + 3 = 7
	5 = Friday    - Sunday is 5 + 2 = 7
	6 = Saturday  - Sunday is 6 + 1 = 7
	7 = Sunday    - Sunday is 7 + 0 = 7
	#>

    
    
	
	If ($SelectedWeek -eq 0) {
		$SelectedDoW = [int]$TodayDoWNumberOneThruSeven
		$SelectedDateTime = [datetime]$TodayDateTime
        
	} Else {
		If ($SelectedWeek -lt 0) {
			$SelectedWeekPos = $SelectedWeek * -1
		} Else {
			$SelectedWeekPos = $SelectedWeek
		}
		
		$DaysToCountBackward = ([int]$TodayDoWNumberOneThruSeven)
		Write-Verbose "`$DaysToCountBackward = $DaysToCountBackward"
		
		If ($SelectedWeekPos -gt 1) {
			$DaysToCountBackward = $DaysToCountBackward + (($SelectedWeekPos - 1) * 7)
			Write-Verbose "`$DaysToCountBackward = $DaysToCountBackward"
		}
		
		$DaysToCountBackward = $DaysToCountBackward * -1
		Write-Verbose "`$DaysToCountBackward = $DaysToCountBackward"
		
		$SelectedDateTime = $TodayDateTime.AddDays($DaysToCountBackward)
		
		$SelectedDoW = 7
		
	}

	# Week of the Year (00-52)
	$WeekOfYearZero = Get-Date -Date $CurrentDateTime -UFormat %W
	Write-Verbose "`$WeekOfYearZero (00-52) = $WeekOfYearZero"
       
	# Week of the Year (01-53)
	$WeekOfYear = Get-Date -Date $CurrentDateTime -UFormat %V
	Write-Verbose "`$WeekOfYear (01-53) = $WeekOfYear"
    

	Do {
		
		If ($SelectedDateTime -eq $TodayDateTime) {
			$TodayLabel = " (Today)"
		} Else {
			$TodayLabel = ""
		}
		
		If ($SelectedDateTime -eq $YesterdayDateTime) {
			$YesterdayLabel = " (Yesterday)"
		} Else {
			$YesterdayLabel = ""
		}
        
		
		If ($SelectedDoW -eq 7) { # Sunday
			$Sunday = $SelectedDateTime
			Write-Verbose "Sunday = $Sunday$($TodayLabel)$($YesterdayLabel)"
            $EndOfWeekMonthLong = Get-Date -Date $SelectedDateTime -UFormat %B
            $EndOfWeekMonthShort = Get-Date -Date $SelectedDateTime -UFormat %b
		}
		
		If ($SelectedDoW -eq 6) { # Saturday
			$Saturday = $SelectedDateTime
			Write-Verbose "Saturday = $Saturday$($TodayLabel)$($YesterdayLabel)"
		}
		
		If ($SelectedDoW -eq 5) { # Friday
			$Friday = $SelectedDateTime
			Write-Verbose "Friday = $Friday$($TodayLabel)$($YesterdayLabel)"
		}
		
		If ($SelectedDoW -eq 4) { # Thursday
			$Thursday = $SelectedDateTime
			Write-Verbose "Thursday = $Thursday$($TodayLabel)$($YesterdayLabel)"
		}
		
		If ($SelectedDoW -eq 3) { # Wednesday
			$Wednesday = $SelectedDateTime
			Write-Verbose "Wednesday = $Wednesday$($TodayLabel)$($YesterdayLabel)"
		}
		
		If ($SelectedDoW -eq 2) { # Tuesday
			$Tuesday = $SelectedDateTime
			Write-Verbose "Tuesday = $Tuesday$($TodayLabel)$($YesterdayLabel)"
		}
		
		If ($SelectedDoW -eq 1) { # Monday
			$Monday = $SelectedDateTime
			Write-Verbose "Monday = $Monday$($TodayLabel)$($YesterdayLabel)"
            $StartOfWeekMonthLong = Get-Date -Date $SelectedDateTime -UFormat %B
            $StartOfWeekMonthShort = Get-Date -Date $SelectedDateTime -UFormat %b
		}
		
		$SelectedDoW = $SelectedDoW - 1
		$SelectedDateTime = ($SelectedDateTime).AddDays(-1)
		
	} until ($SelectedDoW -lt 1)
    
    If ($StartOfWeekMonthLong -ne $EndOfWeekMonthLong) {
        Write-Host "Month: $StartOfWeekMonthShort-$EndOfWeekMonthShort"
    } Else {
        Write-Host "Month: $StartOfWeekMonthLong"
    }
    
	
	Write-HR -IsVerbose -DashedLine
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
    $SelectedWeek = -1
	
	If ($SelectedWeek -eq 0) {
		$SelectedDoW = [int]$TodayDoWNumberOneThruSeven
		$SelectedDateTime = [datetime]$TodayDateTime
	} Else {
		If ($SelectedWeek -lt 0) {
			$SelectedWeekPos = $SelectedWeek * -1
		} Else {
			$SelectedWeekPos = $SelectedWeek
		}
		
		$DaysToCountBackward = ([int]$TodayDoWNumberOneThruSeven)
		Write-Verbose "`$DaysToCountBackward = $DaysToCountBackward"
		
		If ($SelectedWeekPos -gt 1) {
			$DaysToCountBackward = $DaysToCountBackward + (($SelectedWeekPos - 1) * 7)
			Write-Verbose "`$DaysToCountBackward = $DaysToCountBackward"
		}
		
		$DaysToCountBackward = $DaysToCountBackward * -1
		Write-Verbose "`$DaysToCountBackward = $DaysToCountBackward"
		
		$SelectedDateTime = $TodayDateTime.AddDays($DaysToCountBackward)
		
		$SelectedDoW = 7
		
	}
	
	Do {
		
		If ($SelectedDateTime -eq $TodayDateTime) {
			$TodayLabel = " (Today)"
		} Else {
			$TodayLabel = ""
		}
		
		If ($SelectedDateTime -eq $YesterdayDateTime) {
			$YesterdayLabel = " (Yesterday)"
		} Else {
			$YesterdayLabel = ""
		}
		
		If ($SelectedDoW -eq 7) { # Sunday
			$Sunday = $SelectedDateTime
			Write-Verbose "Sunday = $Sunday$($TodayLabel)$($YesterdayLabel)"
		}
		
		If ($SelectedDoW -eq 6) { # Saturday
			$Saturday = $SelectedDateTime
			Write-Verbose "Saturday = $Saturday$($TodayLabel)$($YesterdayLabel)"
		}
		
		If ($SelectedDoW -eq 5) { # Friday
			$Friday = $SelectedDateTime
			Write-Verbose "Friday = $Friday$($TodayLabel)$($YesterdayLabel)"
		}
		
		If ($SelectedDoW -eq 4) { # Thursday
			$Thursday = $SelectedDateTime
			Write-Verbose "Thursday = $Thursday$($TodayLabel)$($YesterdayLabel)"
		}
		
		If ($SelectedDoW -eq 3) { # Wednesday
			$Wednesday = $SelectedDateTime
			Write-Verbose "Wednesday = $Wednesday$($TodayLabel)$($YesterdayLabel)"
		}
		
		If ($SelectedDoW -eq 2) { # Tuesday
			$Tuesday = $SelectedDateTime
			Write-Verbose "Tuesday = $Tuesday$($TodayLabel)$($YesterdayLabel)"
		}
		
		If ($SelectedDoW -eq 1) { # Monday
			$Monday = $SelectedDateTime
			Write-Verbose "Monday = $Monday$($TodayLabel)$($YesterdayLabel)"
		}
		
		$SelectedDoW = $SelectedDoW - 1
		$SelectedDateTime = ($SelectedDateTime).AddDays(-1)
		
	} until ($SelectedDoW -lt 1)
	
	Write-HR -IsVerbose -DashedLine
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
    $SelectedWeek = -2
	
	If ($SelectedWeek -eq 0) {
		$SelectedDoW = [int]$TodayDoWNumberOneThruSeven
		$SelectedDateTime = [datetime]$TodayDateTime
	} Else {
		If ($SelectedWeek -lt 0) {
			$SelectedWeekPos = $SelectedWeek * -1
		} Else {
			$SelectedWeekPos = $SelectedWeek
		}
		
		$DaysToCountBackward = ([int]$TodayDoWNumberOneThruSeven)
		Write-Verbose "`$DaysToCountBackward = $DaysToCountBackward"
		
		If ($SelectedWeekPos -gt 1) {
			$DaysToCountBackward = $DaysToCountBackward + (($SelectedWeekPos - 1) * 7)
			Write-Verbose "`$DaysToCountBackward = $DaysToCountBackward"
		}
		
		$DaysToCountBackward = $DaysToCountBackward * -1
		Write-Verbose "`$DaysToCountBackward = $DaysToCountBackward"
		
		$SelectedDateTime = $TodayDateTime.AddDays($DaysToCountBackward)
		
		$SelectedDoW = 7
		
	}
	
    
	Do {
		
		If ($SelectedDateTime -eq $TodayDateTime) {
			$TodayLabel = " (Today)"
		} Else {
			$TodayLabel = ""
		}
		
		If ($SelectedDateTime -eq $YesterdayDateTime) {
			$YesterdayLabel = " (Yesterday)"
		} Else {
			$YesterdayLabel = ""
		}
		
		If ($SelectedDoW -eq 7) { # Sunday
			$Sunday = $SelectedDateTime
			Write-Verbose "Sunday = $Sunday$($TodayLabel)$($YesterdayLabel)"
		}
		
		If ($SelectedDoW -eq 6) { # Saturday
			$Saturday = $SelectedDateTime
			Write-Verbose "Saturday = $Saturday$($TodayLabel)$($YesterdayLabel)"
		}
		
		If ($SelectedDoW -eq 5) { # Friday
			$Friday = $SelectedDateTime
			Write-Verbose "Friday = $Friday$($TodayLabel)$($YesterdayLabel)"
		}
		
		If ($SelectedDoW -eq 4) { # Thursday
			$Thursday = $SelectedDateTime
			Write-Verbose "Thursday = $Thursday$($TodayLabel)$($YesterdayLabel)"
		}
		
		If ($SelectedDoW -eq 3) { # Wednesday
			$Wednesday = $SelectedDateTime
			Write-Verbose "Wednesday = $Wednesday$($TodayLabel)$($YesterdayLabel)"
		}
		
		If ($SelectedDoW -eq 2) { # Tuesday
			$Tuesday = $SelectedDateTime
			Write-Verbose "Tuesday = $Tuesday$($TodayLabel)$($YesterdayLabel)"
		}
		
		If ($SelectedDoW -eq 1) { # Monday
			$Monday = $SelectedDateTime
			Write-Verbose "Monday = $Monday$($TodayLabel)$($YesterdayLabel)"
		}
		
		$SelectedDoW = $SelectedDoW - 1
		$SelectedDateTime = ($SelectedDateTime).AddDays(-1)
		
	} until ($SelectedDoW -lt 1)
	
	Write-HR -IsVerbose -DashedLine
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
    $SelectedWeek = -3
	
	If ($SelectedWeek -eq 0) {
		$SelectedDoW = [int]$TodayDoWNumberOneThruSeven
		$SelectedDateTime = [datetime]$TodayDateTime
	} Else {
		If ($SelectedWeek -lt 0) {
			$SelectedWeekPos = $SelectedWeek * -1
		} Else {
			$SelectedWeekPos = $SelectedWeek
		}
		
		$DaysToCountBackward = ([int]$TodayDoWNumberOneThruSeven)
		Write-Verbose "`$DaysToCountBackward = $DaysToCountBackward"
		
		If ($SelectedWeekPos -gt 1) {
			$DaysToCountBackward = $DaysToCountBackward + (($SelectedWeekPos - 1) * 7)
			Write-Verbose "`$DaysToCountBackward = $DaysToCountBackward"
		}
		
		$DaysToCountBackward = $DaysToCountBackward * -1
		Write-Verbose "`$DaysToCountBackward = $DaysToCountBackward"
		
		$SelectedDateTime = $TodayDateTime.AddDays($DaysToCountBackward)
		
		$SelectedDoW = 7
		
	}
	
    
	Do {
		
		If ($SelectedDateTime -eq $TodayDateTime) {
			$TodayLabel = " (Today)"
		} Else {
			$TodayLabel = ""
		}
		
		If ($SelectedDateTime -eq $YesterdayDateTime) {
			$YesterdayLabel = " (Yesterday)"
		} Else {
			$YesterdayLabel = ""
		}
		
		If ($SelectedDoW -eq 7) { # Sunday
			$Sunday = $SelectedDateTime
			Write-Verbose "Sunday = $Sunday$($TodayLabel)$($YesterdayLabel)"
		}
		
		If ($SelectedDoW -eq 6) { # Saturday
			$Saturday = $SelectedDateTime
			Write-Verbose "Saturday = $Saturday$($TodayLabel)$($YesterdayLabel)"
		}
		
		If ($SelectedDoW -eq 5) { # Friday
			$Friday = $SelectedDateTime
			Write-Verbose "Friday = $Friday$($TodayLabel)$($YesterdayLabel)"
		}
		
		If ($SelectedDoW -eq 4) { # Thursday
			$Thursday = $SelectedDateTime
			Write-Verbose "Thursday = $Thursday$($TodayLabel)$($YesterdayLabel)"
		}
		
		If ($SelectedDoW -eq 3) { # Wednesday
			$Wednesday = $SelectedDateTime
			Write-Verbose "Wednesday = $Wednesday$($TodayLabel)$($YesterdayLabel)"
		}
		
		If ($SelectedDoW -eq 2) { # Tuesday
			$Tuesday = $SelectedDateTime
			Write-Verbose "Tuesday = $Tuesday$($TodayLabel)$($YesterdayLabel)"
		}
		
		If ($SelectedDoW -eq 1) { # Monday
			$Monday = $SelectedDateTime
			Write-Verbose "Monday = $Monday$($TodayLabel)$($YesterdayLabel)"
		}
		
		$SelectedDoW = $SelectedDoW - 1
		$SelectedDateTime = ($SelectedDateTime).AddDays(-1)
		
	} until ($SelectedDoW -lt 1)
	
	Write-HR -IsVerbose -DashedLine
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	$YesterdayDateTime = $TodayDateTime.AddDays(-1)
	
	<#
	1 = Monday		
	2 = Tuesday		
	3 = Wednesday	-2 = 1 Monday
	4 = Thursday	-3 = 1 Monday, -2 = Tuesday
	5 = Friday		-4 = 1 Monday, -3 = Tuesday, -2 = Wednesday
	6 = Saturday	-5 = 1 Monday, -4 = Tuesday, -3 = Wednesday, -2 = Thursday
	7 = Sunday		-6 = 1 Monday, -5 = Tuesday, -4 = Wednesday, -3 = Thursday, -2 = Friday
	#>
	
	<#
	1 = Monday		
	2 = Tuesday		
	3 = Wednesday	DayOptionOne = -2 = 1 Monday
	4 = Thursday	DayOptionTwo = -3 = 1 Monday, -2 = Tuesday
	5 = Friday		DayOptionThree = -4 = 1 Monday, -3 = Tuesday, -2 = Wednesday
	6 = Saturday	DayOptionFour = -5 = 1 Monday, -4 = Tuesday, -3 = Wednesday, -2 = Thursday
	7 = Sunday		DayOptionFive = -6 = 1 Monday, -5 = Tuesday, -4 = Wednesday, -3 = Thursday, -2 = Friday
	#>
	
	Write-Verbose "`$TodayDoWNumberOneThruSeven = $TodayDoWNumberOneThruSeven"
	
	If ([int]$TodayDoWNumberOneThruSeven -ge 3) {
		
		$RollingInt = [int]$TodayDoWNumberOneThruSeven - 2
		Write-Verbose "`$RollingInt = $RollingInt"
		$DaysBefore = -2
		Write-Verbose "`$DaysBefore = $DaysBefore"
		$DayOptionFive = (Get-Date).AddDays($DaysBefore) # Two days before
		Write-Verbose "`$DayOptionFive = $DayOptionFive"
		$DayOptionFive = $TodayDateTime.AddDays($DaysBefore) # Two days before
		Write-Verbose "`$DayOptionFive = $DayOptionFive"
		Write-Verbose "`$DayOptionFive = $(Get-Date -Date $DayOptionFive -UFormat %A)"
		
		$RollingInt = $RollingInt - 1
		Write-Verbose "`$RollingInt = $RollingInt"
		$DaysBefore = $DaysBefore - 1
		Write-Verbose "`$DaysBefore = $DaysBefore"
		$DayOptionFour = $TodayDateTime.AddDays($DaysBefore)
		Write-Verbose "`$DayOptionFour = $DayOptionFour"
		Write-Verbose "`$DayOptionFour = $(Get-Date -Date $DayOptionFour -UFormat %A)"
		
		$RollingInt = $RollingInt - 1
		Write-Verbose "`$RollingInt = $RollingInt"
		$DaysBefore = $DaysBefore - 1
		Write-Verbose "`$DaysBefore = $DaysBefore"
		$DayOptionThree = $TodayDateTime.AddDays($DaysBefore)
		Write-Verbose "`$DayOptionThree = $DayOptionThree"
		Write-Verbose "`$DayOptionThree = $(Get-Date -Date $DayOptionThree -UFormat %A)"
		
		$RollingInt = $RollingInt - 1
		Write-Verbose "`$RollingInt = $RollingInt"
		$DaysBefore = $DaysBefore - 1
		Write-Verbose "`$DaysBefore = $DaysBefore"
		$DayOptionTwo = $TodayDateTime.AddDays($DaysBefore)
		Write-Verbose "`$DayOptionTwo = $DayOptionTwo"
		Write-Verbose "`$DayOptionTwo = $(Get-Date -Date $DayOptionTwo -UFormat %A)"
		
		$RollingInt = $RollingInt - 1
		Write-Verbose "`$RollingInt = $RollingInt"
		$DaysBefore = $DaysBefore - 1
		Write-Verbose "`$DaysBefore = $DaysBefore"
		$DayOptionOne = $TodayDateTime.AddDays($DaysBefore)
		Write-Verbose "`$DayOptionOne = $DayOptionOne"
		Write-Verbose "`$DayOptionOne = $(Get-Date -Date $DayOptionOne -UFormat %A)"
		
		
		
		
		
	}
	
	Write-Verbose "`$TodayDoWNumberOneThruSeven = $TodayDoWNumberOneThruSeven"
	
	If ([int]$TodayDoWNumberOneThruSeven -ge 3) {
		
		$RollingInt = [int]$TodayDoWNumberOneThruSeven - 2
		Write-Verbose "`$RollingInt = $RollingInt"
		$DaysBefore = -2
		Write-Verbose "`$DaysBefore = $DaysBefore"
		$DayOptionFive = (Get-Date).AddDays($DaysBefore) # Two days before
		Write-Verbose "`$DayOptionFive = $DayOptionFive"
		$DayOptionFive = $TodayDateTime.AddDays($DaysBefore) # Two days before
		Write-Verbose "`$DayOptionFive = $DayOptionFive"
		Write-Verbose "`$DayOptionFive = $(Get-Date -Date $DayOptionFive -UFormat %A)"
		$DayOptionFiveDate = $DayOptionFive.Date
		Write-Verbose "`$DayOptionFive = $($DayOptionFive.Date)"
		Write-Verbose "`$DayOptionFive = $DayOptionFiveDate"
		Write-Verbose "`$DayOptionFive = $(Get-Date -Date $DayOptionFive)"
		
		
		$RollingInt = $RollingInt - 1
		Write-Verbose "`$RollingInt = $RollingInt"
		$DaysBefore = $DaysBefore - 1
		Write-Verbose "`$DaysBefore = $DaysBefore"
		$DayOptionFour = $TodayDateTime.AddDays($DaysBefore)
		Write-Verbose "`$DayOptionFour = $DayOptionFour"
		Write-Verbose "`$DayOptionFour = $(Get-Date -Date $DayOptionFour -UFormat %A)"
		
		$RollingInt = $RollingInt - 1
		Write-Verbose "`$RollingInt = $RollingInt"
		$DaysBefore = $DaysBefore - 1
		Write-Verbose "`$DaysBefore = $DaysBefore"
		$DayOptionThree = $TodayDateTime.AddDays($DaysBefore)
		Write-Verbose "`$DayOptionThree = $DayOptionThree"
		Write-Verbose "`$DayOptionThree = $(Get-Date -Date $DayOptionThree -UFormat %A)"
		
		$RollingInt = $RollingInt - 1
		Write-Verbose "`$RollingInt = $RollingInt"
		$DaysBefore = $DaysBefore - 1
		Write-Verbose "`$DaysBefore = $DaysBefore"
		$DayOptionTwo = $TodayDateTime.AddDays($DaysBefore)
		Write-Verbose "`$DayOptionTwo = $DayOptionTwo"
		Write-Verbose "`$DayOptionTwo = $(Get-Date -Date $DayOptionTwo -UFormat %A)"
		
		$RollingInt = $RollingInt - 1
		Write-Verbose "`$RollingInt = $RollingInt"
		$DaysBefore = $DaysBefore - 1
		Write-Verbose "`$DaysBefore = $DaysBefore"
		$DayOptionOne = $TodayDateTime.AddDays($DaysBefore)
		Write-Verbose "`$DayOptionOne = $DayOptionOne"
		Write-Verbose "`$DayOptionOne = $(Get-Date -Date $DayOptionOne -UFormat %A)"
		
		
		
		
		
	}
	
	
	
	#-----------------------------------------------------------------------------------------------------------------------
	#-----------------------------------------------------------------------------------------------------------------------
	#-----------------------------------------------------------------------------------------------------------------------
	
	Write-HR -IsVerbose
	Write-HR -IsVerbose
	Write-HR -IsVerbose -DashedLine
	Write-HR -IsVerbose -DashedLine
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	If ([int]$TodayDoWNumberOneThruSeven -ge 3) {
		
		
		
		If ([int]$TodayDoWNumberOneThruSeven -ge 4) {
			If ([int]$TodayDoWNumberOneThruSeven -ge 5) {
				If ([int]$TodayDoWNumberOneThruSeven -ge 6) {
					If ([int]$TodayDoWNumberOneThruSeven -eq 7) {
						# Today is Sunday
						
						
					}
					
				}
				
			}
			
		}
		
		
		
	}
	
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	PAUSE
	
	#-----------------------------------------------------------------------------------------------------------------------
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	#-----------------------------------------------------------------------------------------------------------------------
	# Build Choice Prompt
	#-----------------------------------------------------------------------------------------------------------------------
	$Title = "$TitleName?"
	$Info = "$InfoDescription"
	$Info = @"
Month: $TodayMonth
Week #$TodayWeekOfYear/53

Select day:

T - Today - $TodayDoWLong ($TodayMonthDay)
Y - Yesterday - $YesterdayDoW ($YesterdayMonthDay)
C - Current Week
N - Next Week

D - Sunday
S - Saturday
F - Friday
H - Thursday
W - Wednesday
U - Tuesday
M - Monday

O - Show/Hide Saturday & Sunday
P - Previous Week
L - Last Week
Q - Quit

Select a choice:
"@
	
	$Info = @"
Choose day:

T - Today
Y - Yesterday
"@
	
	$Info += @"
Choose day:

T - Today
Y - Yesterday

F - Friday
H - Thursday
W - Wednesday
U - Tuesday
M - Monday

L - Last Week
Q - Quit

Select a choice:
"@
	
	
	$ChoiceYes = New-Object System.Management.Automation.Host.ChoiceDescription "&Yes", "[Y]es, $HintPhrase."
	$ChoiceNo = New-Object System.Management.Automation.Host.ChoiceDescription "&No", "[N]o, do not $HintPhrase."
	$Options = [System.Management.Automation.Host.ChoiceDescription[]]($ChoiceYes, $ChoiceNo)
	# default choice: 0 = first Option, 1 = second option, etc.
	[int]$defaultchoice = 0
	#-----------------------------------------------------------------------------------------------------------------------
	# Execute Choice Prompt
	#-----------------------------------------------------------------------------------------------------------------------
	# PromptForChoice() output will always be integer: https://powershell.org/forums/topic/question-regarding-result-host-ui-promptforchoice/
	If ($InfoDescription) {
		$answer = $host.UI.PromptForChoice($Title, $Info, $Options, $defaultchoice)
	} else {
		$answer = $host.UI.PromptForChoice($Title, "", $Options, $defaultchoice)
	}
	#-----------------------------------------------------------------------------------------------------------------------
	# Interpret answer
	#-----------------------------------------------------------------------------------------------------------------------
	#help about_switch
	#https://powershellexplained.com/2018-01-12-Powershell-switch-statement/#switch-statement
	#Write-Verbose "Answer = $answer"
	switch ($answer) {
		0 { # Y - Yes
			Write-Verbose "Yes ('$answer') option selected."
			$ChoiceResultVar = 'Y'
		}
		1 { # N - No
			Write-Verbose "No ('$answer') option selected."
			$ChoiceResultVar = 'N'
		}
	}
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	Return $ChoiceResultVar

} # End PromptForChoice-DayDate function -------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
Function ReadPrompt-AMPM24 { #------------------------------------------------------------------------------------------
	
	#http://techgenix.com/powershell-functions-common-parameters/
	# To enable common parameters in functions (-Verbose, -Debug, etc.) the following 2 lines must be present:
	#[cmdletbinding()]
	#Param()
	[cmdletbinding()]
	Param()
	
	do {
		$ChoiceAMPM24hour = Read-Host -Prompt "[A]M, [P]M, or [2]4 hour? [A\P\2]"
		switch ($ChoiceAMPM24hour) {
			'A'	{ # A - AM time
	            $ResultAMPM = "AM"
				Write-Host "AM time ('$ChoiceAMPM24hour') option selected."
				Write-Verbose "AM time ('$ChoiceAMPM24hour') option selected."
				Write-Host `r`n
			}
			'P' { # P - PM time
	            $ResultAMPM = "PM"
				Write-Host "PM time ('$ChoiceAMPM24hour') option selected."
				Write-Verbose "PM time ('$ChoiceAMPM24hour') option selected."
				Write-Host `r`n
			}
			2 { # 2 - 24-hour time
	            $ResultAMPM = "24"
				Write-Host "24-hour time ('$ChoiceAMPM24hour') option selected."
				Write-Verbose "24-hour time ('$ChoiceAMPM24hour') option selected."
				Write-Host `r`n
			}
			default { # Choice not recognized.
	            Write-Host `r`n
				Write-Host "Choice `"$ChoiceAMPM24hour`" not recognized. Options must be AM, PM, or 24-hour:"
				Write-Host "                     [A] = AM"
				Write-Host "                     [P] = PM"
				Write-Host "                     [2] = 24-hour"
				Write-Host `r`n
				#Break #help about_Break
				PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
				Write-Host `r`n
			}
		}
	}
	until ($ChoiceAMPM24hour -eq 'A' -Or $ChoiceAMPM24hour -eq 'P' -Or $ChoiceAMPM24hour -eq 2)
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	Return $ResultAMPM
	
} # End ReadPrompt-AMPM24 function -------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
Function ReadPrompt-Hour { #--------------------------------------------------------------------------------------------
	
	#http://techgenix.com/powershell-functions-common-parameters/
	# To enable common parameters in functions (-Verbose, -Debug, etc.) the following 2 lines must be present:
	#[cmdletbinding()]
	#Param()
	[cmdletbinding()]
	Param(
		[Parameter(Mandatory=$false,Position=0,
		ValueFromPipeline = $true)]
		$VarInput
	)
	
	# Sub-functions:
	#-----------------------------------------------------------------------------------------------------------------------
	function Validate-Integer {
		Param (
			#Script parameters go here
			[Parameter(Mandatory=$true,Position=0,
			ValueFromPipeline = $true)]
			# Validate a positive integer (whole number) using Regular Expressions, thanks to:
			#https://stackoverflow.com/questions/16774064/regular-expression-for-whole-numbers-and-integers
			#-----------------------------------------------------------------------------------------------------------------------
			#	(?<![-.])		# Assert that the previous character isn't a minus sign or a dot.
			#	\b				# Anchor the match to the start of a number.
			#	[0-9]+			# Match a number.
			#	\b				# Anchor the match to the end of the number.
			#	(?!\.[0-9])		# Assert that no decimal part follows.
			#$RegEx = "(?<![-.])\b[0-9]+\b(?!\.[0-9])"
			#[ValidatePattern("(?<![-.])\b[0-9]+\b(?!\.[0-9])")]
			# This [ValidateScript({})] does the exact same thing as the [ValidatePattern("")] above, it just throws much nicer, customizable error messages that actually explain why if failed (rather than "(?<![-.])\b[0-9]+\b(?!\.[0-9])").
			[ValidateScript({
				If ($_ -match "(?<![-.])\b[0-9]+\b(?!\.[0-9])") {
					$True
				} else {
					Throw "$_ must be a positive integer (whole number, no decimals). [ValidateScript({})] error."
				}
			})]
			#-----------------------------------------------------------------------------------------------------------------------
			# Bugfix: For the [ValidatePattern("")] or [ValidateScript({})] regex validation checks to work e.g. for strict integer validation (throw an error if a non-integer value is provided) do not define the var-type e.g. [int]$var since PowerShell will automatically round the input value to an integer BEFORE performing the regex comparisons. Instead, declare parameter without [int] defining the var-type e.g. $var,
			$InputToValidate
		)
		
		Return $InputToValidate
		#Return [int]$InputToValidate
	}
	#-----------------------------------------------------------------------------------------------------------------------
	function Remove-LeadingZeros {
		Param (
			#Script parameters go here
			[Parameter(Mandatory=$true,Position=0,
			ValueFromPipeline = $true)]
			$VarInput
		)
		$VarSimplified = $VarInput.TrimStart('0')
		If ($VarSimplified -eq $null) {
			Write-Verbose "$VarName is `$null after removing leading zeros."
			$VarSimplified = '0'
		}
		If ($VarSimplified -eq "") {
			Write-Verbose "$VarName is equal to `"`" after removing leading zeros."
			$VarSimplified = '0'
		}
		If ($VarSimplified -eq '') {
			Write-Verbose "$VarName is equal to `'`' after removing leading zeros."
			$VarSimplified = '0'
		}
		
		Return $VarSimplified
	}
	#-----------------------------------------------------------------------------------------------------------------------
	# /Sub-functions
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	# Make function more customizable by condensing hard-coded values to the top
	
	$VarName = "Hour"
	
	$MinInt = 0
	
	$MaxInt = 23
	
	# since 24-hour time values are valid hour values
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	# Check if we have a value sent in from an external variable (parameter) first
	If ($VarInput -eq $null -or $VarInput -eq "") {
		$PipelineInput = $false
	} else {
		$PipelineInput = $true
		Write-Verbose "Piped-in content = $VarInput"
		$VarInput = [string]$VarInput #Bugfix: convert input from an object to a string
	}
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	# Initialize test verification vars
	$IntegerValidation = $false
	$RangeValidation = $false
	
	# Begin loop to validate Input, and request new input from user if it fails validation.
	while ($IntegerValidation -eq $false -Or $RangeValidation -eq $false) {
		
		# Initialize test verification vars (at the start of each loop)
		$IntegerValidation = $false
		$RangeValidation = $false
		
		#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		# Prompt user for $VarName value input
		If ($PipelineInput -ne $true) {
			Write-Verbose "No values piped-in from external sources (parameters)"
			$VarInput = Read-Host -Prompt "Enter $VarName"
			Write-Verbose "Entered value = $VarInput"
		} else {
			Write-Verbose "Using piped-in value from parameter = $VarInput"
			$PipelineInput = $false
		}
		
		#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		# Check if input is null
		If ($VarInput -eq $null -or $VarInput -eq "") {
			Write-HorizontalRuleAdv -DashedLine -IsWarning
			Write-Warning "$VarName input is null."
			#PAUSE
			Write-Host `r`n
			Continue #help about_Continue
		}
		
		#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		# Remove leading zeros (0)
		$VarSimplified = Remove-LeadingZeros $VarInput
		Write-Verbose "Remove leading zeros (0) = $VarSimplified"
		
		# Remove leading zeros (0)
		<#
		$VarSimplified = $VarInput.TrimStart('0')
		If ($VarSimplified -eq $null) {
			Write-Verbose "$VarName is `$null after removing leading zeros."
			$VarSimplified = '0'
		}
		If ($VarSimplified -eq "") {
			Write-Verbose "$VarName is equal to `"`" after removing leading zeros."
			$VarSimplified = '0'
		}
		If ($VarSimplified -eq '') {
			Write-Verbose "$VarName is equal to `'`' after removing leading zeros."
			$VarSimplified = '0'
		}
		Write-Verbose "Remove leading zeros (0) = $VarSimplified"
		#>
		
		#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		# Check if $VarName input is integer using Validate-Integer function
		try { # help about_Try_Catch_Finally
			#https://stackoverflow.com/questions/6430382/powershell-detecting-errors-in-script-functions
			$VarInteger = Validate-Integer $VarSimplified -ErrorVariable ValidateIntError
			# -ErrorVariable <variable_name> - Error is assigned to the variable name you specify. Even when you use the -ErrorVariable parameter, the $error variable is still updated.
			# If you want to append an error to the variable instead of overwriting it, you can put a plus sign (+) in front of the variable name. E.g. -ErrorVariable +<variable_name>
			#https://devblogs.microsoft.com/scripting/handling-errors-the-powershell-way/
		}
		catch {
			Write-HorizontalRuleAdv -DashedLine -IsVerbose
			Write-Verbose "`$ValidateIntError:" # Error variable set using the -ErrorVariable "common parameter": Get-Help -Name about_CommonParameters
			Write-Verbose "$ValidateIntError" -ErrorAction 'SilentlyContinue' # Error variable set using the -ErrorVariable "common parameter": Get-Help -Name about_CommonParameters
			#Write-HorizontalRuleAdv -SingleLine -IsVerbose
			#Write-Verbose "`$error:" # Command's error record will be appended to the "automatic variable" named $error
			#Write-HorizontalRuleAdv -DashedLine -IsVerbose
			#Write-Verbose "$error" -ErrorAction 'SilentlyContinue' # Command's error record will be appended to the "automatic variable" named $error
			Write-HorizontalRuleAdv -DashedLine -IsWarning
			Write-Warning "$VarName input must be an integer. (Whole numbers only, no decimals, no negatives.)"
			#PAUSE
			Write-Host `r`n
			Continue #help about_Continue
		}
		
		$IntegerValidation = $true
		
		Write-Verbose "Integer validation success = $VarInteger"
		
		#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		# Check if $VarName input is between $MinInt and $MaxInt
		If ([int]$VarInteger -ge [int]$MinInt -And [int]$VarInteger -le [int]$MaxInt) {
			$VarRange = [int]$VarInteger
			$RangeValidation = $true
		} else {
			Write-HorizontalRuleAdv -DashedLine -IsWarning
			Write-Warning "$VarName input must be between $MinInt-$MaxInt."
			Write-Warning "$VarName input must be between 1-12 for AM/PM time, or 0-23 for 24-hour time."
			#PAUSE
			Write-Host `r`n
			Continue #help about_Continue
		}
		
		Write-Verbose "$VarName value range validation = $VarRange"
		
		#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
	}
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	Write-Verbose "$VarName value $VarRange validation complete."
	
	Return [int]$VarRange
	
} # End ReadPrompt-Hour function ---------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
Function ReadPrompt-ValidateIntegerRange { #----------------------------------------------------------------------------
	
	#http://techgenix.com/powershell-functions-common-parameters/
	# To enable common parameters in functions (-Verbose, -Debug, etc.) the following 2 lines must be present:
	#[cmdletbinding()]
	#Param()
	[cmdletbinding()]
	Param(
		[Parameter(Mandatory=$false,
		ValueFromPipeline = $true)]
		$ValueInput,
		
		[Parameter(Mandatory=$true,Position=0)]
		[string]$Label,
		
		[Parameter(Mandatory=$true,Position=1)]
		[int]$MinInt,
		
		[Parameter(Mandatory=$true,Position=2)]
		[int]$MaxInt
	)
	
	# Sub-functions:
	#-----------------------------------------------------------------------------------------------------------------------
	function Validate-Integer {
		Param (
			#Script parameters go here
			[Parameter(Mandatory=$true,Position=0,
			ValueFromPipeline = $true)]
			# Validate a positive integer (whole number) using Regular Expressions, thanks to:
			#https://stackoverflow.com/questions/16774064/regular-expression-for-whole-numbers-and-integers
			#-----------------------------------------------------------------------------------------------------------------------
			#	(?<![-.])		# Assert that the previous character isn't a minus sign or a dot.
			#	\b				# Anchor the match to the start of a number.
			#	[0-9]+			# Match a number.
			#	\b				# Anchor the match to the end of the number.
			#	(?!\.[0-9])		# Assert that no decimal part follows.
			#$RegEx = "(?<![-.])\b[0-9]+\b(?!\.[0-9])"
			#[ValidatePattern("(?<![-.])\b[0-9]+\b(?!\.[0-9])")]
			# This [ValidateScript({})] does the exact same thing as the [ValidatePattern("")] above, it just throws much nicer, customizable error messages that actually explain why if failed (rather than "(?<![-.])\b[0-9]+\b(?!\.[0-9])").
			[ValidateScript({
				If ($_ -match "(?<![-.])\b[0-9]+\b(?!\.[0-9])") {
					$True
				} else {
					Throw "$_ must be a positive integer (whole number, no decimals). [ValidateScript({})] error."
				}
			})]
			#-----------------------------------------------------------------------------------------------------------------------
			# Bugfix: For the [ValidatePattern("")] or [ValidateScript({})] regex validation checks to work e.g. for strict integer validation (throw an error if a non-integer value is provided) do not define the var-type e.g. [int]$var since PowerShell will automatically round the input value to an integer BEFORE performing the regex comparisons. Instead, declare parameter without [int] defining the var-type e.g. $var,
			$InputToValidate
		)
		
		Return $InputToValidate
		#Return [int]$InputToValidate
	}
	#-----------------------------------------------------------------------------------------------------------------------
	function Remove-LeadingZeros {
		Param (
			#Script parameters go here
			[Parameter(Mandatory=$true,Position=0,
			ValueFromPipeline = $true)]
			$VarInput
		)
		$VarSimplified = $VarInput.TrimStart('0')
		If ($VarSimplified -eq $null) {
			Write-Verbose "$VarName is `$null after removing leading zeros."
			$VarSimplified = '0'
		}
		If ($VarSimplified -eq "") {
			Write-Verbose "$VarName is equal to `"`" after removing leading zeros."
			$VarSimplified = '0'
		}
		If ($VarSimplified -eq '') {
			Write-Verbose "$VarName is equal to `'`' after removing leading zeros."
			$VarSimplified = '0'
		}
		
		Return $VarSimplified
	}
	#-----------------------------------------------------------------------------------------------------------------------
	# /Sub-functions
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	$VarInput = $ValueInput
	
	$VarName = $Label
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	#Check if we have a value sent in from an external variable (parameter) first
	If ($VarInput -eq $null -or $VarInput -eq "") {
		$PipelineInput = $false
	} else {
		$PipelineInput = $true
		Write-Verbose "Piped-in content = $VarInput"
		$VarInput = [string]$VarInput #Bugfix: convert input from an object to a string
	}
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	# Initialize test verification vars
	$IntegerValidation = $false
	$RangeValidation = $false
	
	# Begin loop to validate Input, and request new input from user if it fails validation.
	while ($IntegerValidation -eq $false -Or $RangeValidation -eq $false) {
		
		# Initialize test verification vars (at the start of each loop)
		$IntegerValidation = $false
		$RangeValidation = $false
		
		#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		# Prompt user for $VarName value input
		If ($PipelineInput -ne $true) {
			Write-Verbose "No values piped-in from external sources (parameters)"
			$VarInput = Read-Host -Prompt "Enter $VarName"
			Write-Verbose "Entered value = $VarInput"
		} else {
			Write-Verbose "Using piped-in value from parameter = $VarInput"
			$PipelineInput = $false
		}
		
		#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		# Remove leading zeros (0)
		$VarSimplified = Remove-LeadingZeros $VarInput
		Write-Verbose "Remove leading zeros (0) = $VarSimplified"
		
		# Remove leading zeros (0)
		<#
		$VarSimplified = $VarInput.TrimStart('0')
		If ($VarSimplified -eq $null) {
			Write-Verbose "$VarName is `$null after removing leading zeros."
			$VarSimplified = '0'
		}
		If ($VarSimplified -eq "") {
			Write-Verbose "$VarName is equal to `"`" after removing leading zeros."
			$VarSimplified = '0'
		}
		If ($VarSimplified -eq '') {
			Write-Verbose "$VarName is equal to `'`' after removing leading zeros."
			$VarSimplified = '0'
		}
		#>
		Write-Verbose "Remove leading zeros (0) = $VarSimplified"
		
		#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		# Check if $VarName input is integer using Validate-Integer function
		try { # help about_Try_Catch_Finally
			#https://stackoverflow.com/questions/6430382/powershell-detecting-errors-in-script-functions
			$VarInteger = Validate-Integer $VarSimplified -ErrorVariable ValidateIntError
			# -ErrorVariable <variable_name> - Error is assigned to the variable name you specify. Even when you use the -ErrorVariable parameter, the $error variable is still updated.
			# If you want to append an error to the variable instead of overwriting it, you can put a plus sign (+) in front of the variable name. E.g. -ErrorVariable +<variable_name>
			#https://devblogs.microsoft.com/scripting/handling-errors-the-powershell-way/
		}
		catch {
			Write-HorizontalRuleAdv -DashedLine -IsVerbose
			Write-Verbose "`$ValidateIntError:" # Error variable set using the -ErrorVariable "common parameter": Get-Help -Name about_CommonParameters
			Write-Verbose "$ValidateIntError" -ErrorAction 'SilentlyContinue' # Error variable set using the -ErrorVariable "common parameter": Get-Help -Name about_CommonParameters
			#Write-HorizontalRuleAdv -SingleLine -IsVerbose
			#Write-Verbose "`$error:" # Command's error record will be appended to the "automatic variable" named $error
			#Write-HorizontalRuleAdv -DashedLine -IsVerbose
			#Write-Verbose "$error" -ErrorAction 'SilentlyContinue' # Command's error record will be appended to the "automatic variable" named $error
			Write-HorizontalRuleAdv -DashedLine -IsWarning
			Write-Warning "$VarName input must be an integer. (Whole numbers only, no decimals, no negatives.)"
			#PAUSE
			Write-Host `r`n
			Continue #help about_Continue
		}
		
		$IntegerValidation = $true
		
		Write-Verbose "Integer validation success = $VarInteger"
		
		#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		# Check if $VarName input is between $MinInt and $MaxInt
		If ([int]$VarInteger -ge [int]$MinInt -And [int]$VarInteger -le [int]$MaxInt) {
			$VarRange = [int]$VarInteger
			$RangeValidation = $true
		} else {
			Write-HorizontalRuleAdv -DashedLine -IsWarning
			Write-Warning "$VarName input must be between $MinInt-$MaxInt."
			#PAUSE
			Write-Host `r`n
			Continue #help about_Continue
		}
		
		Write-Verbose "$VarName value range validation = $VarRange"
		
		#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
	}
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	Write-Verbose "$VarName value $VarRange validation complete."
	
	Return [int]$VarRange
	
} # End ReadPrompt-ValidateIntegerRange function -----------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
Function ReadPrompt-Minute { #------------------------------------------------------------------------------------------
	
	#http://techgenix.com/powershell-functions-common-parameters/
	# To enable common parameters in functions (-Verbose, -Debug, etc.) the following 2 lines must be present:
	#[cmdletbinding()]
	#Param()
	[cmdletbinding()]
	Param(
		[Parameter(Mandatory=$false,Position=0,
		ValueFromPipeline = $true)]
		$VarInput
	)
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	# Make function more customizable by condensing hard-coded values to the top
	
	$VarName = "Minute"
	
	$MinInt = 0
	
	$MaxInt = 59
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	#Check if we have a value sent in from an external variable (parameter) first
	If ($VarInput -eq $null -or $VarInput -eq "") {
		$PipelineInput = $false
		$OutputValue = ReadPrompt-ValidateIntegerRange -Label $VarName -MinInt $MinInt -MaxInt $MaxInt
	} else {
		$PipelineInput = $true
		Write-Verbose "Piped-in content = $VarInput"
		$VarInput = [string]$VarInput #Bugfix: convert input from an object to a string
		$OutputValue = $VarInput | ReadPrompt-ValidateIntegerRange -Label $VarName -MinInt $MinInt -MaxInt $MaxInt
	}
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	Write-Verbose "$VarName value $OutputValue validation complete."
	
	Return $OutputValue
	
} # End ReadPrompt-Minute function -------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
Function ReadPrompt-DayOfMonth { #--------------------------------------------------------------------------------------
	
	#http://techgenix.com/powershell-functions-common-parameters/
	# To enable common parameters in functions (-Verbose, -Debug, etc.) the following 2 lines must be present:
	#[cmdletbinding()]
	#Param()
	[cmdletbinding()]
	Param(
		[Parameter(Mandatory=$false,Position=0,
		ValueFromPipeline = $true)]
		$VarInput
	)
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	# Make function more customizable by condensing hard-coded values to the top
	
	$VarName = "DayOfMonth"
	
	$MinInt = 1
	
	$MaxInt = 31
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	#Check if we have a value sent in from an external variable (parameter) first
	If ($VarInput -eq $null -or $VarInput -eq "") {
		$PipelineInput = $false
		$OutputValue = ReadPrompt-ValidateIntegerRange -Label $VarName -MinInt $MinInt -MaxInt $MaxInt
	} else {
		$PipelineInput = $true
		Write-Verbose "Piped-in content = $VarInput"
		$VarInput = [string]$VarInput #Bugfix: convert input from an object to a string
		$OutputValue = $VarInput | ReadPrompt-ValidateIntegerRange -Label $VarName -MinInt $MinInt -MaxInt $MaxInt
	}
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	Write-Verbose "$VarName value $OutputValue validation complete."
	
	Return $OutputValue
	
} # End ReadPrompt-DayOfMonth function ---------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
Function ReadPrompt-Month { #-------------------------------------------------------------------------------------------
	
	#http://techgenix.com/powershell-functions-common-parameters/
	# To enable common parameters in functions (-Verbose, -Debug, etc.) the following 2 lines must be present:
	#[cmdletbinding()]
	#Param()
	[cmdletbinding()]
	Param(
		[Parameter(Mandatory=$false,Position=0,
		ValueFromPipeline = $true)]
		$VarInput
	)
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	# Make function more customizable by condensing hard-coded values to the top
	
	$VarName = "Month"
	
	$MinInt = 1
	
	$MaxInt = 12
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	#Check if we have a value sent in from an external variable (parameter) first
	If ($VarInput -eq $null -or $VarInput -eq "") {
		$PipelineInput = $false
		$OutputValue = ReadPrompt-ValidateIntegerRange -Label $VarName -MinInt $MinInt -MaxInt $MaxInt
	} else {
		$PipelineInput = $true
		Write-Verbose "Piped-in content = $VarInput"
		$VarInput = [string]$VarInput #Bugfix: convert input from an object to a string
		$OutputValue = $VarInput | ReadPrompt-ValidateIntegerRange -Label $VarName -MinInt $MinInt -MaxInt $MaxInt
	}
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	Write-Verbose "$VarName value $OutputValue validation complete."
	
	Return $OutputValue
	
} # End ReadPrompt-Month function --------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
Function ReadPrompt-Year { #--------------------------------------------------------------------------------------------
	
	#http://techgenix.com/powershell-functions-common-parameters/
	# To enable common parameters in functions (-Verbose, -Debug, etc.) the following 2 lines must be present:
	#[cmdletbinding()]
	#Param()
	[cmdletbinding()]
	Param(
		[Parameter(Mandatory=$false,Position=0,
		ValueFromPipeline = $true)]
		$VarInput
	)
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	# Make function more customizable by condensing hard-coded values to the top
	
	$VarName = "Year"
	
	$MinInt = 1900
	
	$MaxInt = 2050
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	#Check if we have a value sent in from an external variable (parameter) first
	If ($VarInput -eq $null -or $VarInput -eq "") {
		$PipelineInput = $false
		$OutputValue = ReadPrompt-ValidateIntegerRange -Label $VarName -MinInt $MinInt -MaxInt $MaxInt
	} else {
		$PipelineInput = $true
		Write-Verbose "Piped-in content = $VarInput"
		$VarInput = [string]$VarInput #Bugfix: convert input from an object to a string
		$OutputValue = $VarInput | ReadPrompt-ValidateIntegerRange -Label $VarName -MinInt $MinInt -MaxInt $MaxInt
	}
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	Write-Verbose "$VarName value $OutputValue validation complete."
	
	Return $OutputValue
	
} # End ReadPrompt-Year function ---------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
Function Convert-AMPMhourTo24hour { #-----------------------------------------------------------------------------------
<#
.SYNOPSIS
Convert an hour value in AM/PM format to a 24-hour value.

.DESCRIPTION
Enter a 12-hour format value plus its AM/PM value, and this cmdlet will return the equivalent 24-hour format hour value from 0-23. Must specify either -AM or -PM switch.

The abbreviations AM and PM derive from Latin:

AM = Ante meridiem: Before noon
PM = Post meridiem: After noon

https://www.timeanddate.com/time/am-and-pm.html

.PARAMETER Hours
The AM/PM hour value, from 1-12. Must be an integer.

.PARAMETER AM
Use the AM parameter to specify the -Hours <VALUE> as AM (Ante Meridiem: Before noon)

.PARAMETER PM
Use the PM parameter to specify the -Hours <VALUE> as PM (Post Meridiem: After noon)

.EXAMPLE
$OutputVar = Convert-AMPMhourTo24hour 4 -PM

This line will convert a PM hour value (in this case, 4 PM) into its 24-hour equivalent, and save the result into the $OutputVar variable.

PS C:\> Write-Host "4 PM = $OutputVar:00"

In this example, the output would read:

"4 PM = 16:00"

since 4:00 PM is equivalent to 16:00 on a 24-hour clock.

.EXAMPLE
Get-Date -UFormat %I | Convert-AMPMhourTo24hour -PM

The above line script will get the current hour in AM/PM format, and convert it to 24-hour format. For example, if the current time was 8 PM, the above line would print out the result:

"20"

since 8:00 PM is equivalent to 20:00 on a 24-hour clock.

To store the output value in a variable first, then print the result:

PS C:\> $OutputVar = (Get-Date -UFormat %I | Convert-AMPMhourTo24hour -PM)
PS C:\> Write-Host "$(Get-Date -UFormat %I) PM = $OutputVar:00"

For example, if the current time was 2 PM, the output would of this would read:

"2 PM = 14:00"

For the same thing but with AM times, simply change the -PM switch to the -AM switch:

PS C:\> $OutputVar = (Get-Date -UFormat %I | Convert-AMPMhourTo24hour -AM)
PS C:\> Write-Host "$(Get-Date -UFormat %I) AM = $OutputVar:00"

For example, if the current time was 8 AM, the output would read:

"8 AM = 8:00"

.EXAMPLE
$StartHour = Read-Host -Prompt "Enter Start hour"
PS C:\> $StartMin = Read-Host -Prompt "Enter Start minute"

# To get today's date, but with a different time-value, then use a script block like this invloving Read-Host, Get-Date, and (this function) Convert-AMPMhourTo24hour.

PS C:\> do {
PS C:\>   $ChoiceAMPM24hour = Read-Host -Prompt "[A]M, [P]M, or [2]4 hour? [A\P\2]"
PS C:\>   switch ($ChoiceAMPM24hour) {
PS C:\> 	'A' { # A - AM time
PS C:\>            $AntePost = "AM"
PS C:\>            Write-Verbose "AM time ('$ChoiceAMPM24hour') option selected."
PS C:\>            $24hourFormat = Convert-AMPMhourTo24hour -Hours $StartHour -AM
PS C:\>     }
PS C:\>     'P' { # P - PM time
PS C:\>            $AntePost = "PM"
PS C:\>            Write-Verbose "PM time ('$ChoiceAMPM24hour') option selected."
PS C:\>            $24hourFormat = Convert-AMPMhourTo24hour -Hours $StartHour -PM
PS C:\>     }
PS C:\>     2 { # 2 - 24-hour time
PS C:\>            $AntePost = "(24-hour)"
PS C:\>            Write-Verbose "24-hour time ('$ChoiceAMPM24hour') option selected."
PS C:\>            $24hourFormat = $StartHour
PS C:\>     }
PS C:\>     default { # Choice not recognized.
PS C:\>            Write-Host `r`n
PS C:\>            Write-Warning "Choice `"$ChoiceAMPM24hour`" not recognized. Options must be AM, PM, or 24-hour."
PS C:\>            Write-Host `r`n
PS C:\>            PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
PS C:\>            #Clear-Host # CLS
PS C:\>            #Break #help about_Break
PS C:\>            Write-Host `r`n
PS C:\>     }
PS C:\>   }
PS C:\> } until ($ChoiceAMPM24hour -eq 'A' -Or $ChoiceAMPM24hour -eq 'P' -Or $ChoiceAMPM24hour -eq 2)
PS C:\> Write-Verbose "12-hour time '$StartHour:$StartMin $AntePost' converted to 24-hour time ('$24hourFormat:$StartMin')"

The above script will prompt the user:

"Enter Start hour: "
"Enter Start minute: "
"[A]M, [P]M, or [2]4 hour? [A\P\2]: "

PS C:\> $DifferentTimeToday = Get-Date -Hour $24hourFormat -Minute $StartMin -Second 0 -Millisecond 0

Then set a variable called $DifferentTimeToday of <DateTime>-type that is has same date as today, but with the time entered by the user.

.INPUTS
Requires a "Hours" time value as input, and selection of AM or PM. Hour value must be a positive integer (whole number, non-decimal) between 1 and 12. "Hours" value can be piped in from other commands, but a choice between -AM or -PM switch must still be made. See Examples for more info.

.OUTPUTS
Returns a [int32] integer number (whole number, not decimal, not negative) between 0 and 23, according to 24-hour time formats, equivalent to the AM/PM input time (hour).

.NOTES
Conversion table between AM/PM hours and 24-hour time format:

--AM/PM----24-hr--------------------------------------------------------------------------------
12:00 AM = 00:00____*** exception: if AM-hours = 12, then 24-hours = 0			\
 1:00 AM = 01:00	\															 |
 2:00 AM = 02:00	 |															 |
 3:00 AM = 03:00	 |															 |
 4:00 AM = 04:00	 |															 |
 5:00 AM = 05:00	 |															 |
 6:00 AM = 06:00	 |------- AM-hour = 24-hours								 |-------  AM
 7:00 AM = 07:00	 |															 |
 8:00 AM = 08:00	 |															 |
 9:00 AM = 09:00	 |															 |
10:00 AM = 10:00	 |															 |
11:00 AM = 11:00____/___________________________________________________________/_______________
12:00 PM = 12:00____*** exception: if PM-hours = 12, then 24-hours = 12			\
 1:00 PM = 13:00	\															 |
 2:00 PM = 14:00	 |															 |
 3:00 PM = 15:00	 |															 |
 4:00 PM = 16:00	 |															 |
 5:00 PM = 17:00	 |															 |
 6:00 PM = 18:00	 |------- (PM-hours + 12) = 24-hours						 |-------  PM
 7:00 PM = 19:00	 |															 |
 8:00 PM = 20:00	 |															 |
 9:00 PM = 21:00	 |															 |
10:00 PM = 22:00	 |															 |
11:00 PM = 23:00____/															/
------------------------------------------------------------------------------------------------

.LINK
about_Comment_Based_Help

.LINK
https://www.lsoft.com/manuals/maestro/4.0/htmlhelp/interface%20user/TimeConversionTable.html

.LINK
https://www.timeanddate.com/time/am-and-pm.html

.LINK
about_Functions_Advanced_Parameters

.LINK
https://docs.microsoft.com/en-us/powershell/developer/cmdlet/validating-parameter-input

.LINK
https://social.technet.microsoft.com/wiki/contents/articles/15994.powershell-advanced-function-parameter-attributes.aspx

.LINK
https://www.petri.com/validating-powershell-input-using-parameter-validation-attributes

.LINK
https://docs.microsoft.com/en-us/powershell/developer/cmdlet/validating-parameter-input

.LINK
https://stackoverflow.com/questions/16774064/regular-expression-for-whole-numbers-and-integers

.LINK
https://www.gngrninja.com/script-ninja/2016/5/15/powershell-getting-started-part-8-accepting-pipeline-input

#>
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	#http://techgenix.com/powershell-functions-common-parameters/
	# To enable common parameters in functions (-Verbose, -Debug, etc.) the following 2 lines must be present:
	#[cmdletbinding()]
	#Param()
	[cmdletbinding()]
	Param (
		#Script parameters go here
		[Parameter(Mandatory=$true,Position=0,
		ValueFromPipeline = $true)]
		# Validate a positive integer (whole number) using Regular Expressions, thanks to:
		#https://stackoverflow.com/questions/16774064/regular-expression-for-whole-numbers-and-integers
		#-----------------------------------------------------------------------------------------------------------------------
		#	(?<![-.])		# Assert that the previous character isn't a minus sign or a dot.
		#	\b				# Anchor the match to the start of a number.
		#	[0-9]+			# Match a number.
		#	\b				# Anchor the match to the end of the number.
		#	(?!\.[0-9])		# Assert that no decimal part follows.
		#$RegEx = "(?<![-.])\b[0-9]+\b(?!\.[0-9])"
		#[ValidatePattern("(?<![-.])\b[0-9]+\b(?!\.[0-9])")]
		# This [ValidateScript({})] does the exact same thing as the [ValidatePattern("")] above, it just throws much nicer, customizable error messages that actually explain why if failed (rather than "(?<![-.])\b[0-9]+\b(?!\.[0-9])").
		[ValidateScript({
            If ($_ -match "(?<![-.])\b[0-9]+\b(?!\.[0-9])") {
                $True
            } else {
                Throw "$_ must be a positive integer (whole number, no decimals)."
            }
        })]
		#-----------------------------------------------------------------------------------------------------------------------
		# Bugfix: For the [ValidatePattern("")] or [ValidateScript({})] regex validation checks to work e.g. for strict integer validation (throw an error if a non-integer value is provided) do not define the var-type e.g. [int]$var since PowerShell will automatically round the input value to an integer BEFORE performing the regex comparisons. Instead, declare parameter without [int] defining the var-type e.g. $var,
		[ValidateRange(1,12)]
		$Hours,
		
		[Parameter(Mandatory=$true,
		ParameterSetName='AMtag')]
		[switch]$AM = $false,
		
		[Parameter(Mandatory=$true,
		ParameterSetName='PMtag')]
		[switch]$PM = $false
	)
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	Write-Verbose "Input hours = $Hours"
	
	#-----------------------------------------------------------------------------------------------------------------------
	# Convert AM hours
	#-----------------------------------------------------------------------------------------------------------------------
	
	If ($AM) {
		Write-Verbose "AM hours selected."
		If ($Hours -eq 12) {
			Write-Verbose "Exception: hour equals 12"
			$24hour = 0
		} else {
			$24hour = $Hours
		}
	}
	
	#-----------------------------------------------------------------------------------------------------------------------
	# Convert PM hours
	#-----------------------------------------------------------------------------------------------------------------------
	
	If ($PM) {
		Write-Verbose "PM hours selected."
		If ($Hours -eq 12) {
			Write-Verbose "Exception: hour equals 12"
			$24hour = 12
		} else {
			$24hour = [Int]$Hours + 12
		}
	}
	
	#-----------------------------------------------------------------------------------------------------------------------
	# Write out result of function
	#-----------------------------------------------------------------------------------------------------------------------
	
	Write-Verbose "24-hour format Result = $24hour"
	
	Return $24hour
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
} # End Convert-AMPMhourTo24hour function ------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
Function Convert-TimeZone { #-------------------------------------------------------------------------------------------

<#
.SYNOPSIS
Convert-TimeZone function converts times from one time zone to the same time in another time zone.

.DESCRIPTION
 Thanks to:
 https://blogs.msdn.microsoft.com/rslaten/2014/08/04/converting-times-from-one-time-zone-to-another-time-zone-in-powershell/

.PARAMETER Time
Horizontal Rule types. Accepted types are 'SingleLine', 'DoubleLine', 'DashedLine', and 'BlankLine'. Defaults to 'SingleLine'.

.PARAMETER FromTimeZone
From

.PARAMETER ToTimeZone
To

.LINK
https://blogs.msdn.microsoft.com/rslaten/2014/08/04/converting-times-from-one-time-zone-to-another-time-zone-in-powershell/

.LINK
Get-TimeZone

#>

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

param(
  [Parameter(Mandatory=$false)]
  $Time,
  [Parameter(Mandatory=$false)]
  $FromTimeZone,
  [Parameter(Mandatory=$false)]
  $ToTimeZone
)

#-----------------------------------------------------------------------------------------------------------------------

function ConvertTime
{
  param($time, $FromTimeZone, $ToTimeZone)

  $oFromTimeZone = [System.TimeZoneInfo]::FindSystemTimeZoneById($FromTimeZone)
  $oToTimeZone = [System.TimeZoneInfo]::FindSystemTimeZoneById($ToTimeZone)
  $utc = [System.TimeZoneInfo]::ConvertTimeToUtc($time, $oFromTimeZone)
  $newTime = [System.TimeZoneInfo]::ConvertTime($utc, $oToTimeZone)

  return $newTime
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

function ConvertUTC
{
  param($time, $FromTimeZone)

  $oFromTimeZone = [System.TimeZoneInfo]::FindSystemTimeZoneById($FromTimeZone)
  $utc = [System.TimeZoneInfo]::ConvertTimeToUtc($time, $oFromTimeZone)
  return $utc
}

#-----------------------------------------------------------------------------------------------------------------------

if ($ToTimeZone)
{
  
  [datetime]$time = $time
  $toUTC = ConvertUTC -time $time -FromTimeZone $FromTimeZone
  $toNewTimeZone = ConvertTime -time $time -FromTimeZone $FromTimeZone -ToTimeZone $ToTimeZone
  Write-Host ("Original Time ({0}): {1}" -f $FromTimeZone, $time)
  Write-Host ("UTC Time: {0}" -f $toUTC)
  Write-Host ("{0}: {1}" -f $ToTimeZone, $toNewTimeZone)
}
else
{
  if (!($time)) 
  {
    $FromTimeZone = (([System.TimeZoneInfo]::Local).Id).ToString()
    $time = [DateTime]::SpecifyKind((Get-Date), [DateTimeKind]::Unspecified)
  }
  else { [datetime]$time = $time }
  Write-Host ("Original Time - {0}: {1}" -f $FromTimeZone, $time)
  $toUTC = ConvertUTC -time $time -FromTimeZone $FromTimeZone
  $times = @()
  foreach ($timeZone in ([system.timezoneinfo]::GetSystemTimeZones()))
  {
   $times += (New-Object psobject -Property @{'Name' = $timeZone.DisplayName; 'ID' = $timeZone.id; 'Time' = (ConvertTime -time $time -FromTimeZone $FromTimeZone -ToTimeZone $timeZone.id); 'DST' = $timeZone.SupportsDaylightSavingTime})
  }
  $times | Sort-Object Time | Format-Table -Property * -AutoSize
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

} # End Convert-TimeZone function --------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
Function Log-Time { #---------------------------------------------------------------------------------------------------
	<#
		.SYNOPSIS
		Log-Time
		
		.DESCRIPTION
		Log-Time description.
		
		.PARAMETER TimeLogFile
		TimeLogFile = '.\TimeLog.csv'
		
		.PARAMETER DateTimeInput
		DateTimeInput <date_time_object>
		
		.PARAMETER Interactive
		Interactive = $false
		
		.PARAMETER Description
		Description <string>
		
		.PARAMETER TimeStampTag
		TimeStampTag <custom_tag>
		
		.PARAMETER ClockIn
		ClockIn
		
		.PARAMETER ClockOut
		ClockOut
		
		.PARAMETER TimeStamp
		TimeStamp <timestamp_message>
		
		.PARAMETER TaskStart
		TaskStart <task_name>
		
		.PARAMETER TaskStop
		TaskStop
		
		.PARAMETER BreakStart
		BreakStart
		
		.PARAMETER BreakStop
		BreakStop
		
		.PARAMETER PauseStart
		PauseStart <pause_reason>
		
		.PARAMETER PauseStop
		PauseStop
		
		.PARAMETER ProjectStart
		ProjectStart <project_name>
		
		.PARAMETER ProjectStop
		ProjectStop <project_name>
		
		.PARAMETER Distraction
		Distraction
		
		.EXAMPLE
		Test-Param -A "Anne" -D "Dave" -F "Freddy"
		C:\PS> 
	#>
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	Param (
		#[CmdletBinding(DefaultParameterSetName="ByUserName")]
		# Script parameters go here
		#https://ss64.com/ps/syntax-args.html
		#http://wahlnetwork.com/2017/07/10/powershell-aliases/
		#https://www.jonathanmedd.net/2013/01/add-a-parameter-to-multiple-parameter-sets-in-powershell.html
		[Parameter(Mandatory=$true,Position=0)]
		[Alias('File','Path','FilePath')]
		[string]$TimeLogFile = '.\TimeLog.csv', 
		
		[Parameter(Mandatory=$false)]
		[Alias('Date','Time')]
		[DateTime]$DateTimeInput,
		
		[Parameter(Mandatory=$false)]
		[Alias('i','PickTime','Add')]
		[switch]$Interactive = $false,
		
		[Parameter(Mandatory=$false)]
		[Alias('d')]
		[string]$Description,
		
		[Parameter(Mandatory=$false,
		Position=1,
		ParameterSetName='CustomTag')]
		[string]$TimeStampTag,
		
		[Parameter(Mandatory=$false,
		ParameterSetName='ClockInTag')]
		[switch]$ClockIn,
		
		[Parameter(Mandatory=$false,
		ParameterSetName='ClockOutTag')]
		[switch]$ClockOut,
		
		[Parameter(Mandatory=$false,
		ParameterSetName='TimeStampTag')]
		[string]$TimeStamp,
		
		[Parameter(Mandatory=$false,
		ParameterSetName='TaskStartTag')]
		[string]$TaskStart,
		
		[Parameter(Mandatory=$false,
		ParameterSetName='TaskStopTag')]
		[switch]$TaskStop,
		
		[Parameter(Mandatory=$false,
		ParameterSetName='BreakStartTag')]
		[switch]$BreakStart,
		
		[Parameter(Mandatory=$false,
		ParameterSetName='BreakStopTag')]
		[switch]$BreakStop,
		
		[Parameter(Mandatory=$false,
		ParameterSetName='PauseStartTag')]
		[string]$PauseStart,
		
		[Parameter(Mandatory=$false,
		ParameterSetName='PauseStopTag')]
		[switch]$PauseStop,
		
		[Parameter(Mandatory=$false,
		ParameterSetName='ProjectStartTag')]
		[string]$ProjectStart,
		
		[Parameter(Mandatory=$false,
		ParameterSetName='ProjectStopTag')]
		[string]$ProjectStop,
		
		[Parameter(Mandatory=$false,
		ParameterSetName='DistractionTag')]
		[switch]$Distraction
		
	)
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	# Function name:
	# https://stackoverflow.com/questions/3689543/is-there-a-way-to-retrieve-a-powershell-function-name-from-within-a-function#3690830
	#$FunctionName = (Get-PSCallStack | Select-Object FunctionName -Skip 1 -First 1).FunctionName
	#$FunctionName = (Get-Variable MyInvocation -Scope 1).Value.MyCommand.Name
	$FunctionName = $PSCmdlet.MyInvocation.MyCommand.Name
	Write-Verbose "Running function: $FunctionName"
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	$TimeLogColumns = "DateTime"
	$TimeLogColumns += ",BeginEnd"
	$TimeLogColumns += ",TimeLogTag"
	$TimeLogColumns += ",Description"
	
	Write-Verbose "Log columns:`r`n'$TimeLogColumns'"
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	#-----------------------------------------------------------------------------------------------------------------------
	# Evaluate input parameters
	#-----------------------------------------------------------------------------------------------------------------------
	
	# Evaluate log file input parameter
	
	If (!$TimeLogFile) {
		Write-HR -IsWarning
		Write-Warning "Time-Log file does not exist: '$TimeLogFile'"
		$ChoiceCreateLogFile = PromptForChoice-YesNo -TitleName "Would you like to create it" -InfoDescription "'$TimeLogFile'" -HintPhrase "create new log file"
		If ($ChoiceCreateLogFile -eq 'Y') {
			# Yes, create new log file
			$TimeLogColumns > $TimeLogFile
		} elseif ($ChoiceCreateLogFile -eq 'N') {
			# No, do not create new log file
			Return
		} else {
			Write-Error "Choice not recognized: 'ChoiceCreateLogFile'. Should be 'Y' for Yes or 'N' for No."
		}
	}
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	# Evaluate -Interactive/-DateTimeInput parameters
	
	If ($DateTimeInput) {
		Write-Verbose "DateTimeInput = $DateTimeInput"
		Write-Host "DateTimeInput = $DateTimeInput"
		$DateTimeMode = 'InputProvided'
		$DateTimeValue = $DateTimeInput
	} elseif ($Interactive) {
		Write-Verbose "Interactive mode selected"
		Write-Host "Interactive mode selected"
		$DateTimeMode = 'Interactive'
	} else {
		Write-HR -IsWarning
		Write-Warning "No -DateTimeInput or -Interactive mode selected. Defaulting to -Interactive"
		$DateTimeMode = 'Interactive'
	}
	Write-Verbose "Date/Time mode selected = $DateTimeMode"
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	# Set Timestamp Tag and Begin/End tag.
	
	If ($TimeStampTag) {
		$TimeLogTag = $TimeStampTag
		$BeginEnd = "[TimeStamp]"
	}
	
	If ($ClockIn) {
		$TimeLogTag = "Clock-In"
		$BeginEnd = "[Begin]"
	}
	
	If ($ClockOut) {
		$TimeLogTag = "Clock-Out"
		$BeginEnd = "[End]"
	}
	
	If ($TimeStamp) {
		$TimeLogTag = "TimeStamp='$TimeStamp'"
		$BeginEnd = "[TimeStamp]"
	}
	
	If ($TaskStart) {
		$TimeLogTag = "Task-Start='$TaskStart'"
		$BeginEnd = "[Begin]"
	}
	
	If ($TaskStop) {
		$TimeLogTag = "Task-Stop"
		$BeginEnd = "[End]"
	}
	
	If ($BreakStart) {
		$TimeLogTag = "Break-Start"
		$BeginEnd = "[Begin]"
	}
	
	If ($BreakStop) {
		$TimeLogTag = "Break-Stop"
		$BeginEnd = "[End]"
	}
	
	If ($PauseStart) {
		$TimeLogTag = "Pause-Start='$PauseStart'"
		$BeginEnd = "[Begin]"
	}
	
	If ($PauseStop) {
		$TimeLogTag = "Pause-Stop"
		$BeginEnd = "[End]"
	}
	
	If ($ProjectStart) {
		$TimeLogTag = "Project-Start='$ProjectStart'"
		$BeginEnd = "[TimeStamp]"
	}
	
	If ($ProjectStop) {
		$TimeLogTag = "Project-Stop='$ProjectStop'"
		$BeginEnd = "[TimeStamp]"
	}
	
	If ($Distraction) {
		$TimeLogTag = "Distraction"
		$BeginEnd = "[TimeStamp]"
	}
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	# Default to [TimeStamp] tag if nothing else is selected.
	
	If ($TimeLogTag -eq $null -Or $TimeLogTag -eq "") {
		Write-HR -IsWarning
		Write-Warning "No TimeStampTag seleceted. Defaulting to [TimeStamp]"
		$TimeLogTag = "TimeStamp='defaultNoTagSelected'"
		If ($BeginEnd -eq $null -Or $BeginEnd -eq "") {
			Write-HR -IsWarning -DashedLine
			Write-Warning "Begin/End mode tag defaulting to [TimeStamp]"
			$BeginEnd = "[TimeStamp]"
		}
	}
	
	#-----------------------------------------------------------------------------------------------------------------------
	# Collect Date/Time value if interactive mode is set
	#-----------------------------------------------------------------------------------------------------------------------
	
	If ($DateTimeMode -eq 'Interactive') {
		Write-Host "Choose Day and Time . . . "
	}
	
	#-----------------------------------------------------------------------------------------------------------------------
	# Write Time-Log Entry
	#-----------------------------------------------------------------------------------------------------------------------
	
	<#
	$TimeLogColumns = "DateTime"
	$TimeLogColumns += ",BeginEnd"
	$TimeLogColumns += ",TimeLogTag"
	$TimeLogColumns += ",Description"
	Write-Verbose "Log columns:`r`n'$TimeLogColumns'"
	#>
	
	$TimeLogEntry = $DateTimeValue
	$TimeLogEntry += ",$BeginEnd"
	$TimeLogEntry += ",$TimeLogTag"
	$TimeLogEntry += ",$Description"
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
} # End Log-Time function ----------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------


#-----------------------------------------------------------------------------------------------------------------------
Function Total-TimestampArray { #---------------------------------------------------------------------------------------
	
	Param (
		#Script parameters go here
		# https://ss64.com/ps/syntax-args.html
		[Parameter(Mandatory=$false,Position=0)]
		[string]$HRtype = 'SingleLine', 
		
		[Parameter(Mandatory=$false)]
		[switch]$Endcaps = $false,

		[Parameter(Mandatory=$false)]
		[string]$EndcapCharacter = '#',
		
		[Parameter(Mandatory=$false)]
		[switch]$IsWarning = $false,

		[Parameter(Mandatory=$false)]
		[switch]$IsVerbose = $false,

		[Parameter(Mandatory=$false)]
		[switch]$MaxLineLength = $false
	)
	
	# Function name:
	# https://stackoverflow.com/questions/3689543/is-there-a-way-to-retrieve-a-powershell-function-name-from-within-a-function#3690830
	#$FunctionName = (Get-PSCallStack | Select-Object FunctionName -Skip 1 -First 1).FunctionName
	#$FunctionName = (Get-Variable MyInvocation -Scope 1).Value.MyCommand.Name
	$FunctionName = $PSCmdlet.MyInvocation.MyCommand.Name
	Write-Verbose "Running function: $FunctionName"
	
	
} # End Total-TimestampArray function ---------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------



#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Once [Functions] block has finished running, exit the script if -LoadFunctions switch is on.
If ($LoadFunctions) {
  #https://stackoverflow.com/questions/2022326/terminating-a-script-in-powershell
  # Only load functions of script. Do not execute Main script block.
  Return
}
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------[Execution]------------------------------------------------------

#=======================================================================================================================
#Index:
#1. Test different methods of writing output
#2. Testing Write-HorizontalRule function
#3. Testing Convert-AMPMhourTo24hour
#4. Testing ReadPrompt-Hour
#5. Testing Out-GridView
#6. User Choice Selection / Menu Demos
#7. Test For loop & date formatting
#8. Test multi-dimensional variable methods
#9. Test running external script
#=======================================================================================================================

#-----------------------------------------------------------------------------------------------------------------------
#=======================================================================================================================
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#
#
##Script MAIN Execution goes here
Clear-Host # CLS
Write-Verbose `n
Write-HorizontalRuleAdv -HRtype DoubleLine -IsVerbose
Write-Verbose `n
Write-Verbose "Script Main beginning. $ScriptName"

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#1. Test different methods of writing output
#=======================================================================================================================

$SectionName = "#1. Test different methods of writing output"

$ChoiceSkip = PromptForChoice-YesNoSectionSkip $SectionName

If ($ChoiceSkip -eq 'N') {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# run "help about_comment_based_help" - I want to display formatted help for a function or script. Use comment-based help instead - run "help about_comment_based_help". PowerShell will format it for you.
# https://technet.microsoft.com/en-us/library/dd819489.aspx
# Write-Host - You almost never need to do it. 
# Write-Information - Only works if $ErrorActionPreference = 'Continue' Does not work if = 'SilentlyContinue' Prints grey text. Can be overridden with -InformationAction Continue
# Write-Verbose - Writes yellow VERBOSE: messages (9 chars). Can be turned on/off by running script with -Verbose parameter.
# Write-Debug - Pauses script execution every time it's called. Can be turned on/off by running script with -Debug parameter.
# Write-Warning - Writes yellow WARNING: messages (9 chars), regardless of -Verbose or -Debug switches.
# Write-Error - Only works if $ErrorActionPreference = 'Continue' Does not work if = 'SilentlyContinue' Prints in red text, "Entire Script path: Error message." E.g. C:\Users\G\Documents\SpiderOak Hive\Consulting\2018-04-06 SodaLakeNetworking\Manage-SodaLakeData.ps1 : TEST ERROR.
# Write-Output - I just need to display some text! Do you really? PowerShell works better with objects, and that's what your script should be outputting, by means of Write-Output. Let PowerShell's Format cmdlets turn those objects into text like lists and tables.
# Write-Progress - Makes a green and yellow progress bar appear at the top part of the command window.

Write-Host "Script Main beginning." $MyInvocation.MyCommand.Name
Write-Information -MessageData "Will only display if set defaults display infromational messages."
Write-Information -MessageData "Test informational messages." -InformationAction Continue
Write-Verbose "Script body."
Write-Verbose "Debug preference = $DebugPreference"
Write-Debug "Script Main beginning." # NOTE: Writing debug text will PAUSE script execution automatically.
Write-Warning "Test Warning."
Write-Error -Message "TEST ERROR. TEST ERROR. TEST ERROR. TEST ERROR." -Category InvalidData -ErrorId TEST_ID
For ($I = 1; $I -le 100; $I++) {Write-Progress -Activity "Test in progress..." -Status "$I% Complete:" -PercentComplete $I;}
#For ($I = 1; $I -le 1000; $I++) {Write-Progress -Activity "Test in progress..." -Status "$($I / 10)% Complete:" -PercentComplete ($I/10)}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#2. Test different methods of writing output thru Logging Module
#-----------------------------------------------------------------------------------------------------------------------

# Write-LogInfo ? Writes an informational message to the log file
# Write-LogWarning ? Writes a warning message to the log file (with the format of WARNING: )
# Write-LogError ? Writes an error message to the log file (with the format of ERROR: ). In addition, optionally calls Stop-Log to end logging and terminate the calling script on fatal error.

Write-LogInfo -LogPath $sLogFile -Message "-----------------------------------------------------------------------------------------------------------------------"
Write-LogInfo -LogPath $sLogFile -Message "[TIMESTAMP]: $($Time)"

Write-LogInfo -LogPath $sLogFile -Message "Test log info write."
Write-LogWarning -LogPath $sLogFile -Message "Test log warning write."
Write-LogError -LogPath $sLogFile -Message "Test log error write."

#Read-Host "Press ENTER key to continue . . . " # PAUSE (Read-Host automatically adds colon : at the end of prompt)
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#2. Test Write-Host colors output
#-----------------------------------------------------------------------------------------------------------------------

<#
help Write-Host -Full

-BackgroundColor <ConsoleColor>

- Black
- DarkBlue
- DarkGreen
- DarkCyan
- DarkRed
- DarkMagenta
- DarkYellow
- Gray
- DarkGray
- Blue
- Green
- Cyan
- Red
- Magenta
- Yellow
- White

-ForegroundColor <ConsoleColor>

- Black
- DarkBlue
- DarkGreen
- DarkCyan
- DarkRed
- DarkMagenta
- DarkYellow
- Gray
- DarkGray
- Blue
- Green
- Cyan
- Red
- Magenta
- Yellow
- White
#>

$TestText = "The quick brown fox jumped over the lazy dog."

Write-Verbose `n
Write-HorizontalRuleAdv -HRtype SingleLine

Write-Host $TestText -ForegroundColor White -BackgroundColor Black
Write-Host $TestText -ForegroundColor Yellow -BackgroundColor Black
Write-Host $TestText -ForegroundColor Magenta -BackgroundColor Black
Write-Host $TestText -ForegroundColor Red -BackgroundColor Black
Write-Host $TestText -ForegroundColor Cyan -BackgroundColor Black
Write-Host $TestText -ForegroundColor Green -BackgroundColor Black
Write-Host $TestText -ForegroundColor Blue -BackgroundColor DarkRed
Write-Host $TestText -ForegroundColor DarkGray -BackgroundColor Cyan
Write-Host $TestText -ForegroundColor Gray -BackgroundColor Black
Write-Host $TestText -ForegroundColor DarkYellow -BackgroundColor Black
Write-Host $TestText -ForegroundColor DarkMagenta -BackgroundColor White
Write-Host $TestText -ForegroundColor DarkRed -BackgroundColor Black
Write-Host $TestText -ForegroundColor DarkCyan -BackgroundColor Red
Write-Host $TestText -ForegroundColor DarkGreen -BackgroundColor Black
Write-Host $TestText -ForegroundColor DarkBlue -BackgroundColor DarkMagenta
Write-Host $TestText -ForegroundColor Black -BackgroundColor White

Write-HorizontalRuleAdv -HRtype SingleLine

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#2. Testing Write-HorizontalRule function
#=======================================================================================================================

$SectionName = "#2. Testing Write-HorizontalRule function"

$ChoiceSkip = PromptForChoice-YesNoSectionSkip $SectionName

If ($ChoiceSkip -eq 'N') {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host "Write-HorizontalRule Help output:"
Write-HorizontalRule
Get-Help Write-HorizontalRule
Get-Help Write-HorizontalRule -Full
Write-HorizontalRule
Write-Verbose "Script MAIN execution. $ScriptName"
Write-Host "Script MAIN execution." $MyInvocation.MyCommand.Name
Write-HorizontalRule -HRtype DoubleLine
Write-HorizontalRule -HRtype DashedLine
Write-HorizontalRule -HRtype SingleLine
Write-HorizontalRule -HRtype IntentionallyThrowError -Verbose

Write-Host `n
Write-Host "Write-HorizontalRuleAdv Help output:"
Write-HorizontalRule
Get-Help Write-HorizontalRuleAdv -Full
Write-HorizontalRule

Write-HorizontalRuleAdv -HRtype SingleLine -Verbose
Write-HorizontalRuleAdv -HRtype DashedLine -Verbose
Write-HorizontalRuleAdv -HRtype DoubleLine -Verbose
Write-HorizontalRuleAdv -HRtype SingleLine -Endcaps
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `|
Write-HorizontalRuleAdv -HRtype DashedLine -Endcaps
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `|
Write-HorizontalRuleAdv -HRtype DoubleLine -Endcaps

Write-HorizontalRuleAdv -HRtype SingleLine -IsVerbose
Write-HorizontalRuleAdv -HRtype DashedLine -IsVerbose
Write-HorizontalRuleAdv -HRtype DoubleLine -IsVerbose
Write-HorizontalRuleAdv -HRtype SingleLine -Endcaps -IsVerbose
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `| -IsVerbose
Write-HorizontalRuleAdv -HRtype DashedLine -Endcaps -IsVerbose
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `| -IsVerbose
Write-HorizontalRuleAdv -HRtype DoubleLine -Endcaps -IsVerbose

Write-HorizontalRuleAdv -HRtype SingleLine -IsWarning
Write-HorizontalRuleAdv -HRtype DashedLine -IsWarning
Write-HorizontalRuleAdv -HRtype DoubleLine -IsWarning
Write-HorizontalRuleAdv -HRtype SingleLine -Endcaps -IsWarning
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `| -IsWarning
Write-HorizontalRuleAdv -HRtype DashedLine -Endcaps -IsWarning
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `| -IsWarning
Write-HorizontalRuleAdv -HRtype DoubleLine -Endcaps -IsWarning

PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#3. Testing Convert-AMPMhourTo24hour
#=======================================================================================================================

$SectionName = "#3. Testing Convert-AMPMhourTo24hour"

$ChoiceSkip = PromptForChoice-YesNoSectionSkip $SectionName

If ($ChoiceSkip -eq 'N') {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

<#
12.1
11.6
11.4
11
011
9.6
9.4
09
9
-9
.9
0.9
.0
0.0
#>

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

help Convert-AMPMhourTo24hour

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

Write-Host "help Convert-AMPMhourTo24hour -full"
Write-Warning "Executing `"help Convert-AMPMhourTo24hour -full`" from a script environment during run will not display any of the extra information from the -Full switch. The command must be executed from the command line to get entire help content."

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 0 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 1 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 12 -AM


Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 09.6 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 09.4 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 12.1 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 11.6 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 11.4 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 11 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 011 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 9.6 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 9.4 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 009 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 09 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 9 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour -9 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour .9 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 0.9 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour .0 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 0.0 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

#

Write-Host `r`n

Write-Host "Example #1:"

$AMPMhour = 4

$OutputVar = Convert-AMPMhourTo24hour $AMPMhour -PM

Write-Host "$AMPMhour PM = $OutputVar           (24-hour)"

Write-Host `r`n

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

Write-Host `r`n

Write-Host "Example #2:"

Get-Date -UFormat %I | Convert-AMPMhourTo24hour -PM

$NowHour = Get-Date -UFormat %I
Write-Host "`$NowHour = $NowHour"

$OutputVar = (Get-Date -UFormat %I | Convert-AMPMhourTo24hour -PM)
Write-Host "`$OutputVar = $OutputVar"

Write-Host "$NowHour PM = $OutputVar           (24-hour)"
Write-Host "$(Get-Date -UFormat %I) PM = $OutputVar           (24-hour)"

Write-Host `r`n

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

Write-Host `r`n

Write-Host "Example #3:"

Get-Random -Minimum 1 -Maximum 12 | Convert-AMPMhourTo24hour -PM

Get-Random -Minimum 1 -Maximum 12 | Tee-Object -Variable Randomvar | Convert-AMPMhourTo24hour -PM
Write-Host "`$Randomvar = $Randomvar"

$OutputVar = (Get-Random -Minimum 1 -Maximum 12 | Tee-Object -Variable Randomvar | Convert-AMPMhourTo24hour -PM)
Write-Host "$Randomvar PM = $OutputVar           (24-hour)"

Write-Host `r`n

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#4. Testing ReadPrompt-Hour
#=======================================================================================================================

$SectionName = "#4. Testing ReadPrompt-Hour"

$ChoiceSkip = PromptForChoice-YesNoSectionSkip $SectionName

If ($ChoiceSkip -eq 'N') {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

Write-Host `r`n
Write-Host `r`n

#

Write-Host "# Start Time #`n`r`n"

Write-Host `r`n

Write-HorizontalRuleAdv -SingleLine

#$StartHour = Read-Host -Prompt "Enter Start hour"
#$StartHour = ReadPrompt-Hour -Verbose
$StartHour = ReadPrompt-Hour -Verbose

#

Write-HorizontalRuleAdv

#

#-----------------------------------------------------------------------------------------------------------------------

Write-HorizontalRuleAdv -DashedLine

Write-Host "Success:" -ForegroundColor Green
$StartHour = (0000004 | ReadPrompt-Hour -Verbose)

Write-HorizontalRuleAdv -DashedLine

Write-Host "Success:" -ForegroundColor Green
$StartHour = ('0000004' | ReadPrompt-Hour -Verbose)

Write-HorizontalRuleAdv -DashedLine

Write-Host "Success:" -ForegroundColor Green
$StartHour = ("0000000" | ReadPrompt-Hour -Verbose)

Write-HorizontalRuleAdv -DashedLine

Write-Host "Failure:"
$StartHour = (24 | ReadPrompt-Hour -Verbose)

Write-HorizontalRuleAdv -DashedLine

Write-Host "Failure:"
$StartHour = (2.4 | ReadPrompt-Hour -Verbose)

Write-HorizontalRuleAdv -DashedLine

Write-Host "Failure:"
$StartHour = (-2 | ReadPrompt-Hour -Verbose)

Write-HorizontalRuleAdv -DashedLine

Write-Host "Failure:"
$StartHour = (0.01 | ReadPrompt-Hour -Verbose)

Write-HorizontalRuleAdv -DashedLine

Write-Host "Failure:"
$StartHour = (-0000.0010 | ReadPrompt-Hour -Verbose)

Write-HorizontalRuleAdv -DashedLine

#-----------------------------------------------------------------------------------------------------------------------

#

Write-HorizontalRuleAdv

#

Write-Host `r`n

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#5. Testing Out-GridView
#=======================================================================================================================

$SectionName = "#5. Testing Out-GridView"

$ChoiceSkip = PromptForChoice-YesNoSectionSkip $SectionName

If ($ChoiceSkip -eq 'N') {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#https://mcpmag.com/articles/2016/02/17/creating-a-gui-using-out-gridview.aspx
Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "A quick way to go back in your history and run the same command again:"
Write-Host "Get-History | Out-GridView -PassThru | Invoke-Expression"
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
Get-History | Out-GridView -PassThru | Invoke-Expression

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Looking at the cmdlet help:"
Get-Command | Out-GridView -PassThru | Get-Help -ShowWindow 

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Looking at the about* Help Files:"
Get-Help about* | Out-GridView -PassThru | Get-Help -ShowWindow 

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Menu example using Out-GridView:"
$Menu = [ordered]@{
	1 = 'Do something'
	2 = 'Do this instead'
	3 = 'Do whatever you want'
}

$Result = $Menu | Out-GridView -PassThru -Title 'Make a selection'

Switch ($Result) {
	{$Result.Name -eq 1} {Write-Host 'Do something'}
	{$Result.Name -eq 2} {Write-Host 'Do this instead'}
	{$Result.Name -eq 3} {Write-Host 'Do whatever you want'}   
} 

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Advanced Out-GridView usage:"
$WMI =  @{
	Filter =  "DriveType='3' AND (Not Name LIKE  '\\\\?\\%')"
	Class =  "Win32_Volume"
	ErrorAction =  "Stop"
	Property =  "Name","Label","Capacity","FreeSpace"
	Computername =  $Env:COMPUTERNAME
}

$List = New-Object System.Collections.ArrayList

Get-WmiObject @WMI  | ForEach {

	$Decimal  = $_.freespace / $_.capacity

	$Graph  = "$($Bar)"*($Decimal*100)

	$Hash = [ordered]@{

		Computername =  $Env:COMPUTERNAME

		Name =  $_.Name

		FreeSpace =  "$Graph"       

		Percent =  $Decimal

		FreeSpaceGB =  ([math]::Round(($_.Freespace/1GB),2))

		CapacityGB =  ([math]::Round(($_.Capacity/1GB),2))

	}

	[void]$List.Add((

		[pscustomobject]$Hash

	))

}

$List | Out-GridView -Title 'Drive Space' 

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#6. User Choice Selection / Menu Demos
#=======================================================================================================================

$SectionName = "#6. User Choice Selection / Menu Demos"

$ChoiceSkip = PromptForChoice-YesNoSectionSkip $SectionName

If ($ChoiceSkip -eq 'N') {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------

Write-Host `r`n
Write-Host "User Choice Selection / Menu Demos"
Write-Host `r`n

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-HorizontalRuleAdv -HRtype SingleLine
Write-Host 'Method #1: "Read-Host -Prompt"'
Write-HorizontalRuleAdv -HRtype DashedLine
do {
	$ChoiceYesNoCancel = Read-Host -Prompt "[Y]es, [N]o, or [C]ancel? [Y\N\C]"
	switch ($ChoiceYesNoCancel) {
		'Y'	{ # Y - Yes
			Write-Verbose "Yes ('$ChoiceYesNoCancel') option selected."
			Write-Host "Yes ('$ChoiceYesNoCancel') option selected."
			Write-Host `r`n
		}
		'N' { # N - No
			Write-Verbose "No ('$ChoiceYesNoCancel') option selected."
			Write-Host "No ('$ChoiceYesNoCancel') option selected."
			Write-Host `r`n
		}
		'C' { # C - Cancel
			Write-Verbose "Cancel ('$ChoiceYesNoCancel') option selected."
			Write-Host "Cancel ('$ChoiceYesNoCancel') option selected."
			Write-Host `r`n
		}
		default { # Choice not recognized.
			Write-Host `r`n
			Write-Host "Choice `"$ChoiceYesNoCancel`" not recognized. Options must be Yes, No, or Cancel."
			#Write-HorizontalRuleAdv -HRtype DashedLine
			Write-Host `r`n
			#Break #help about_Break
			PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
			Write-Host `r`n
			Write-HorizontalRuleAdv -HRtype DashedLine
		}
	}
}
until ($ChoiceYesNoCancel -eq 'Y' -Or $ChoiceYesNoCancel -eq 'N' -Or $ChoiceYesNoCancel -eq 'C')
Write-HorizontalRuleAdv -HRtype DashedLine
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `r`n
Write-HorizontalRuleAdv -HRtype SingleLine
Write-Host 'Method #2: "PromptForChoice()"'
#-----------------------------------------------------------------------------------------------------------------------
# Build Menu
#-----------------------------------------------------------------------------------------------------------------------
#Clear-Host # CLS
Write-HorizontalRuleAdv -HRtype DashedLine
#-----------------------------------------------------------------------------------------------------------------------
# Build Choice Prompt
#-----------------------------------------------------------------------------------------------------------------------
$Title = "Main Menu"
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
$Info = 'User choice selection example using "PromptForChoice()"'
$Info = @"
User choice selection example using "PromptForChoice()"

Y - Yes
N - No
Q - Quit
 
Select a choice:
"@
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# &Quit makes Q a Hot Key. 
$ChoiceYes = New-Object System.Management.Automation.Host.ChoiceDescription "&Yes", "Select [Y]es as the answer."
$ChoiceNo = New-Object System.Management.Automation.Host.ChoiceDescription "&No", "Select [N]o as the answer."
$ChoiceQuit = New-Object System.Management.Automation.Host.ChoiceDescription "&Quit", "[Q]uit, prints `"Good Bye!!!`" in green"
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
$Options = [System.Management.Automation.Host.ChoiceDescription[]]($ChoiceYes, $ChoiceNo)
# default choice: 0 = first Option, 1 = second option, etc.
[int]$defaultchoice = 1
#-----------------------------------------------------------------------------------------------------------------------
# Execute Choice Prompt
#-----------------------------------------------------------------------------------------------------------------------
# PromptForChoice() output will always be integer: https://powershell.org/forums/topic/question-regarding-result-host-ui-promptforchoice/
# If run from shell, will create a GUI dialog box. If run from script, will create choice text menu in command line.
# https://social.technet.microsoft.com/wiki/contents/articles/24030.powershell-demo-prompt-for-choice.aspx
$answer = $host.UI.PromptForChoice($Title, $Info, $Options, $defaultchoice)
#-----------------------------------------------------------------------------------------------------------------------
# Interpret answer
#-----------------------------------------------------------------------------------------------------------------------
#help about_switch
#https://powershellexplained.com/2018-01-12-Powershell-switch-statement/#switch-statement
Write-Verbose "Answer = $answer"
switch ($answer) {
	0	{ # Y - Yes
		Write-Verbose "Yes ('$answer') option selected."
		Write-Host "Si Senor." -ForegroundColor Green
		Write-Host `r`n
	}
	1 { # N - No
		Write-Verbose "No ('$answer') option selected."
		Write-Host "No gracias." -ForegroundColor Orange
		Write-Host `r`n
	}
	2 {
		Write-Verbose "Quit ('$answer') option selected."
		Write-Host "Good Bye!!!" -ForegroundColor Green
		Write-HorizontalRuleAdv -HRtype DashedLine
		Write-Host `r`n
	}
}
Write-HorizontalRuleAdv -HRtype DashedLine -IsVerbose
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `r`n
Write-HorizontalRuleAdv -HRtype SingleLine
Write-Host 'Method #3: "Out-GridView -PassThru"'
Write-HorizontalRuleAdv -HRtype DashedLine
#-----------------------------------------------------------------------------------------------------------------------
# Build Menu
#-----------------------------------------------------------------------------------------------------------------------
Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Menu example using Out-GridView:"
#-----------------------------------------------------------------------------------------------------------------------
# Build Choice Prompt
#-----------------------------------------------------------------------------------------------------------------------
$Title = "Main Menu"
$Menu = [ordered]@{
	1 = 'Yes'
	2 = 'No'
	3 = 'Cancel'
}
#-----------------------------------------------------------------------------------------------------------------------
# Execute Choice Prompt
#-----------------------------------------------------------------------------------------------------------------------
# Using Out-GridView creates a GUI selection window with filter ability
# and ability to select multiple options with the -PassThru switch
$Result = $Menu | Out-GridView -PassThru -Title $Title
#-----------------------------------------------------------------------------------------------------------------------
# Interpret answer
#-----------------------------------------------------------------------------------------------------------------------
$answer = $Result.Name
Write-Verbose "`$Result.Name = $answer"
Write-HorizontalRuleAdv -HRtype DashedLine -IsVerbose
Switch ($answer) {
	1 {
		Write-Host '"Yes" was selected.'
	}
	2 {
		Write-Host '"No" was selected.'
	}
	3 {
		Write-Host '"Cancel" was selected.'
	}
}
Write-HorizontalRuleAdv -HRtype DashedLine
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#7. Test For loop & date formatting
#=======================================================================================================================

$SectionName = "#7. Test For loop & date formatting"

$ChoiceSkip = PromptForChoice-YesNoSectionSkip $SectionName

If ($ChoiceSkip -eq 'N') {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Months in 3 letters."
# https://www.business.com/articles/powershell-for-loop/
# help about_For
For ($m=1; $m -lt 13; $m++) {
    $m
    Get-Date -Month $m -UFormat %b
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#8. Test multi-dimensional variable methods
#=======================================================================================================================

$SectionName = "#8. Test multi-dimensional variable methods"

$ChoiceSkip = PromptForChoice-YesNoSectionSkip $SectionName

If ($ChoiceSkip -eq 'N') {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Test CSV ForEach loop 1."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test1.csv"
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
$CSVheaders = "col1,col2"
$CSVarray = (Get-Content $CSVfile).split(",")
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
ForEach ($column in $CSVarray) {
	Write-Host "Start of loop."
    Write-Host "Whole:     $column"
	Write-Host "Array One: $column[0]"
	Write-Host "Array Two: $column[1]"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Test CSV ForEach loop 2."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test2.csv"
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
$CSVheaders = "col1,col2"
$CSVarray = (Get-Content $CSVfile).split(",")
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
ForEach ($line in $CSVarray) {
	Write-Host "Start of loop."
    Write-Host "Whole:     $line"
	Write-Host "Array One: $line[0]"
	Write-Host "Array Two: $line[1]"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Test CSV ForEach loop 3."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test3.csv"
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
$CSVheaders = "col1,col2"
$CSVarray = (Get-Content $CSVfile).split(",")
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
ForEach ($line in $CSVarray) {
	Write-Host "Start of loop."
    Write-Host "Whole:     $line"
	Write-Host "Array One: $line[0]"
	Write-Host "Array Two: $line[1]"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype SingleLine
Write-Host `n
Write-Host "Test Import-CSV ForEach loop."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test3.csv"
$CSVheaders = "col1,col2"
$CSVarray = (Get-Content $CSVfile).split(",")
$CSVimport = Import-CSV $CSVfile -Delimiter "," -Header $CSVheaders
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
Import-CSV -Path $CSVfile -Delimiter "," -Header $CSVheaders | ForEach {
	Write-Host "Start of loop."
    Write-Host "Whole:     $_"
	Write-Host "Array One: $_[0]"
	Write-Host "Array Two: $_[1]"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype SingleLine
Write-Host `n
Write-Host "Test Import-CSV ForEach loop 2."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test4.csv"
$CSVheaders = "col1,col2,col3"
$CSVarray = (Get-Content $CSVfile).split(",")
$CSVimport = Import-CSV -Path $CSVfile -Delimiter "," -Header $CSVheaders
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
Import-CSV -Path $CSVfile | ForEach {
	Write-Host "Start of loop."
    Write-Host "Whole:     $_"
	Write-Host "Col call: $($_."header 1")"
	Write-Host "Col call: $($_."header 2")"
	Write-Host "Col call: $($_.H1)"
	Write-Host "Col call: $($_."header 4")"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DoubleLine
Write-Host `n
Write-Host "Perform actions from a CSV file."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\commands.csv"
$CSVheaders = "Program,Exec Command"
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
# The foreach alias also supports beginning command blocks, middle command blocks, and end command blocks. The beginning and end command blocks run once, and the middle command block runs every time the Foreach loop steps through a collection or array.
# <command> | foreach {<beginning command_block>}{<middle command_block>}{<ending command_block>}
Import-CSV -Path $CSVfile | ForEach-Object {
	# beginning (runs once)
	Write-Host `n
	Write-Host "Beginning block: ForEach"
	Write-Host `n
}{
    # middle (loop)
	Write-Host "$_"
	
	# https://discoposse.com/2012/01/23/csv-yeah-you-know-me-powershell-and-the-import-csv-cmdlet-part-1/
	# https://discoposse.com/2012/01/23/csv-yeah-you-know-me-powershell-and-the-import-csv-cmdlet-part-2/
	# https://discoposse.com/2012/12/29/csv-yeah-you-know-me-powershell-and-the-import-csv-cmdlet-part-3/
	
	$HostProgram = $_.Program
	$CommandToExecute = $_."Exec Command"
	
	Write-Host "Host Program: $HostProgram"
	Write-Host "Expand Var: $($_.Program)"
	
	Write-Host "Command to execute: $CommandToExecute"
	Write-Host "Expand Var: $($_."Exec Command")"
	Write-Host `n
}{
	# ending (runs once)
	Write-Host "Ending block: ForEach"
	Write-Host `n
}

Write-Host "Loop is over."
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#9. Test running external script
#=======================================================================================================================

$SectionName = "#9. Test running external script"

$ChoiceSkip = PromptForChoice-YesNoSectionSkip $SectionName

If ($ChoiceSkip -eq 'N') {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Run External Script."
$ExternalScript = "$Home\Documents\SodaLake\PowerShell\Choice\DialogDemo.ps1"
PowerShell.exe -NoProfile -ExecutionPolicy Bypass -Command "& '$ExternalScript'"
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-Verbose "/Script body."
Write-HorizontalRuleAdv -HRtype DoubleLine
#Script MAIN Execution ends here
#
#
#
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#=======================================================================================================================
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------[Footer]---------------------------------------------------------

Write-Host `n
Write-Host "End of script" $MyInvocation.MyCommand.Name
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
Write-Host `n

Write-Verbose "Script Main end. $ScriptName"
Write-Debug "End-of-script. $ScriptName"
Write-LogInfo -LogPath $sLogFile -Message "End of script $ScriptName"
Stop-Log -LogPath $sLogFile
Write-Output $sLogFile
Return
