<#
.SYNOPSIS
  <Overview of script>

.DESCRIPTION
  <Brief description of script>

.PARAMETER -SampleParam
  <This parameter text will not be shown, since -SampleParam is not a real parameter listed in Param(). However, if a .PARAMETER help line is present and there is no Param(), all help text will fail.>

.PARAMETER LaunchedInCmd
  Used to indicate to this script when it has been launched in a Command Prompt windows (CMD.EXE)
  
  Formats output to the size of a standard Command Prompt (79 characters wide + 1) or to the size of a standard PowerShell window (119 characters winde + 1)

.PARAMETER LoadFunctions
  Use this switch to only load the functions in this script. The script main body execution will not run.

.INPUTS
  <Inputs if any, otherwise state None>

.OUTPUTS 
Log File
  The script log file stored in C:\Windows\Temp\<name>.log

.NOTES
  Version:        1.0
  Author:         <Name>
  Creation Date:  <Date>
  Purpose/Change: Initial script development

  Requires PSLogging module from 
  https://9to5it.com/powershell-logging-v2-easily-create-log-files/
  PowerShell Gallery:
  https://www.powershellgallery.com/packages/PSLogging/
  GitHub:
  https://www.powershellgallery.com/packages/PSLogging/

  AUTOGENERATED CONTENT
    The name, syntax, parameter list, parameter attribute table, common
    parameters, and remarks are automatically generated by the Get-Help cmdlet.

.EXAMPLE
  <Example explanation goes here>
  
  <Example goes here. Repeat this attribute for more than one example>

.LINK
about_Comment_Based_Help

.LINK
about_Requires

.LINK
about_Scripts

.LINK
https://ss64.com/ps/syntax-run.html

.LINK
https://ss64.com/ps/call.html

.LINK
about_Functions_CmdletBindingAttribute
#>

# "#Requires" - You can use a #Requires statement to prevent a script from running without specified modules or snap-ins and a specified version of PowerShell. For more information, see about_Requires.
# help about_Requires
# help about_PSSnapins
# e.g. "#Requires -Version 6" "#Requires -RunAsAdministrator"
#Requires -Modules PSLogging

# To insatll PSLogging module:
# https://docs.microsoft.com/en-us/powershell/developer/module/installing-a-powershell-module
# PowerShell v4:
# 	1. Find PSModulePath environment variable
# 		$Env:PSModulePath
# 		[Environment]::GetEnvironmentVariable("PSModulePath")
#	2. Find the PSLogging module
# 		.\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging
# 	3. Either copy the module to a location within the PSModulePath environment variable, or add the location of the module to the PSModulePath environment variable.
# 		3a. Copy the module to the location:
# 			# Install for Current User – $Home\Documents\WindowsPowerShell\Modules (%UserProfile%\Documents\WindowsPowerShell\Modules)
# 				$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 				$Destination = "$Home\Documents\WindowsPowerShell\Modules"
# 				Copy-Item "$newModule" -Destination "$Destination\PSLogging" -Recurse
# 			# Install for All Users – $Env:ProgramFiles\WindowsPowerShell\Modules (%ProgramFiles%\WindowsPowerShell\Modules)
# 				$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 				$Destination = "$Env:ProgramFiles\WindowsPowerShell\Modules"
# 				Copy-Item "$newModule" -Destination "$Destination\PSLogging" -Recurse
# 		3b. Add the module's path to the PSModulePath environment variable
# 			$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 			$p = [Environment]::GetEnvironmentVariable("PSModulePath")
# 			$p += ";$newModule"
# 			[Environment]::SetEnvironmentVariable("PSModulePath",$p)
# PowerShell v5: (and above)
# 	Find-Module -Name "PSLogging*" | Install-Module -Scope AllUsers 
# Accepted values: CurrentUser, AllUsers
# 	Update-Module PSLogging -Force

#-----------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------[Header]--------------------------------------------------------

# Index:
# 1. <# Help #>
# 2. #Requires
# 3. [Header]
# 4. [Script Parameters]
# 5. [Initialisations]
# 6. [Modules]
# 7. [Declarations]
# 8. [Functions]
# 9. [Execution]
# 10. [Footer]

# Tested with PowerShell versions:
# 5.1
# $PSVersionTable.PSVersion

# To run from PowerShell command line:
# https://ss64.com/ps/syntax-run.html
# https://ss64.com/ps/call.html
# help about_Scripts
# & "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1"
# & "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Verbose -Debug
# & "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Verbose -Debug -LaunchedInCmd
# https://ss64.com/ps/source.html
# . "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1"
# . "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Verbose -Debug
# . "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Verbose -Debug -LaunchedInCmd

# To run help:
# Get-Help "C:\Users\G\Documents\SpiderOak Hive\Programming\Powershell\Templates\powershell-template.ps1" -Full
# Example help file:
# Get-Help Get-ChildItem
# Get-Help Get-ChildItem -Full

# Execution Policy:
# $oldExecutionPolicy = Get-ExecutionPolicy
# Set-ExecutionPolicy -ExecutionPolicy RemoteSigned
# Set-ExecutionPolicy -ExecutionPolicy Bypass
# Set-ExecutionPolicy $oldExecutionPolicy

#-----------------------------------------------------------------------------------------------------------------------
#--------------------------------------------------[Script Parameters]--------------------------------------------------

# Debugging: absolutely NO commands can come before Param (except for [CmdletBinding()] )
# Debugging: You must have a script parameter defined here if you have the Help Topic .PARAMETER defined above.
# https://ss64.com/ps/syntax-args.html

#[CmdletBinding()]
#[CmdletBinding(SupportsShouldProcess=$true)]

#Script parameters go here
Param (
  #Script parameters go here
  # Debugging: You must have a script parameter defined here if you have the Help Topic .PARAMETER defined above.
  # help about_Functions_Advanced_Parameters
  # https://ss64.com/ps/syntax-args.html
  # https://ss64.com/ps/syntax-automatic-variables.html

  [Parameter(Mandatory=$false)]
  [switch]$LaunchedInCmd = $false,

  [Parameter(Mandatory=$false)]
  [switch]$LoadFunctions = $false
)


#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
If (-Not $LoadFunctions) {
# Only load functions of script. Do not execute Main script block.
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------[Initialisations]---------------------------------------------------

Write-Verbose `n # New line (carriage return and newline (CRLF), `r`n)
Write-Host `n

# Script name (including extension)
$ScriptName = $MyInvocation.MyCommand.Name
Write-Verbose "Script name:"
Write-Verbose "$ScriptName"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

# Script dir (home directory of script)
#https://stackoverflow.com/questions/801967/how-can-i-find-the-source-path-of-an-executing-script/6985381#6985381
$ScriptDir = Split-Path $script:MyInvocation.MyCommand.Path
Write-Verbose "Script home directory:"
Write-Verbose "$ScriptDir"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

# Script path (full file path & name & extension of currently running script)
$ScriptPath = $MyInvocation.MyCommand.Path
Write-Verbose "Script full path:"
Write-Verbose "$ScriptPath"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

#Set Error Action to Silently Continue
$ErrorActionPreference = 'SilentlyContinue'
#Set Error Action to Continue
$ErrorActionPreference = 'Continue'

#Set Verbose message display
#$VerbosePreference = "SilentlyContinue"
#$VerbosePreference = "Continue"

#Set Debug message display
# help about_Debuggers
#$DebugPreference = "SilentlyContinue"
#$DebugPreference = "Continue"

#Set Progress Bar display
#* If the progress bar does not appear, check the value of the $ProgressPreference variable. If the value is set to SilentlyContinue, the progress bar is not displayed. For more information about Windows PowerShell preferences, see about_Preference_Variables.
#$ProgressPreference = "SilentlyContinue"
#$ProgressPreference = "Continue"

#Set Informational message display
#$InformationPreference = "SilentlyContinue"
#$InformationPreference = "Continue"

#Check Execution Policy
$RecommendedExecutionPolicy = "RemoteSigned"
Write-Verbose "Recommended Execution Policy = $RecommendedExecutionPolicy"
#Write-Host "Current Execution Policy =" (Get-ExecutionPolicy)
$startExecutionPolicy = Get-ExecutionPolicy
Write-Verbose "Current Execution Policy = $startExecutionPolicy"

#Check PowerShell version
$MinimumRequiredVersion = 6
# https://ss64.com/ps/get-host.html
# https://stackoverflow.com/questions/1825585/determine-installed-powershell-version
$PoShVersion = $PSVersionTable.PSVersion
# https://ss64.com/ps/if.html
IF ($PSVersionTable.PSVersion.Major -lt $MinimumRequiredVersion) {
    Write-Warning "This script requires at least PowerShell version $MinimumRequiredVersion. Running version $PoShVersion"
}
Write-Verbose "Minimum required PowerShell version = $MinimumRequiredVersion"
Write-Host "Current PowerShell version =" $PSVersionTable.PSVersion.Major . $PSVersionTable.PSVersion.Minor
Write-Host "Current PowerShell version =" $PSVersionTable.PSVersion.Major`.$PSVersionTable.PSVersion.Minor
#Write-Host "Current PowerShell version = $PSVersionTable.PSVersion.Major . $PSVersionTable.PSVersion.Minor"
Write-Host "Current PowerShell version =" $PSVersionTable.PSVersion.Major `b. `b$PSVersionTable.PSVersion.Minor
Write-Host "Current PowerShell version =" $PSVersionTable.PSVersion.Major `b. `b "$PSVersionTable.PSVersion.Minor"
Write-Host "Current PowerShell version =" $PSVersionTable.PSVersion.Major `b. `b"$PSVersionTable.PSVersion.Minor"

#-----------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------[Modules]-------------------------------------------------------

#Import Modules & Snap-ins
Write-Verbose "Importing modules..."
Write-Verbose `n # New line (carriage return and newline, `r`n)

Import-Module PSLogging

Write-Verbose `r`n
Write-Verbose "Module import complete..."

#-----------------------------------------------------------------------------------------------------------------------
#-----------------------------------------------------[Declarations]----------------------------------------------------

#Script Version
$sScriptVersion = '1.0'

#Log File Info
$scriptPath = Split-Path -parent $MyInvocation.MyCommand.Definition # PoSh v2 compatible - thanks to https://stackoverflow.com/questions/5466329/whats-the-best-way-to-determine-the-location-of-the-current-powershell-script
Write-Verbose "scriptPath = $scriptPath"
Write-Verbose "scriptPath = $PSScriptRoot" # PoSh v3 compatible - This is an automatic variable set to the current file's/module's directory
$sLogPath = $scriptPath
$sLogPath = $PSScriptRoot
$yesterday = [DateTime]::Today.AddDays(-1)
$TodaysDate = Get-Date -Format FileDate
Write-Verbose "Date code = $TodaysDate"
$sLogName = $MyInvocation.MyCommand.Name.Substring(0,$MyInvocation.MyCommand.Name.Length-4) + "_" + $TodaysDate + ".log"
Write-Verbose "LogName = $sLogName"
$sLogFile = Join-Path -Path $sLogPath -ChildPath $sLogName
Write-Verbose "LogFile = $sLogFile"

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Only load functions of script. Do not execute Main script block.
}
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------[Functions]------------------------------------------------------

# help about_Functions
# help about_Functions_Advanced
# help about_Functions_Advanced_Methods
# help about_Functions_Advanced_Parameters
# Get-Verb

<#

Function <FunctionName> {
  Param ()

  Begin {
    Write-LogInfo -LogPath $sLogFile -Message '<description of what is going on>...'
  }

  Process {
    Try {
      <code goes here>
    }

    Catch {
      Write-LogError -LogPath $sLogFile -Message $_.Exception -ExitGracefully
      Break
    }
  }

  End {
    If ($?) {
      Write-LogInfo -LogPath $sLogFile -Message 'Completed Successfully.'
      Write-LogInfo -LogPath $sLogFile -Message ' '
    }
  }
} # End <FunctionName> function ----------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#>

function Start-PSAdmin {Start-Process PowerShell -Verb RunAs}

function Get-ScriptDirectory1 #https://stackoverflow.com/questions/801967/how-can-i-find-the-source-path-of-an-executing-script/6985381#6985381
{
    Split-Path $script:MyInvocation.MyCommand.Path
} # End Get-ScriptDirectory function -----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

function Get-ScriptDirectory2 { #https://stackoverflow.com/questions/1183183/path-of-currently-executing-powershell-script#1183197
    # For PowerShell 3.0 users - following works for both modules and script files:
    Split-Path -parent $PSCommandPath
} # End Get-ScriptDirectory function -----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

function Get-ScriptDirectory3 #https://stackoverflow.com/questions/1183183/path-of-currently-executing-powershell-script#1183197
{
  $Invocation = (Get-Variable MyInvocation -Scope 1).Value
  Split-Path $Invocation.MyCommand.Path
} # End Get-ScriptDirectory function -----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
#.SYNOPSIS
# <Overview of script>

#.DESCRIPTION
# <Brief description of script>

#.PARAMETER HRtype
# Horizontal Rule types. Accepted types are 'SingleLine', 'DoubleLine', 'DashedLine', and 'BlankLine'. 

#.NOTES
# <Notes Here>
Function Write-HorizontalRule {
  Param (
    [Parameter(Mandatory=$false,Position=0)]
    [string]$HRtype = 'SingleLine'
  )
  
  # help about_Automatic_Variables
  # help about_If
  # help about_Comparison_Operators
  # https://ss64.com/ps/if.html
  IF ($LaunchedInCmd -eq $true) {
    # Print horizontal rule styles here using Write-Host instead of Write-Verbose, since that would add "VERBOSE: " to the beginning of each line and prevent the horizontal rule from lining up on the screen properly.
	# Command Prompt character width: 79
    IF ($HRtype -eq "DoubleLine") {
      Write-Host ===============================================================================
    } ELSEIF ($HRtype -eq "DashedLine") {
      Write-Host "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "SingleLine") {
      #Write-Host -------------------------------------------------------------------------------- # This too long
      Write-Host -------------------------------------------------------------------------------
    } ELSEIF (-Not $HRtype) {
      Write-Host -------------------------------------------------------------------------------
    } ELSE {
      Write-Verbose "PowerShell Script launched in cmd.exe = $LaunchedInCmd"
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
    }
  } ELSEIF ($LaunchedInCmd -eq $false) {
    # PowerShell window character width: 119
    IF ($HRtype -eq "DoubleLine") {
      Write-Host =======================================================================================================================
    } ELSEIF ($HRtype -eq "DashedLine") {
      Write-Host - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    } ELSEIF ($HRtype -eq "SingleLine") {
      #Write-Host ------------------------------------------------------------------------------------------------------------------------ # This too long
      Write-Host -----------------------------------------------------------------------------------------------------------------------
    } ELSEIF (-Not $HRtype) {
      Write-Host -----------------------------------------------------------------------------------------------------------------------
    } ELSE {
      Write-Verbose "PowerShell Script launched in cmd.exe = $LaunchedInCmd"
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
    }
  }
} # End Write-HorizontalRule function ----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

Function Write-HorizontalRuleAdv {
  
  # .DESCRIPTION
  #  <Brief description of script>
  
  # .PARAMETER HRtype
  # Horizontal Rule types. Accepted types are 'SingleLine', 'DoubleLine', 'DashedLine', and 'BlankLine'. 
  
  # .PARAMETER Endcaps
  # Add a character to each end of the horizontal rule. Default is '#'. Set a different endcap character using -EndcapCharacter <single character>
  
  Param (
    #Script parameters go here
    # https://ss64.com/ps/syntax-args.html
    [Parameter(Mandatory=$false,Position=0)]
    [string]$HRtype = 'SingleLine',
    
    [Parameter(Mandatory=$false)]
    [switch]$Endcaps = $false,

    [Parameter(Mandatory=$false)]
    [string]$EndcapCharacter = '#',
	
    [Parameter(Mandatory=$false)]
    [switch]$IsWarning = $false,

    [Parameter(Mandatory=$false)]
    [switch]$IsVerbose = $false,

    [Parameter(Mandatory=$false)]
    [switch]$MaxLineLength = $false
  )
  
  # Function name:
  # https://stackoverflow.com/questions/3689543/is-there-a-way-to-retrieve-a-powershell-function-name-from-within-a-function#3690830
  #$FunctionName = (Get-PSCallStack | Select-Object FunctionName -Skip 1 -First 1).FunctionName
  #$FunctionName = (Get-Variable MyInvocation -Scope 1).Value.MyCommand.Name
  $FunctionName = $PSCmdlet.MyInvocation.MyCommand.Name
  Write-Verbose "Running function: $FunctionName"
  
  # help about_Automatic_Variables
  # help about_If
  # help about_Comparison_Operators
  # https://ss64.com/ps/if.html
  IF ($LaunchedInCmd) {
    # Print horizontal rule styles here using Write-Host instead of Write-Verbose, since that would add "VERBOSE: " to the beginning of each line and prevent the horizontal rule from lining up on the screen properly.
	# Command Prompt character width: 79
    IF ($HRtype -eq "DoubleLine") {
      $HRoutput = "==============================================================================="
    } ELSEIF ($HRtype -eq "DashedLine") {
      $HRoutput = "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "BlankLine") {
      $HRoutput = "                                                                               "
    } ELSEIF ($HRtype -eq "SingleLine") {
      #HRoutput = "--------------------------------------------------------------------------------" # This too long
      $HRoutput = "-------------------------------------------------------------------------------"
    } ELSEIF (-Not $HRtype) {
      $HRoutput = "-------------------------------------------------------------------------------"
    } ELSE {
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
      Return
    }
  } ELSE {
    # PowerShell window character width: 119
    IF ($HRtype -eq "DoubleLine") {
      $HRoutput = "======================================================================================================================="
    } ELSEIF ($HRtype -eq "DashedLine") {
      $HRoutput = "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "BlankLine") {
      $HRoutput = "                                                                                                                       "
    } ELSEIF ($HRtype -eq "SingleLine") {
      #HRoutput = "------------------------------------------------------------------------------------------------------------------------" # This too long
      $HRoutput = "-----------------------------------------------------------------------------------------------------------------------"
    } ELSEIF (-Not $HRtype) {
      $HRoutput = "-----------------------------------------------------------------------------------------------------------------------"
    } ELSE {
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
      Return
    }
  }
  
  # Command Prompt character width: 79
  # PowerShell window character width: 119
  $MaxLength = $HRoutput.Length
  
  IF ($IsWarning -eq $true -or $IsVerbose -eq $true) {
    #WARNING: 
    #VERBOSE: 
    #123456789
    $MaxLength = $MaxLength - 9
    $HRoutput = ($HRoutput).Substring(9,$MaxLength)
  }
  
  IF ($Endcaps -eq $true) {
    #$EndcapLength = $MaxLength - 2
    $MaxLength = $MaxLength - 2
    #$HRoutput = ($HRoutput).Substring(1,$EndcapLength)
    $HRoutput = ($HRoutput).Substring(1,$MaxLength)
    $HRoutput = "$EndcapCharacter$HRoutput$EndcapCharacter"
  }
  
  $MaxLineLengthOutput = $MaxLength
  
  # Write output
  
  IF ($MaxLineLength -eq $true) {
    Write-Output $MaxLineLengthOutput
  } ELSEIF ($IsWarning -eq $true) {
    Write-Warning $HRoutput -WarningAction Continue
  } ELSEIF ($IsVerbose -eq $true) {
    # Set Verbose message display
    # $VerbosePreference = "Continue"
    # $VerbosePreference = "SilentlyContinue"
    #$OrigVerbosePreference = $VerbosePreference
    #$VerbosePreference = "Continue"
    Write-Verbose $HRoutput
    #$VerbosePreference = $OrigVerbosePreference
  } ELSE {
    Write-Host $HRoutput
  }

} # End Write-HorizontalRuleAdv function -------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

If ($LoadFunctions) {
  #https://stackoverflow.com/questions/2022326/terminating-a-script-in-powershell
  # Only load functions of script. Do not execute Main script block.
  Return
}

#-----------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------[Execution]------------------------------------------------------

Start-Log -LogPath $sLogPath -LogName $sLogName -ScriptVersion $sScriptVersion

# run "help about_comment_based_help" - I want to display formatted help for a function or script. Use comment-based help instead - run "help about_comment_based_help". PowerShell will format it for you.
# https://technet.microsoft.com/en-us/library/dd819489.aspx
# Write-Host - You almost never need to do it. 
# Write-Information - Only works if $ErrorActionPreference = 'Continue' Does not work if = 'SilentlyContinue' Prints grey text. Can be overridden with -InformationAction Continue
# Write-Verbose - Writes yellow VERBOSE: messages (9 chars). Can be turned on/off by running script with -Verbose parameter.
# Write-Debug - Pauses script execution every time it's called. Can be turned on/off by running script with -Debug parameter.
# Write-Warning - Writes yellow WARNING: messages (9 chars), regardless of -Verbose or -Debug switches.
# Write-Error - Only works if $ErrorActionPreference = 'Continue' Does not work if = 'SilentlyContinue' Prints in red text, "Entire Script path: Error message." E.g. C:\Users\G\Documents\SpiderOak Hive\Consulting\2018-04-06 SodaLakeNetworking\Manage-SodaLakeData.ps1 : TEST ERROR.
# Write-Output - I just need to display some text! Do you really? PowerShell works better with objects, and that's what your script should be outputting, by means of Write-Output. Let PowerShell's Format cmdlets turn those objects into text like lists and tables.
# Write-Progress - Makes a green and yellow progress bar appear at the top part of the command window.

Write-Host "Script Main beginning." $MyInvocation.MyCommand.Name
Write-Information -MessageData "Will only display if set defaults display infromational messages."
Write-Information -MessageData "Test infromational messages." -InformationAction Continue
Write-Verbose "Script Main beginning. $ScriptName"
Write-Verbose "Debug preference = $DebugPreference"
Write-Debug "Script Main beginning." # NOTE: Writing debug text will PAUSE script execution automatically.
Write-Warning "Test Warning."
Write-Error -Message "TEST ERROR. TEST ERROR. TEST ERROR. TEST ERROR." -Category InvalidData -ErrorId TEST_ID
For ($I = 1; $I -le 100; $I++) {Write-Progress -Activity "Test in progress..." -Status "$I% Complete:" -PercentComplete $I;}
#For ($I = 1; $I -le 1000; $I++) {Write-Progress -Activity "Test in progress..." -Status "$($I / 10)% Complete:" -PercentComplete ($I/10)}

# Write-LogInfo – Writes an informational message to the log file
# Write-LogWarning – Writes a warning message to the log file (with the format of WARNING: )
# Write-LogError – Writes an error message to the log file (with the format of ERROR: ). In addition, optionally calls Stop-Log to end logging and terminate the calling script on fatal error.

Write-LogInfo -LogPath $sLogFile -Message "Test log info write."
Write-LogWarning -LogPath $sLogFile -Message "Test log warning write."
Write-LogError -LogPath $sLogFile -Message "Test log error write."

# https://ss64.com/ps/read-host.html
#$Choice = Read-Host -Prompt "Enter text to be caputred" # CHOICE (Read-Host automatically adds colon at the end of prompt)
# https://ss64.com/ps/syntax-esc.html
#Write-Host "Captured text = `"$Choice`""

#Read-Host "Press ENTER key to continue . . . " # PAUSE (Read-Host automatically adds colon : at the end of prompt)
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

# -----------------------------------------------------------------------------------------------------------------------
# =======================================================================================================================
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#
#
##Script MAIN Execution goes here
Clear-Host # CLS

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Test first function

#GenerateSQL-InboxProcessingProject -UserID 0 -SelectedInboxID 10 -NewProjectName "Test new name" -NewProjectDescription "Description new test."
#GenerateSQL-InboxProcessingProject -UserID 0 -SelectedInboxID 10 -NewProjectName "Test new name" -NewProjectDescription "Description new test." -Debug

Write-Host `n
Write-Host "End SQL function test."
Write-HorizontalRuleAdv -HRtype DashedLine
#PAUSE

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

$SelectedUserID = $defaultUserID

If ($RecentlyAddedInboxItem) {Clear-Variable RecentlyAddedInboxItem}

do
{
	Clear-Host # CLS
	Write-Host "Selected User ID: $SelectedUserID"
	Write-HorizontalRuleAdv -HRtype DashedLine
	#Write-Host `n
	Write-Host "  Select option:" -ForegroundColor Green
	Write-Host "    A - [A]dd to Inbox"
	Write-Host "    P - [P]rocess Inbox"
	Write-Host "    U - Change [U]ser ID"
	Write-Host "    T - Project function [T]est"
	Write-Host "    Q - [Q]uit"
	#Write-Host `n
	Write-HorizontalRuleAdv -HRtype DashedLine
	#Write-Host "Choose Pipsqueak SQL command to generate."
	# If run from shell, will create a dialog box. If run in script, will show choice text in command line.
	# https://social.technet.microsoft.com/wiki/contents/articles/24030.powershell-demo-prompt-for-choice.aspx
	$Title = "Pipsqueak SQL Macro tool"
	$Info = "Choose Pipsqueak SQL command to generate."
	# &Power makes P a Hot Key. 
	$ChoiceAddToInbox = New-Object System.Management.Automation.Host.ChoiceDescription "&Add to Inbox", "[A]dd to new item to Inbox."
	$ChoiceProcessInbox = New-Object System.Management.Automation.Host.ChoiceDescription "&Process Inbox", "Go to [P]rocessing Inbox Menu"
	$ChoiceChangeUserID = New-Object System.Management.Automation.Host.ChoiceDescription "Change &User ID", "Change the selected [U]ser ID. Currently selected: $SelectedUserID"
	$ChoiceProject = New-Object System.Management.Automation.Host.ChoiceDescription "Project &Test", "[T]est `"Process from Inbox to Projects list`" function."
	$ChoiceQuit = New-Object System.Management.Automation.Host.ChoiceDescription "&Quit", "[Q]uit, prints `"Good Bye!!!`" in green and exits."
	$Options = [System.Management.Automation.Host.ChoiceDescription[]]($ChoiceAddToInbox, $ChoiceProcessInbox, $ChoiceChangeUserID, $ChoiceProject, $ChoiceQuit)
	# default choice: 0 = first Option, 1 = second option, etc.
	[int]$defaultchoice = 1
	# PromptForChoice() output will always be int https://powershell.org/forums/topic/question-regarding-result-host-ui-promptforchoice/
	$answer = $host.UI.PromptForChoice($Title, $Info, $Options, $defaultchoice)
	#help about_switch
	switch ($answer)
	{
		0 { # Add to Inbox - $ChoiceAddToInbox
			#GenerateSQL-AddToInbox -UserID $SelectedUserID
			$RecentlyAddedInboxItem = GenerateSQL-AddToInbox -UserID $SelectedUserID
			
			Write-Host `n
			Write-Host "End Add to Inbox SQL function."
			Write-HorizontalRuleAdv -HRtype DashedLine
			PAUSE
		}
		1 { # Process Inbox - $ChoiceProcessInbox
			do
			{
				Write-Host `n
				Clear-Host # CLS
				Write-Host "Selected User ID: $SelectedUserID"
				Write-HorizontalRuleAdv -Endcaps 
				Write-Host "  Process Inbox:" -ForegroundColor Yellow
				#Write-Host `n
				Write-HorizontalRuleAdv -Endcaps -EndcapCharacter " "
				#Write-Host `n
				Write-Host "    [A] - Add to Inbox"
				If ($RecentlyAddedInboxItem.NewID) {
				#Write-Host "    Recently added ID:   '$RecentlyAddedInboxItem.NewID'" -ForegroundColor Yellow
				Write-Host "    Recently added ID:   '$($RecentlyAddedInboxItem.NewID)'" -ForegroundColor Yellow
				}
				If ($RecentlyAddedInboxItem.NewItemName) {
				#Write-Host "    Recently added Name: '$RecentlyAddedInboxItem.NewItemName'" -ForegroundColor Yellow
				Write-Host "    Recently added Name: '$($RecentlyAddedInboxItem.NewItemName)'" -ForegroundColor Yellow
				}
				Write-Host `n
				Write-Host "    [D] - Add Deadline to Project"
				Write-Host `n
				Write-Host "    [T] - Test option."
				Write-Host `n
				If ($CurrentlySelectedInboxID) {
				Write-Host "    Selected Inbox ID:   '$CurrentlySelectedInboxID'" -ForegroundColor Green
				} ELSE {
				Write-Host "    Selected Inbox ID:   '$CurrentlySelectedInboxID'"
				}
				If ($RecentlyAddedInboxItem.NewID -eq $CurrentlySelectedInboxID) {
					$CurrentlySelectedInboxName = $RecentlyAddedInboxItem.NewItemName
				}
				If ($CurrentlySelectedInboxName) {
				Write-Host "    Selected Inbox Name: '$CurrentlySelectedInboxName'" -ForegroundColor Green
				}
				If ($CurrentlySelectedInboxDateAdded) {
				Write-Host "    Selected Inbox Date Added: '$CurrentlySelectedInboxDateAdded'"
				}
				Write-Host "        [G] - Get your next unprocessed Inbox ID (FIFO)"
				Write-Host "        [I] - Change Inbox ID"
				Write-Host "        [N] - Lookup Inbox item Name"
				Write-Host "        [U] - Count number of Unprocessed Inbox items remaining"
				Write-Host `n
				If ($CurrentlySelectedInboxID) {
				Write-Host "    Process item as..." -ForegroundColor Yellow
				} ELSE {
				Write-Host "    Process item as..."
				}
				Write-Host "        [P] - as Project"
				Write-Host "        [E] - as Next Action (Existing Project)"
				Write-Host "        [C] - to Completion (Trash)"
				Write-Host "        [W] - as Waiting For"
				Write-Host "        [R] - as Reference"
				Write-Host "        [S] - as Someday/Maybe"
				Write-Host `n
				Write-Host "    [Q] - Quit"
				#Write-Host `n
				Write-HorizontalRuleAdv -Endcaps 
				$Title = "Inbox Processing"
				$Info = "Choose Pipsqueak SQL command to generate."
				# &Power makes P a Hot Key. 
				$ChoiceAddToInbox = New-Object System.Management.Automation.Host.ChoiceDescription "&Add to Inbox", "[A]dd to new item to Inbox: HistoryTypeID = 0"
				$ChoiceAddDeadlineToProject = New-Object System.Management.Automation.Host.ChoiceDescription "Add &Deadline", "Add [D]eadline to a Project: HistoryTypeID = 12, Change Project Deadline: HistoryTypeID = 13, Remove Project Deadline: HistoryTypeID = 17"
				$ChoiceTest = New-Object System.Management.Automation.Host.ChoiceDescription "&Test", "Prints `"[T]esting 123...`" in green."
				$ChoiceGetNextInboxID = New-Object System.Management.Automation.Host.ChoiceDescription "&Get next Inbox ID", "[G]et your next unprocessed Inbox item ID (F.irst I.n, F.irst O.ut), and select it."
				$ChoiceChangeInboxID = New-Object System.Management.Automation.Host.ChoiceDescription "Change &Inbox ID", "Change the selected [I]nbox ID. Currently selected Inbox ID: '$CurrentlySelectedInboxID'"
				$ChoiceGetInboxName = New-Object System.Management.Automation.Host.ChoiceDescription "Lookup Inbox &Name", "Lookup the selected Inbox item's [N]ame. Currently selected Inbox item Name: '$CurrentlySelectedInboxName'"
				$ChoiceCountUnprocessedInboxItems = New-Object System.Management.Automation.Host.ChoiceDescription "Count &Unprocessed Items", "Count the number of remaining [U]nprocessed Inbox items."
				$ChoiceProject = New-Object System.Management.Automation.Host.ChoiceDescription "&Project", "Process from Inbox to [P]rojects list: HistoryTypeID = 8, Add Deadline: HistoryTypeID = 12, Add Next Action during Processing: HistoryTypeID = 9"
				$ChoiceNextActionExisting = New-Object System.Management.Automation.Host.ChoiceDescription "Next Action &Existing", "processed from Inbox and deferred to N[E]xt Actions, [E]xisting Project: HistoryTypeID = 14"
				$ChoiceProcessedCompleted = New-Object System.Management.Automation.Host.ChoiceDescription "&Completed", "Processed to [C]ompletion (Trash): HistoryTypeID = 11"
				$ChoiceWaitingFor = New-Object System.Management.Automation.Host.ChoiceDescription "&Waiting For", "processed from Inbox and delegated to [W]aiting For: HistoryTypeID = 7"
				$ChoiceReference = New-Object System.Management.Automation.Host.ChoiceDescription "&Reference", "Processed to [R]eference: HistoryTypeID = 4"
				$ChoiceSomedayMaybe = New-Object System.Management.Automation.Host.ChoiceDescription "&Someday/Maybe", "processed from Inbox to incubate in [S]omeday/Maybe: HistoryTypeID = 2"
				$ChoiceQuit = New-Object System.Management.Automation.Host.ChoiceDescription "&Quit", "[Q]uits back to Main Menu."
				$Options = [System.Management.Automation.Host.ChoiceDescription[]]($ChoiceAddToInbox, $ChoiceAddDeadlineToProject, $ChoiceTest, $ChoiceGetNextInboxID, $ChoiceChangeInboxID, $ChoiceGetInboxName, $ChoiceCountUnprocessedInboxItems, $ChoiceProject, $ChoiceNextActionExisting, $ChoiceProcessedCompleted, $ChoiceWaitingFor, $ChoiceReference, $ChoiceSomedayMaybe, $ChoiceQuit)
				# default choice: 0 = first Option, 1 = second option, 2 = third option, etc.
				[int]$defaultchoice = 3
				# PromptForChoice() output will always be int https://powershell.org/forums/topic/question-regarding-result-host-ui-promptforchoice/
				$InboxProcessingAnswer = $host.UI.PromptForChoice($Title, $Info, $Options, $defaultchoice)
				#help about_switch
				switch ($InboxProcessingAnswer)
				{
					0 { # $ChoiceAddToInbox - Add to Inbox
						Write-Verbose "Choice [A] - Add to Inbox"
						
						#GenerateSQL-AddToInbox -UserID $SelectedUserID
						$RecentlyAddedInboxItem = GenerateSQL-AddToInbox -UserID $SelectedUserID
						
						Write-Host `n
						Write-Host "End Add to Inbox SQL function."
						Write-HorizontalRuleAdv -HRtype DashedLine
						PAUSE
					} 
					1 { # $ChoiceAddDeadlineToProject - Add Deadline to Project
						Write-Verbose "Choice [D] - Add Deadline to Project"
						
						Write-Host `n
						Write-Host "Choice [D] - Add Deadline to Project"
						Write-Host `n
						
						PAUSE
					}
					2 { # $ChoiceTest - Test Item
						Write-Verbose "Choice [T] - Test Item"
						#Write-Host `n
						Write-HorizontalRuleAdv -HRtype DoubleLine
						Write-Host "Testing 123..." -ForegroundColor Green
						Write-HorizontalRuleAdv -HRtype DoubleLine
						PAUSE
					}
					3 { # $ChoiceGetNextInboxID - Get the selected user's next unprocessed Inbox ID
						Write-Verbose "Choice [G] - Get the selected user's next unprocessed Inbox ID"
						Write-Host `n
						Write-Host "Currently selected Inbox ID: '$CurrentlySelectedInboxID'"
						
						#GenerateSQL-GetNextUnproccessedInboxID -UserID $SelectedUserID
						#$CurrentlySelectedInboxID = Read-Host -Prompt "Enter Inbox ID to select" # CHOICE (Read-Host automatically adds colon : at the end of prompt)
						
						#$CurrentlySelectedInboxID = GenerateSQL-GetNextUnproccessedInboxID -UserID $$SelectedUserID
						
						$GetNextInbox = GenerateSQL-GetNextUnproccessedInboxID -UserID $SelectedUserID
						
						$CurrentlySelectedInboxID = $GetNextInbox.NextID
						$CurrentlySelectedInboxName = $GetNextInbox.NextItemName
						$CurrentlySelectedInboxDateAdded = $GetNextInbox.NextItemDateAdded
						
						Write-Verbose "Next Unprocessed Inbox ID: '$CurrentlySelectedInboxID'"
						Write-Verbose "Next Unprocessed Inbox Item name: '$CurrentlySelectedInboxName'"
						Write-Verbose "Next Unprocessed Inbox Item Date Added: '$CurrentlySelectedInboxDateAdded'"
						#If ($VerbosePreference -ne "SilentlyContinue") {PAUSE}
						
						Write-Host "Newly selected Inbox ID: '$CurrentlySelectedInboxID'"
						Write-HorizontalRuleAdv -HRtype DashedLine
						PAUSE
					}
					4 { # $ChoiceChangeInboxID - Change currently selected Inbox ID
						Write-Verbose "Choice [I] - Change currently selected Inbox ID"
						Write-Host `n
						Write-Host "Currently selected Inbox ID: '$CurrentlySelectedInboxID'"
						Write-Host `n
						$CurrentlySelectedInboxID = Read-Host -Prompt "Enter new Inbox ID to select" # CHOICE (Read-Host automatically adds colon : at the end of prompt)
						Write-Host `n
						Write-Host "Newly selected Inbox ID: '$CurrentlySelectedInboxID'"
						Write-HorizontalRuleAdv -HRtype DashedLine
						PAUSE
					}
					5 { # $ChoiceGetInboxName - Lookup selected Inbox ID record's Item Name
						Write-Verbose "Choice [N] - Lookup selected Inbox ID record's Item Name"
						Write-Host `n
						Write-Host "Currently selected Inbox ID: '$CurrentlySelectedInboxID'"
						Write-Host "Currently selected Inbox Item Name: '$CurrentlySelectedInboxName'"
						Write-Host `n
						$CurrentlySelectedInboxName = GenerateSQL-GetInboxItemName -SelectedInboxID $CurrentlySelectedInboxID
						Write-Host `n
						Write-Host "Newly selected Inbox Item Name: '$CurrentlySelectedInboxName'"
						Write-HorizontalRuleAdv -HRtype DashedLine
						PAUSE
					}
					6 { # $ChoiceCountUnprocessedInboxItems - Count how many Unprocessed Inbox items user has
						Write-Verbose "Choice [U] - Count how many Unprocessed Inbox items user has"
						
						Write-Host `n
						Write-Host "Choice [U] - Count how many Unprocessed Inbox items user has"
						Write-Host `n
						
						PAUSE
					}
					7 { # $ChoiceProject - Process as Project
						Write-Verbose "Choice [P] - Process as Project"
						
						#GenerateSQL-InboxProcessingProject -UserID $SelectedUserID -SelectedInboxID 10 -NewProjectName "Test new name" -NewProjectDescription "Description new test." -Debug
						#GenerateSQL-InboxProcessingProject -UserID $SelectedUserID
						
						$CommandString = "GenerateSQL-InboxProcessingProject -UserID $SelectedUserID"
						
						# Attach Inbox ID - (required)
						If ($CurrentlySelectedInboxID) {
							$CommandString += " -SelectedInboxID $CurrentlySelectedInboxID"
						} Else { 
							Write-Host `n
							Write-Host "Currently selected Inbox ID: '$CurrentlySelectedInboxID'"
							Write-Host `n
							$CurrentlySelectedInboxID = Read-Host -Prompt "Enter new Inbox ID to select" # CHOICE (Read-Host automatically adds colon : at the end of prompt)
							Write-Host `n
							Write-Host "Newly selected Inbox ID: '$CurrentlySelectedInboxID'" -ForegroundColor Yellow
							Write-HorizontalRuleAdv -HRtype DashedLine
							PAUSE
							$CommandString += " -SelectedInboxID $CurrentlySelectedInboxID"
						}
						
						# Attach Inbox Item Name - (required)
						If ($CurrentlySelectedInboxName) {
							$CommandString += " -SelectedInboxItemName `"$CurrentlySelectedInboxName`""
						} Else {
							$CurrentlySelectedInboxName = GenerateSQL-GetInboxItemName -SelectedInboxID $CurrentlySelectedInboxID
							$CommandString += " -SelectedInboxItemName `"$CurrentlySelectedInboxName`""
						}
						
						# Ask user if he wants to change the Project Name - (optional)
						Write-Host `n
						Write-Host "Inbox item name: "
						Write-Host "'$CurrentlySelectedInboxName'"
						Write-Host `n
						Write-Host "(to keep Project name the same, just hit Enter.)"
						$NewProjectName = Read-Host -Prompt "What should new project name be?" # CHOICE (Read-Host automatically adds colon : at the end of prompt)
						If ($NewProjectName) {
							Write-Host `n
							Write-Host "New project name: " -ForegroundColor Yellow
							Write-Host "'$NewProjectName'" -ForegroundColor Yellow
							#Write-Host `n
							$CommandString += " -NewProjectName `"$NewProjectName`""
						} Else {
							Write-Host "New project name will be same as Inbox item name." -ForegroundColor Yellow
							Write-Host "'$CurrentlySelectedInboxName'" -ForegroundColor Yellow
						}
						
						# (optional)
						$Title = "Add Project Description?"
						$Info = "Add Description to Project item."
						# &Yes makes Y a Hot Key. 
						$ChoiceYes = New-Object System.Management.Automation.Host.ChoiceDescription "&Yes", "[Y]es, add a Project Description."
						$ChoiceNo = New-Object System.Management.Automation.Host.ChoiceDescription "&No", "[N]o, only needs Project Name."
						$Options = [System.Management.Automation.Host.ChoiceDescription[]]($ChoiceYes, $ChoiceNo)
						# default choice: 0 = first Option, 1 = second option, etc.
						[int]$defaultchoice = 1
						# PromptForChoice() output will always be int https://powershell.org/forums/topic/question-regarding-result-host-ui-promptforchoice/
						$YesNoAnswer = $host.UI.PromptForChoice($Title, $Info, $Options, $defaultchoice)
						#help about_switch
						switch ($YesNoAnswer)
						{
							0 { # Yes
								Write-Host `n
								$NewProjectDesc = Read-Host -Prompt "Project Description" # CHOICE (Read-Host automatically adds colon : at the end of prompt)
								Write-Host `n
								Write-Host "New project description: " -ForegroundColor Yellow
								Write-Host "'$NewProjectDesc'" -ForegroundColor Yellow
								$CommandString += " -NewProjectDescription `"$NewProjectDesc`""
							}
							1 { # No
								# Do Nothing.
							}
						}
						
						# (optional)
						$Title = "Add Next Action?"
						$Info = "Add initial Next Action to go along with Project."
						# &Yes makes Y a Hot Key. 
						$ChoiceYes = New-Object System.Management.Automation.Host.ChoiceDescription "&Yes", "[Y]es, add a Next Action to Project at the same time."
						$ChoiceNo = New-Object System.Management.Automation.Host.ChoiceDescription "&No", "[N]o, only add Project."
						$Options = [System.Management.Automation.Host.ChoiceDescription[]]($ChoiceYes, $ChoiceNo)
						# default choice: 0 = first Option, 1 = second option, etc.
						[int]$defaultchoice = 1
						# PromptForChoice() output will always be int https://powershell.org/forums/topic/question-regarding-result-host-ui-promptforchoice/
						$YesNoAnswer = $host.UI.PromptForChoice($Title, $Info, $Options, $defaultchoice)
						#help about_switch
						switch ($YesNoAnswer)
						{
							0 { # Yes
								Write-Host `n
								$AddlNextAction = Read-Host -Prompt "Next Action" # CHOICE (Read-Host automatically adds colon : at the end of prompt)
								Write-Host `n
								Write-Host "Add-on Next Action: " -ForegroundColor Yellow
								Write-Host "'$AddlNextAction'" -ForegroundColor Yellow
								$CommandString += " -FirstNextActionName `"$AddlNextAction`""
							}
							1 { # No
								# Do Nothing.
							}
						}
						
						# (optional)
						$Title = "Add Project Deadline?"
						$Info = "Add deadline to go along with new project."
						# &Yes makes Y a Hot Key. 
						$ChoiceYes = New-Object System.Management.Automation.Host.ChoiceDescription "&Yes", "[Y]es, add a Deadline to the Project right now."
						$ChoiceNo = New-Object System.Management.Automation.Host.ChoiceDescription "&No", "[N]o, only add Project."
						$Options = [System.Management.Automation.Host.ChoiceDescription[]]($ChoiceYes, $ChoiceNo)
						# default choice: 0 = first Option, 1 = second option, etc.
						[int]$defaultchoice = 1
						# PromptForChoice() output will always be int https://powershell.org/forums/topic/question-regarding-result-host-ui-promptforchoice/
						$YesNoAnswer = $host.UI.PromptForChoice($Title, $Info, $Options, $defaultchoice)
						#help about_switch
						switch ($YesNoAnswer)
						{
							0 { # Yes
								Write-Host `n
								
								#-- Set Date/Time value to variable:
								#-- https://stackoverflow.com/questions/12163315/correct-way-of-setting-datetime-value-to-a-variable-in-sql-server
								#-- Based on the ISO 8601 standard, the following 3 formats in the question are valid:
								# = '20131201'
								# = '2013-12-01T00:00:00.000'
								# = '2013-12-01T00:00:00'
								#-- https://stackoverflow.com/questions/1138142/best-way-to-convert-and-validate-a-date-string
								#-- always use ISO-8601 format which will work regardless of what current date format is set in SQL Server.
								#-- SO-8601 format is YYYYMMDD for just dates, or YYYY-MM-DDTHH:MM:SS for date with time - so I'd write your code as:
								
								# https://ss64.com/ps/get-date.html
								# PowerShell - Retrieve the current date and time in strict ISO 8601 format:
								# PS C:\> Get-Date -format s
								# 2018-11-26T14:43:04
								
								$CurrentTimeStampSQL = Get-Date -Format s
								
								# Bugfix: For LibreOffice Base, it doesn't want '2013-12-01T00:00:00' or '2013-12-01T00:00:00.000', it wants '2013-12-01 00:00:00' or '2013-12-01 00:00:00.000'
								#$CurrentTimeStampSQL = $CurrentTimeStampSQL.Replace("T", " ")
								
								$NewDeadline = Read-Host -Prompt "Enter Deadline" # CHOICE (Read-Host automatically adds colon : at the end of prompt)
								Write-Host `n
								Write-Host "New Deadline: " -ForegroundColor Yellow
								Write-Host "'$NewDeadline'" -ForegroundColor Yellow
								$CommandString += " -NewProjectDeadline $NewDeadline"
							}
							1 { # No
								# Do Nothing.
							}
						}
						
						Write-Verbose `n
						Write-HorizontalRuleAdv -HRtype DashedLine -IsVerbose
						Write-Verbose "Assembled command string:"
						Write-Verbose $CommandString
						Write-HorizontalRuleAdv -HRtype DashedLine -IsVerbose
						Write-Verbose `n
						Write-Debug "`n`nAssembled command string: `n`n$CommandString" # NOTE: Writing debug text will PAUSE script execution automatically.
						
						Invoke-Expression $CommandString
						
						Write-Host `n
						Write-Host "End Process Inbox item to Project SQL function."
						Write-HorizontalRuleAdv -HRtype DashedLine
						PAUSE
						
					}
					8 { # $ChoiceNextActionExisting - processed from Inbox and deferred to Next Actions (Existing Project)
						Write-Verbose "Choice [E] - processed from Inbox and deferred to Next Actions (Existing Project)"
						
						Write-Host `n
						Write-Host "Choice [E] - processed from Inbox and deferred to Next Actions (Existing Project)"
						Write-Host `n
						
						PAUSE
					}
					9 { # $ChoiceProcessedCompleted - Processed to Completion (Trash)
						Write-Verbose "Choice [C] - Processed to Completion (Trash)"
						
						Write-Host `n
						Write-Host "Choice [C] - Processed to Completion (Trash)"
						Write-Host `n
						
						PAUSE
					}
					10 { # $ChoiceWaitingFor - processed from Inbox and delegated to Waiting For
						Write-Verbose "Choice [W] - processed from Inbox and delegated to Waiting For"
						
						Write-Host `n
						Write-Host "Choice [W] - processed from Inbox and delegated to Waiting For"
						Write-Host `n
						
						PAUSE
					}
					11 { # $ChoiceReference - Processed to Reference
						Write-Verbose "Choice [R] - Processed to Reference"
						
						Write-Host `n
						Write-Host "Choice [R] - Processed to Reference"
						Write-Host `n
						
						PAUSE
					}
					12 { # $ChoiceSomedayMaybe - processed from Inbox to incubate in Someday/Maybe
						Write-Verbose "Choice [S] - processed from Inbox to incubate in Someday/Maybe"
						
						Write-Host `n
						Write-Host "Choice [S] - processed from Inbox to incubate in Someday/Maybe"
						Write-Host `n
						
						PAUSE
					}
					13 { # $ChoiceQuit - Quit
						Write-Verbose "Choice [Q] - Quit"
						Write-Host "Finished Inbox Processing." -ForegroundColor Green
						#Return
						#Break	
					}
				}
				#PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
			}
			until ($InboxProcessingAnswer -eq 13)
		}
		2 { # Change currently selected User ID - $ChoiceChangeUserID
			Write-Host `n
			Write-Host "Currently selected User ID: '$SelectedUserID'"
			Write-Host `n
			$SelectedUserID = Read-Host -Prompt "Enter new User ID to select" # CHOICE (Read-Host automatically adds colon : at the end of prompt)
			Write-Host `n
			Write-Host "Newly selected User ID: '$SelectedUserID'"
			Write-HorizontalRuleAdv -HRtype DashedLine
			PAUSE
		}
		3 { # Process as Project test - $ChoiceProject
			GenerateSQL-InboxProcessingProject -UserID $SelectedUserID -SelectedInboxID 10 -NewProjectName "Test new name" -NewProjectDescription "Description new test."
			#GenerateSQL-InboxProcessingProject -UserID $SelectedUserID -SelectedInboxID 10 -NewProjectName "Test new name" -NewProjectDescription "Description new test." -Debug
			
			Write-Host `n
			Write-Host "End Process Inbox item to Project SQL function test."
			Write-HorizontalRuleAdv -HRtype DashedLine
			PAUSE
		}
		4 { # Quit - $ChoiceQuit
			Write-Host "Good Bye!!!" -ForegroundColor Green
			Return
		}
	}
    #PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
}
until ($answer -eq '4') 

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
do
{
     Show-Menu
     $input = Read-Host "Please make a selection"
     switch ($input)
     {
           '1' {
                cls
                'You chose option #1'
           } '2' {
                cls
                'You chose option #2'
           } '3' {
                cls
                'You chose option #3'
           } 'q' {
                return
           }
     }
     pause
}
until ($input -eq 'q') 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-Verbose "/Script body."

# =======================================================================================================================

Write-HorizontalRuleAdv -HRtype DoubleLine
Write-Host `n
Write-Host "End of script" $MyInvocation.MyCommand.Name
Write-Host `n
PAUSE
Write-Host `n

#Script MAIN Execution ends here
#
#
#
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# =======================================================================================================================
# -----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------[Footer]---------------------------------------------------------

Write-Verbose "Script Main end. $ScriptName"
Write-Debug "End-of-script. $ScriptName"
Write-LogInfo -LogPath $sLogFile -Message "End of script $ScriptName"
Stop-Log -LogPath $sLogFile
Write-Output $sLogFile
